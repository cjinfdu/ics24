{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/android-chrome-192x192.png","path":"images/android-chrome-192x192.png","modified":1,"renderable":0},{"_id":"source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":0},{"_id":"source/images/logos.png","path":"images/logos.png","modified":1,"renderable":0},{"_id":"source/staff/black.jpg","path":"staff/black.jpg","modified":1,"renderable":0},{"_id":"source/staff/houze.jpg","path":"staff/houze.jpg","modified":1,"renderable":0},{"_id":"source/staff/haotian.jpg","path":"staff/haotian.jpg","modified":1,"renderable":0},{"_id":"source/staff/jizhou.JPG","path":"staff/jizhou.JPG","modified":1,"renderable":0},{"_id":"source/staff/lingyu.jpg","path":"staff/lingyu.jpg","modified":1,"renderable":0},{"_id":"source/staff/yangyang.jpg","path":"staff/yangyang.jpg","modified":1,"renderable":0},{"_id":"source/staff/yifan.jpg","path":"staff/yifan.jpg","modified":1,"renderable":0},{"_id":"source/staff/yiyang.JPG","path":"staff/yiyang.JPG","modified":1,"renderable":0},{"_id":"source/staff/yuchen.jpg","path":"staff/yuchen.jpg","modified":1,"renderable":0},{"_id":"source/staff/zenghao.jpg","path":"staff/zenghao.jpg","modified":1,"renderable":0},{"_id":"source/staff/zhouwu.JPG","path":"staff/zhouwu.JPG","modified":1,"renderable":0},{"_id":"source/staff/old/caibo.jpg","path":"staff/old/caibo.jpg","modified":1,"renderable":0},{"_id":"source/staff/old/jiahao.jpg","path":"staff/old/jiahao.jpg","modified":1,"renderable":0},{"_id":"source/staff/old/xiaode.jpg","path":"staff/old/xiaode.jpg","modified":1,"renderable":0},{"_id":"source/staff/old/xixian.png","path":"staff/old/xixian.png","modified":1,"renderable":0},{"_id":"source/staff/old/yuchen.jpg","path":"staff/old/yuchen.jpg","modified":1,"renderable":0},{"_id":"source/staff/old/zhibo.jpg","path":"staff/old/zhibo.jpg","modified":1,"renderable":0},{"_id":"source/staff/old/zhuohan.jpg","path":"staff/old/zhuohan.jpg","modified":1,"renderable":0},{"_id":"themes/cactus-white/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/images/favicon_cactus.ico","path":"images/favicon_cactus.ico","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/images/theme overview.psd","path":"images/theme overview.psd","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/justified-gallery/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/justified-gallery/justifiedGallery.min.css","path":"lib/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/styles.css","path":"lib/meslo-LG/styles.css","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Regular.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"source/index.md","hash":"6b71c73a88bbca59108c23b6035e0d04e287212e","modified":1730353021938},{"_id":"source/.DS_Store","hash":"c442bd939a3ff343099cd380d96bd21bfc6d9b7e","modified":1730352744601},{"_id":"source/images/android-chrome-192x192.png","hash":"9259de0741219fac922d90fc4de907d85692de35","modified":1727272032352},{"_id":"source/images/favicon.ico","hash":"4489366123f382ff7d4359f1b42951c5083063cf","modified":1727272032352},{"_id":"source/_posts/BombLab.md","hash":"11082089ca49d819d5c929c667417c54232aa7b6","modified":1728524544530},{"_id":"source/images/logos.png","hash":"f2186248894521fe8557872c80f0f34818b999e0","modified":1727272032352},{"_id":"source/_posts/.DS_Store","hash":"00c78e300c97d78a62c250e1d205ebc45a7edd71","modified":1730352689277},{"_id":"source/_posts/DataLab.md","hash":"e6db5187cfa1d2d6976e2825891171397b5b548c","modified":1727272032340},{"_id":"source/_posts/StackLab.md","hash":"132fe5d8c19947a7c7d97445bab6fb4ab21931a7","modified":1730450220820},{"_id":"source/_posts/GitLab.md","hash":"8152cb783db1b33b1e3a74a53306c6ab1ac2055a","modified":1727272032347},{"_id":"source/images/apple-touch-icon.png","hash":"d67cef1f9f60fc4a574ee44fc1a04dd496112071","modified":1727272032352},{"_id":"source/_posts/ICS实验入门手册.md","hash":"585b8036377357d241305c758b741d773c59c4af","modified":1727272032352},{"_id":"source/staff/houze.jpg","hash":"73f4f5026289f9f8cee28c52df4e9efd955924f5","modified":1727272032354},{"_id":"source/staff/haotian.jpg","hash":"e441c87014527dcf675485c063e79d37087edb86","modified":1727272032353},{"_id":"source/staff/index.md","hash":"36adef7631e336487336a380ac1fedafe102908f","modified":1727272032354},{"_id":"source/staff/lingyu.jpg","hash":"c07750a224754f562772fab5b6e96c9aa2ec1b57","modified":1727272032358},{"_id":"source/staff/.DS_Store","hash":"039ab2732c7b3e93cd6af52af8540155545d8f08","modified":1727666417111},{"_id":"source/_posts/BombLab/.DS_Store","hash":"569c1e77bc5663fb1cd3f01d30f812ccdcc620f3","modified":1728518106842},{"_id":"source/_posts/BombLab/meme.jpg","hash":"1f673e6c6b9a34c6b560ba13917ebd97550abdba","modified":1728387651567},{"_id":"source/_posts/DataLab/Driverhdrs.pm","hash":"051b43db7c948628953f4dfba56dad3454f9eb2b","modified":1727272032340},{"_id":"source/_posts/DataLab/Driverlib.pm","hash":"7246ddea38818dbc0ae3249c136bc851ce93083a","modified":1727272032340},{"_id":"source/_posts/DataLab/README","hash":"84d7352e4bc53b8862f192d1194b8701bf61adc0","modified":1727272032341},{"_id":"source/_posts/DataLab/Makefile","hash":"3afcbba9483d82cc5e017280386c3a55aa4abde0","modified":1727272032340},{"_id":"source/_posts/DataLab/bits.h","hash":"adcae9beb0ba7940f75a65aeb00aded13c870f7b","modified":1727272032341},{"_id":"source/_posts/DataLab/decl.c","hash":"e8ef7677656a0c96e11e936acb397ebd46eeff50","modified":1727272032341},{"_id":"source/_posts/DataLab/btest.c","hash":"13ee0952347ffedb987b0da301e0d0e98c2fe5c8","modified":1727272032341},{"_id":"source/_posts/DataLab/btest.h","hash":"60f0175ad796b0132ff71e461da35b2165a5ad14","modified":1727272032341},{"_id":"source/_posts/DataLab/bits.c","hash":"caa8f2e464abc57054d5854214e8f973ff7c2c11","modified":1727272032341},{"_id":"source/_posts/DataLab/fshow.c","hash":"6b24f8648f01a7dd53fcee3736fc8a9e1979f739","modified":1727272032345},{"_id":"source/_posts/DataLab/ishow.c","hash":"dc4aed58eea4ec0ffd23f5208ff50d1a1f988496","modified":1727272032345},{"_id":"source/_posts/DataLab/tests.c","hash":"1825d7733cc94304bf34508ae4a5bc6f8111a1c8","modified":1727272032345},{"_id":"source/_posts/DataLab/tmp.md","hash":"ff9dd896f0f2250cd1101d1dcc72f75a83728e82","modified":1727272032347},{"_id":"source/_posts/DataLab/driver.pl","hash":"d3f972c574378e60247ed0d945ebfbbab035c6e3","modified":1727272032344},{"_id":"source/_posts/GitLab/1.png","hash":"7ea830676745caad94c5b9037cc575b83e51053d","modified":1727272032348},{"_id":"source/_posts/GitLab/11.png","hash":"a64de44db9073afced50744d54f9ea49d7714466","modified":1727272032348},{"_id":"source/_posts/GitLab/10.png","hash":"ae5ed1a41e5c4fd9f9cd05ccc38074550c94cb30","modified":1727272032348},{"_id":"source/_posts/GitLab/.DS_Store","hash":"cc39732fda44c1af631d0e96b0ac8ae9506b5b4c","modified":1726639703334},{"_id":"source/_posts/GitLab/4.png","hash":"40b6a66b4fab45b8f2494fb2fcac9194e556ac75","modified":1727272032349},{"_id":"source/_posts/GitLab/3.png","hash":"b261aea8210273ff7e38990ec4839fde13a92cdf","modified":1727272032349},{"_id":"source/_posts/GitLab/6.png","hash":"e1bac9d064ab9b8adf62fa98d608adee705e5751","modified":1727272032350},{"_id":"source/_posts/StackLab/.DS_Store","hash":"42f4d24c714dcc02ee52e95f7246bef6262201f2","modified":1730352744599},{"_id":"source/staff/old/caibo.jpg","hash":"ada5bf77434aaa7e1bdbe4e23b140fc62abdb93b","modified":1727272032358},{"_id":"source/staff/old/zhibo.jpg","hash":"cae260ef3f77ed2b6366bb5b542e83edd4f9cc42","modified":1727272032366},{"_id":"source/_posts/GitLab/8.png","hash":"6e96461c525b8a0cddffb7b98f4d63c40713f942","modified":1727272032350},{"_id":"source/_posts/StackLab/task3_result.gif","hash":"2b7f7c916dac860f69a653a52a599f189e8ad8c1","modified":1730310757000},{"_id":"source/staff/old/zhuohan.jpg","hash":"17c2e8fcb27538bb3dd65338aba9d84f6fb0a622","modified":1727272032366},{"_id":"source/staff/black.jpg","hash":"392202a45b1955be88f51394dff7c67ad4c12323","modified":1727272032353},{"_id":"source/staff/yifan.jpg","hash":"3a124443ada57c406a5a81af1deef86f8198cacf","modified":1727272032367},{"_id":"source/staff/zhouwu.JPG","hash":"ca18ddd6253d4b3d53beeab663182d6d6c581536","modified":1727272032371},{"_id":"source/staff/yangyang.jpg","hash":"3a27474d9fcfe0022fb21e65dfdddfd4238d626b","modified":1727272032367},{"_id":"source/staff/zenghao.jpg","hash":"58015f5b9694c78ee5b9acd7f70064d2a5a256b6","modified":1727272032371},{"_id":"source/_posts/GitLab/2.png","hash":"2a02f426ccac75c6f2640408ed028ab1942dd8f2","modified":1727272032348},{"_id":"source/_posts/GitLab/5.png","hash":"c6d2a2ed102afc9aa93fcd22597530e87f150b48","modified":1727272032349},{"_id":"source/_posts/GitLab/7.png","hash":"594f6c108b52774111fe13d194e2fb7436587d67","modified":1727272032350},{"_id":"source/staff/old/yuchen.jpg","hash":"7df08a61c0bd6a3fbfa33567fb2966382721d85a","modified":1727272032366},{"_id":"source/staff/yuchen.jpg","hash":"bba0e6b46b467271fe382a500041c555dfb02b18","modified":1727272032371},{"_id":"source/_posts/BombLab/cfg.png","hash":"dc87c30698735bd0cbf51f0c5bd92b992008c5c6","modified":1728387859348},{"_id":"source/_posts/GitLab/9.png","hash":"dc2ccb602715931f52689dd04dbcd4d0bd77e40a","modified":1727272032351},{"_id":"source/_posts/BombLab/PlotAdvices.png","hash":"9ba87dc3a9629f0b93fe1087850ec5e4814c72ff","modified":1728386508432},{"_id":"source/staff/old/xixian.png","hash":"3bbf2faff9776a23f72460cca65317836abef741","modified":1727272032366},{"_id":"themes/cactus-white/LICENSE","hash":"6c2233da6ccbf42c2d2fdd8a137c8a050cb97e21","modified":1727272032372},{"_id":"themes/cactus-white/README.md","hash":"10723cf57ac18800f9693cfdf6e34a94d012c599","modified":1727272032372},{"_id":"themes/cactus-white/_config.yml","hash":"8bf7c9c8f0751bf371d21a5518e7c5012a7230fd","modified":1727272032372},{"_id":"themes/cactus-white/layout/index.ejs","hash":"d60d93d16cd18484ff90013821730c2f10b0e09c","modified":1727272032377},{"_id":"themes/cactus-white/layout/layout.ejs","hash":"8484532ad7c4da22f46fc1394bb2fd9ded34be1f","modified":1727272032377},{"_id":"themes/cactus-white/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1727272032377},{"_id":"themes/cactus-white/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1727272032378},{"_id":"themes/cactus-white/layout/page.ejs","hash":"d14964cac07f5db45d83af682a7924413f7dd3b6","modified":1727272032377},{"_id":"themes/cactus-white/layout/archive.ejs","hash":"ab9798bf534485a4fed4d3089011421858afdd26","modified":1727272032376},{"_id":"themes/cactus-white/layout/post.ejs","hash":"2731e597b5d1714a6f5a775c432e99785f02a3e3","modified":1727272032377},{"_id":"themes/cactus-white/.DS_Store","hash":"bef894abf59ca86eaf1e455ae31e9ec717ea2f92","modified":1727267144992},{"_id":"themes/cactus-white/layout/_partial/comments.ejs","hash":"853a4500da515ef3facc51a055886eaf8efd080d","modified":1727272032373},{"_id":"themes/cactus-white/layout/_partial/footer.ejs","hash":"7f6b3f126a58e6734b658ab57bc6b41822bc9342","modified":1727272032373},{"_id":"themes/cactus-white/layout/_partial/head.ejs","hash":"7782e6b1ce72fcf121f0017d383e2fb87e72c539","modified":1727272032373},{"_id":"themes/cactus-white/layout/_partial/header.ejs","hash":"889fe54bbfd1fb3357e8c0614d57a437a72f782a","modified":1727272032373},{"_id":"themes/cactus-white/layout/_partial/pagination.ejs","hash":"ca660c59aec56daa4a7b41715b97434d4a24c37e","modified":1727272032374},{"_id":"themes/cactus-white/layout/_partial/scripts.ejs","hash":"61b9d9517d07c18360da6177e40436260224eccc","modified":1727272032376},{"_id":"themes/cactus-white/layout/_partial/search.ejs","hash":"1812a10645f635fa8467bf71eed57e704fa3b7cd","modified":1727272032376},{"_id":"themes/cactus-white/layout/_partial/styles.ejs","hash":"6eb7189f05783e7044c7dab16e671176329e7cd3","modified":1727272032376},{"_id":"themes/cactus-white/source/css/_extend.styl","hash":"13e3792845e219246ce9e8b92da26f6c65f4c5c1","modified":1727272032378},{"_id":"themes/cactus-white/source/css/_mixins.styl","hash":"c921ceb620deedddd38c9cec28190995e8764bab","modified":1727272032385},{"_id":"themes/cactus-white/source/css/_util.styl","hash":"f8e286a21c7ec3e771d5ddeb2909ac92390af9bd","modified":1727272032388},{"_id":"themes/cactus-white/source/css/style.styl","hash":"4dc2093b87c76fcc1225103145549fe35d22b80a","modified":1727272032388},{"_id":"themes/cactus-white/source/css/_variables.styl","hash":"66cdadb8c13eb08a33dac135be9486d28eec6e79","modified":1727272032388},{"_id":"themes/cactus-white/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1727272032389},{"_id":"themes/cactus-white/source/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1727272032399},{"_id":"themes/cactus-white/source/images/logo.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1727272032389},{"_id":"themes/cactus-white/layout/_partial/post/actions_desktop.ejs","hash":"063ae931a6902f192e086fe5cceae587d27ed196","modified":1727272032374},{"_id":"themes/cactus-white/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1727272032389},{"_id":"themes/cactus-white/source/images/favicon_cactus.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1727272032389},{"_id":"themes/cactus-white/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1727272032374},{"_id":"themes/cactus-white/layout/_partial/post/actions_mobile.ejs","hash":"64d0f85480997a4fa53c99954e9454c189595e9c","modified":1727272032374},{"_id":"themes/cactus-white/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1727272032375},{"_id":"themes/cactus-white/layout/_partial/post/share.ejs","hash":"25a3406f97e976ec13239f0d3f32f9e512511f50","modified":1727272032375},{"_id":"themes/cactus-white/layout/_partial/post/tag.ejs","hash":"bfab03ef986d35ccad583f2d2b575db4a8d2789e","modified":1727272032375},{"_id":"themes/cactus-white/source/css/_partial/archive.styl","hash":"18fa7f84a9783c5fb56c9f450ea93bd88408e682","modified":1727272032386},{"_id":"themes/cactus-white/source/css/_partial/comments.styl","hash":"11fb41241a13971d23fc3f7e6d60315c7f248396","modified":1727272032386},{"_id":"themes/cactus-white/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1727272032375},{"_id":"themes/cactus-white/source/css/_partial/header.styl","hash":"ba27c6e702e60c3eecb998714ab61284efa4a09b","modified":1727272032386},{"_id":"themes/cactus-white/source/js/search.js","hash":"62493e5477618f259eec9b9d626f5bfd000589df","modified":1727272032400},{"_id":"themes/cactus-white/source/css/_partial/article.styl","hash":"20c222152f6775602815d107a11d2bda512e4c18","modified":1727272032386},{"_id":"themes/cactus-white/source/css/_partial/footer.styl","hash":"9828b9c71781768f2ec74d0535d17966ef020b36","modified":1727272032386},{"_id":"themes/cactus-white/source/css/_partial/pagination.styl","hash":"03a1b81d60dae3dd55963b7e74a6fee83470e6bb","modified":1727272032387},{"_id":"themes/cactus-white/source/css/_partial/search.styl","hash":"4bf70f1ecc5f2c41003ca51a8b0255e32c8c6eba","modified":1727272032387},{"_id":"themes/cactus-white/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1727272032378},{"_id":"themes/cactus-white/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1727272032379},{"_id":"themes/cactus-white/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1727272032379},{"_id":"themes/cactus-white/source/css/_highlight/arta.styl","hash":"25f4d37cbb65409b2245c7c1bd830f18f5cb4227","modified":1727272032379},{"_id":"themes/cactus-white/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1727272032379},{"_id":"themes/cactus-white/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1727272032380},{"_id":"themes/cactus-white/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1727272032380},{"_id":"themes/cactus-white/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1727272032379},{"_id":"themes/cactus-white/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1727272032380},{"_id":"themes/cactus-white/source/css/_partial/index.styl","hash":"e78a3d6254ea6acb339c177692f4d3df7fab87bd","modified":1727272032387},{"_id":"themes/cactus-white/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1727272032380},{"_id":"themes/cactus-white/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1727272032380},{"_id":"themes/cactus-white/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1727272032381},{"_id":"themes/cactus-white/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1727272032381},{"_id":"themes/cactus-white/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1727272032381},{"_id":"themes/cactus-white/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1727272032381},{"_id":"themes/cactus-white/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1727272032381},{"_id":"themes/cactus-white/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1727272032382},{"_id":"themes/cactus-white/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1727272032382},{"_id":"themes/cactus-white/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1727272032382},{"_id":"themes/cactus-white/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1727272032382},{"_id":"themes/cactus-white/source/css/_highlight/kimbie.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1727272032382},{"_id":"themes/cactus-white/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1727272032383},{"_id":"themes/cactus-white/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1727272032383},{"_id":"themes/cactus-white/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1727272032383},{"_id":"themes/cactus-white/source/css/_highlight/paraiso.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1727272032383},{"_id":"themes/cactus-white/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1727272032384},{"_id":"themes/cactus-white/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1727272032384},{"_id":"themes/cactus-white/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1727272032383},{"_id":"themes/cactus-white/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1727272032384},{"_id":"themes/cactus-white/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1727272032384},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1727272032384},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1727272032385},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1727272032385},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1727272032385},{"_id":"themes/cactus-white/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1727272032385},{"_id":"themes/cactus-white/source/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1727272032407},{"_id":"themes/cactus-white/source/css/_partial/post/actions_desktop.styl","hash":"fb5106e42ab607181145e5f4fb78b8ae717ac263","modified":1727272032387},{"_id":"themes/cactus-white/source/css/_partial/post/actions_mobile.styl","hash":"e6a802d7ee1023c5fc5fac18bb0ba3dc03ef2ac8","modified":1727272032387},{"_id":"themes/cactus-white/source/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1727272032406},{"_id":"themes/cactus-white/source/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1727272032414},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1727272032400},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1727272032400},{"_id":"source/staff/old/jiahao.jpg","hash":"26afcb5e8abad8a39eca824089dc7a9c16932d73","modified":1727272032360},{"_id":"themes/cactus-white/source/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1727272032406},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1727272032405},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1727272032405},{"_id":"source/staff/yiyang.JPG","hash":"2c6171d574782ad2438e384f5f316ad18e02ad72","modified":1727272032370},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1727272032401},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1727272032401},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1727272032403},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1727272032403},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1727272032409},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1727272032411},{"_id":"source/staff/jizhou.JPG","hash":"eef121a365294496a55c5c280e890b9fb03ad674","modified":1727272032358},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1727272032414},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1727272032408},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1727272032410},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1727272032409},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1727272032411},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1727272032412},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1727272032412},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1727272032407},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1727272032413},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1727272032414},{"_id":"source/_posts/DataLab/dlc","hash":"0c17f3fee79e9068b80e8a6412457a44c1024228","modified":1727272032344},{"_id":"source/staff/old/xiaode.jpg","hash":"f4af5d5519c70cc85c593af53341620c47d624c1","modified":1727272032365},{"_id":"themes/cactus-white/source/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1727272032399},{"_id":"public/staff/index.html","hash":"b6c84102d69beb96e484965dd7b84a575888071d","modified":1730450253927},{"_id":"public/StackLab/index.html","hash":"77b3ef5b3bdee7ab14b5f497a3e88f3f8a5ab025","modified":1730450253927},{"_id":"public/index.html","hash":"0d540cddf558a30a60552bf12c4af4b4a15bae42","modified":1730450253927},{"_id":"public/BombLab/index.html","hash":"5444c2a973f43dcfbbbb74249344f95dd4f2652f","modified":1730450253927},{"_id":"public/ICS实验入门手册/index.html","hash":"91d9e3d0eeda5c17255c0ced61310bbd9771efb9","modified":1730450253927},{"_id":"public/GitLab/index.html","hash":"99bd165616f179b9be55c2b062d26d00c433b1ff","modified":1730450253927},{"_id":"public/DataLab/index.html","hash":"5c0ebf99db55d7f4a762d397a3d64a3e433e5894","modified":1730450253927},{"_id":"public/DataLab/tmp/index.html","hash":"f0ddf787451c53d34ce3e955d1a7577c14555897","modified":1730450253927},{"_id":"public/archives/index.html","hash":"880c5105e4882c26a02d39dc420de8c8f5b89c97","modified":1730450253927},{"_id":"public/archives/2024/index.html","hash":"30349c75974a5c6a7a02a6fe7364efa59cb8849f","modified":1730450253927},{"_id":"public/archives/2024/09/index.html","hash":"bd60a56595d1b0bc16eb2f21966b128e811e4108","modified":1730450253927},{"_id":"public/archives/2024/10/index.html","hash":"aea9168aaa14c31e60ec53b7f1e11c9845e04a87","modified":1730450253927},{"_id":"public/arc/index.html","hash":"52926266dd99204b0969a0f37a8acc70127ec4b4","modified":1730450253927},{"_id":"public/images/android-chrome-192x192.png","hash":"9259de0741219fac922d90fc4de907d85692de35","modified":1730450253927},{"_id":"public/images/favicon.ico","hash":"4489366123f382ff7d4359f1b42951c5083063cf","modified":1730450253927},{"_id":"public/staff/houze.jpg","hash":"73f4f5026289f9f8cee28c52df4e9efd955924f5","modified":1730450253927},{"_id":"public/staff/haotian.jpg","hash":"e441c87014527dcf675485c063e79d37087edb86","modified":1730450253927},{"_id":"public/images/logos.png","hash":"f2186248894521fe8557872c80f0f34818b999e0","modified":1730450253927},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1730450253927},{"_id":"public/staff/lingyu.jpg","hash":"c07750a224754f562772fab5b6e96c9aa2ec1b57","modified":1730450253927},{"_id":"public/staff/old/caibo.jpg","hash":"ada5bf77434aaa7e1bdbe4e23b140fc62abdb93b","modified":1730450253927},{"_id":"public/staff/old/zhibo.jpg","hash":"cae260ef3f77ed2b6366bb5b542e83edd4f9cc42","modified":1730450253927},{"_id":"public/staff/old/zhuohan.jpg","hash":"17c2e8fcb27538bb3dd65338aba9d84f6fb0a622","modified":1730450253927},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1730450253927},{"_id":"public/images/favicon_cactus.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1730450253927},{"_id":"public/images/logo.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1730450253927},{"_id":"public/BombLab/meme.jpg","hash":"1f673e6c6b9a34c6b560ba13917ebd97550abdba","modified":1730450253927},{"_id":"public/DataLab/Driverhdrs.pm","hash":"051b43db7c948628953f4dfba56dad3454f9eb2b","modified":1730450253927},{"_id":"public/DataLab/Driverlib.pm","hash":"7246ddea38818dbc0ae3249c136bc851ce93083a","modified":1730450253927},{"_id":"public/DataLab/bits.c","hash":"caa8f2e464abc57054d5854214e8f973ff7c2c11","modified":1730450253927},{"_id":"public/DataLab/README","hash":"84d7352e4bc53b8862f192d1194b8701bf61adc0","modified":1730450253927},{"_id":"public/DataLab/Makefile","hash":"3afcbba9483d82cc5e017280386c3a55aa4abde0","modified":1730450253927},{"_id":"public/DataLab/bits.h","hash":"adcae9beb0ba7940f75a65aeb00aded13c870f7b","modified":1730450253927},{"_id":"public/DataLab/btest.c","hash":"13ee0952347ffedb987b0da301e0d0e98c2fe5c8","modified":1730450253927},{"_id":"public/DataLab/decl.c","hash":"e8ef7677656a0c96e11e936acb397ebd46eeff50","modified":1730450253927},{"_id":"public/DataLab/btest.h","hash":"60f0175ad796b0132ff71e461da35b2165a5ad14","modified":1730450253927},{"_id":"public/DataLab/driver.pl","hash":"d3f972c574378e60247ed0d945ebfbbab035c6e3","modified":1730450253927},{"_id":"public/DataLab/ishow.c","hash":"dc4aed58eea4ec0ffd23f5208ff50d1a1f988496","modified":1730450253927},{"_id":"public/DataLab/fshow.c","hash":"6b24f8648f01a7dd53fcee3736fc8a9e1979f739","modified":1730450253927},{"_id":"public/DataLab/tests.c","hash":"1825d7733cc94304bf34508ae4a5bc6f8111a1c8","modified":1730450253927},{"_id":"public/GitLab/10.png","hash":"ae5ed1a41e5c4fd9f9cd05ccc38074550c94cb30","modified":1730450253927},{"_id":"public/GitLab/11.png","hash":"a64de44db9073afced50744d54f9ea49d7714466","modified":1730450253927},{"_id":"public/GitLab/1.png","hash":"7ea830676745caad94c5b9037cc575b83e51053d","modified":1730450253927},{"_id":"public/GitLab/4.png","hash":"40b6a66b4fab45b8f2494fb2fcac9194e556ac75","modified":1730450253927},{"_id":"public/GitLab/8.png","hash":"6e96461c525b8a0cddffb7b98f4d63c40713f942","modified":1730450253927},{"_id":"public/GitLab/6.png","hash":"e1bac9d064ab9b8adf62fa98d608adee705e5751","modified":1730450253927},{"_id":"public/StackLab/task3_result.gif","hash":"2b7f7c916dac860f69a653a52a599f189e8ad8c1","modified":1730450253927},{"_id":"public/GitLab/3.png","hash":"b261aea8210273ff7e38990ec4839fde13a92cdf","modified":1730450253927},{"_id":"public/staff/black.jpg","hash":"392202a45b1955be88f51394dff7c67ad4c12323","modified":1730450253927},{"_id":"public/staff/yangyang.jpg","hash":"3a27474d9fcfe0022fb21e65dfdddfd4238d626b","modified":1730450253927},{"_id":"public/staff/yifan.jpg","hash":"3a124443ada57c406a5a81af1deef86f8198cacf","modified":1730450253927},{"_id":"public/staff/zhouwu.JPG","hash":"ca18ddd6253d4b3d53beeab663182d6d6c581536","modified":1730450253927},{"_id":"public/staff/zenghao.jpg","hash":"58015f5b9694c78ee5b9acd7f70064d2a5a256b6","modified":1730450253927},{"_id":"public/staff/old/yuchen.jpg","hash":"7df08a61c0bd6a3fbfa33567fb2966382721d85a","modified":1730450253927},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1730450253927},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1730450253927},{"_id":"public/css/style.css","hash":"1918b9589c9aca683c9e076c18345a803a823871","modified":1730450253927},{"_id":"public/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1730450253927},{"_id":"public/js/search.js","hash":"62493e5477618f259eec9b9d626f5bfd000589df","modified":1730450253927},{"_id":"public/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1730450253927},{"_id":"public/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1730450253927},{"_id":"public/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1730450253927},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1730450253927},{"_id":"public/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1730450253927},{"_id":"public/DataLab/tmp.html","hash":"c1e05e9b2a1eda18e5647360e4e4d0a0928d20de","modified":1730450253927},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1730450253927},{"_id":"public/GitLab/2.png","hash":"2a02f426ccac75c6f2640408ed028ab1942dd8f2","modified":1730450253927},{"_id":"public/GitLab/5.png","hash":"c6d2a2ed102afc9aa93fcd22597530e87f150b48","modified":1730450253927},{"_id":"public/GitLab/7.png","hash":"594f6c108b52774111fe13d194e2fb7436587d67","modified":1730450253927},{"_id":"public/staff/yuchen.jpg","hash":"bba0e6b46b467271fe382a500041c555dfb02b18","modified":1730450253927},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1730450253927},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1730450253927},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1730450253927},{"_id":"public/BombLab/cfg.png","hash":"dc87c30698735bd0cbf51f0c5bd92b992008c5c6","modified":1730450253927},{"_id":"public/GitLab/9.png","hash":"dc2ccb602715931f52689dd04dbcd4d0bd77e40a","modified":1730450253927},{"_id":"public/staff/old/xixian.png","hash":"3bbf2faff9776a23f72460cca65317836abef741","modified":1730450253927},{"_id":"public/BombLab/PlotAdvices.png","hash":"9ba87dc3a9629f0b93fe1087850ec5e4814c72ff","modified":1730450253927},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1730450253927},{"_id":"public/staff/old/jiahao.jpg","hash":"26afcb5e8abad8a39eca824089dc7a9c16932d73","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1730450253927},{"_id":"public/staff/yiyang.JPG","hash":"2c6171d574782ad2438e384f5f316ad18e02ad72","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1730450253927},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1730450253927},{"_id":"public/staff/jizhou.JPG","hash":"eef121a365294496a55c5c280e890b9fb03ad674","modified":1730450253927},{"_id":"public/DataLab/dlc","hash":"0c17f3fee79e9068b80e8a6412457a44c1024228","modified":1730450253927},{"_id":"public/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1730450253927},{"_id":"public/staff/old/xiaode.jpg","hash":"f4af5d5519c70cc85c593af53341620c47d624c1","modified":1730450253927}],"Category":[],"Data":[],"Page":[{"title":"ICS 2024","_content":"\nFall, 2024\n\nInstructor: [金城](https://cjinfdu.github.io/)\n\nSchool of Computer Science, Fudan University\n\n---\n\n\n## News\n\n- **[Oct 31, 2024]** [StackLab](StackLab) is released.\n- **[Oct 9, 2024]** [BombLab](BombLab) is released.\n- **[Sep 25, 2024]** [DataLab](DataLab) is released.\n- **[Sep 18, 2024]** [GitLab](GitLab) is released.\n- **[Sep 14, 2024]** [ICS实验入门手册](ICS实验入门手册) is released.\n- **[Sep 14 2024]** Course Website is online.\n\n## Schedule\n\n| Num  | Date       | Subject                       | Assignment                                          |\n| :--- | :--------- | :---------------------------- | :-------------------------------------------------- |\n| 01   | 09/06/2024 | 数的表示 I                     |                                                     |\n| 02   | 09/12/2024 | 环境配置                       |                                                     |\n| 03   | 09/13/2024 | 数的表示 II                    |                                                     |\n| 04   | 09/19/2024 | GitLab                       | [Lab0-GitLab](GitLab) (Due: 09/25/2024)              |\n| 05   | 09/20/2024 | 机器码 I                      |                                                     |\n| 06   | 09/26/2024 | DataLab发布                   | [Lab1-DataLab](DataLab) (Due: 10/10/2024)           |\n| 07   | 09/27/2024 | 机器码 II                     |                                                     |\n| 08   | 10/10/2024 | BombLab发布                   | [Lab2BombLab](BombLab) (Due: 10/30/2024)            |\n| 09   | 10/11/2023 | 机器码 III                    |                                                     |\n| 10   | 10/17/2023 | DataLab面试                   |                                                     |\n| 11   | 10/18/2023 | 机器码 IV                     |                                                     |\n| 12   | 10/24/2023 | BombLab答疑                   |                                                     |\n| 13   | 10/25/2023 | 处理器 I                      |                                                     |\n| 14   | 10/31/2023 | StackLab发布                  | [Lab3-StackLab](StackLab) (Due: 11/21/2024)         |\n\n---\n\n```cpp\n#include <iostream>\n#include <coroutine>\n\nstruct task\n{\n    struct promise_type\n    {\n        task get_return_object() { return {}; }\n        std::suspend_never initial_suspend() { return {}; }\n        std::suspend_never final_suspend() noexcept { return {}; }\n        void return_void() {}\n        void unhandled_exception() {}\n    };\n};\n\ntask hello()\n{\n    std::cout << \"Hello, ICS 2024!\" << std::endl;\n    co_return;\n}\n\nint main()\n{\n    hello();\n}\n```\n\n<!-- ```cpp\n#include <stdio.h>\n\nvoid trans(int M, int N, int A[M][N], int B[N][M])\n{\n    int i, j, tmp;\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < M; j++)\n        {\n            tmp = A[i][j];\n            B[j][i] = tmp;\n        }\n    }\n}\n\nstatic int A[256][256];\nstatic int B[256][256];\n\nint main()\n{\n    printf(\"try it, and wait for a year\\n\");\n    trans(256, 256, A, B);\n}\n``` -->\n\n<!--\n```cpp\n#include <stdio.h>\n\n#include \"generator.h\"\n\nint main() {\n    auto coro = []() -> libco::generator<const char> {\n        const char str[] = \"Hello, ICS 2024!\\n\";\n        for (const auto ch : str) {\n            co_yield ch;\n        }\n    }();\n\n    for (const auto ch : coro) {\n        std::cout << ch;\n    }\n}\n```\n-->\n","source":"index.md","raw":"---\ntitle: ICS 2024\n---\n\nFall, 2024\n\nInstructor: [金城](https://cjinfdu.github.io/)\n\nSchool of Computer Science, Fudan University\n\n---\n\n\n## News\n\n- **[Oct 31, 2024]** [StackLab](StackLab) is released.\n- **[Oct 9, 2024]** [BombLab](BombLab) is released.\n- **[Sep 25, 2024]** [DataLab](DataLab) is released.\n- **[Sep 18, 2024]** [GitLab](GitLab) is released.\n- **[Sep 14, 2024]** [ICS实验入门手册](ICS实验入门手册) is released.\n- **[Sep 14 2024]** Course Website is online.\n\n## Schedule\n\n| Num  | Date       | Subject                       | Assignment                                          |\n| :--- | :--------- | :---------------------------- | :-------------------------------------------------- |\n| 01   | 09/06/2024 | 数的表示 I                     |                                                     |\n| 02   | 09/12/2024 | 环境配置                       |                                                     |\n| 03   | 09/13/2024 | 数的表示 II                    |                                                     |\n| 04   | 09/19/2024 | GitLab                       | [Lab0-GitLab](GitLab) (Due: 09/25/2024)              |\n| 05   | 09/20/2024 | 机器码 I                      |                                                     |\n| 06   | 09/26/2024 | DataLab发布                   | [Lab1-DataLab](DataLab) (Due: 10/10/2024)           |\n| 07   | 09/27/2024 | 机器码 II                     |                                                     |\n| 08   | 10/10/2024 | BombLab发布                   | [Lab2BombLab](BombLab) (Due: 10/30/2024)            |\n| 09   | 10/11/2023 | 机器码 III                    |                                                     |\n| 10   | 10/17/2023 | DataLab面试                   |                                                     |\n| 11   | 10/18/2023 | 机器码 IV                     |                                                     |\n| 12   | 10/24/2023 | BombLab答疑                   |                                                     |\n| 13   | 10/25/2023 | 处理器 I                      |                                                     |\n| 14   | 10/31/2023 | StackLab发布                  | [Lab3-StackLab](StackLab) (Due: 11/21/2024)         |\n\n---\n\n```cpp\n#include <iostream>\n#include <coroutine>\n\nstruct task\n{\n    struct promise_type\n    {\n        task get_return_object() { return {}; }\n        std::suspend_never initial_suspend() { return {}; }\n        std::suspend_never final_suspend() noexcept { return {}; }\n        void return_void() {}\n        void unhandled_exception() {}\n    };\n};\n\ntask hello()\n{\n    std::cout << \"Hello, ICS 2024!\" << std::endl;\n    co_return;\n}\n\nint main()\n{\n    hello();\n}\n```\n\n<!-- ```cpp\n#include <stdio.h>\n\nvoid trans(int M, int N, int A[M][N], int B[N][M])\n{\n    int i, j, tmp;\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < M; j++)\n        {\n            tmp = A[i][j];\n            B[j][i] = tmp;\n        }\n    }\n}\n\nstatic int A[256][256];\nstatic int B[256][256];\n\nint main()\n{\n    printf(\"try it, and wait for a year\\n\");\n    trans(256, 256, A, B);\n}\n``` -->\n\n<!--\n```cpp\n#include <stdio.h>\n\n#include \"generator.h\"\n\nint main() {\n    auto coro = []() -> libco::generator<const char> {\n        const char str[] = \"Hello, ICS 2024!\\n\";\n        for (const auto ch : str) {\n            co_yield ch;\n        }\n    }();\n\n    for (const auto ch : coro) {\n        std::cout << ch;\n    }\n}\n```\n-->\n","date":"2024-10-31T05:37:01.938Z","updated":"2024-10-31T05:37:01.938Z","path":"index.html","comments":1,"layout":"page","_id":"cm2yhehke0000rzx44j0wepie","content":"<p>Fall, 2024</p>\n<p>Instructor: <a href=\"https://cjinfdu.github.io/\">金城</a></p>\n<p>School of Computer Science, Fudan University</p>\n<hr />\n<h2 id=\"news\">News</h2>\n<ul>\n<li><strong>[Oct 31, 2024]</strong> <a href=\"StackLab\">StackLab</a> is\nreleased.</li>\n<li><strong>[Oct 9, 2024]</strong> <a href=\"BombLab\">BombLab</a> is\nreleased.</li>\n<li><strong>[Sep 25, 2024]</strong> <a href=\"DataLab\">DataLab</a> is\nreleased.</li>\n<li><strong>[Sep 18, 2024]</strong> <a href=\"GitLab\">GitLab</a> is\nreleased.</li>\n<li><strong>[Sep 14, 2024]</strong> <a\nhref=\"ICS实验入门手册\">ICS实验入门手册</a> is released.</li>\n<li><strong>[Sep 14 2024]</strong> Course Website is online.</li>\n</ul>\n<h2 id=\"schedule\">Schedule</h2>\n<table>\n<colgroup>\n<col style=\"width: 4%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 30%\" />\n<col style=\"width: 54%\" />\n</colgroup>\n<thead>\n<tr>\n<th style=\"text-align: left;\">Num</th>\n<th style=\"text-align: left;\">Date</th>\n<th style=\"text-align: left;\">Subject</th>\n<th style=\"text-align: left;\">Assignment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">01</td>\n<td style=\"text-align: left;\">09/06/2024</td>\n<td style=\"text-align: left;\">数的表示 I</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">02</td>\n<td style=\"text-align: left;\">09/12/2024</td>\n<td style=\"text-align: left;\">环境配置</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">03</td>\n<td style=\"text-align: left;\">09/13/2024</td>\n<td style=\"text-align: left;\">数的表示 II</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">04</td>\n<td style=\"text-align: left;\">09/19/2024</td>\n<td style=\"text-align: left;\">GitLab</td>\n<td style=\"text-align: left;\"><a href=\"GitLab\">Lab0-GitLab</a> (Due:\n09/25/2024)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">05</td>\n<td style=\"text-align: left;\">09/20/2024</td>\n<td style=\"text-align: left;\">机器码 I</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">06</td>\n<td style=\"text-align: left;\">09/26/2024</td>\n<td style=\"text-align: left;\">DataLab发布</td>\n<td style=\"text-align: left;\"><a href=\"DataLab\">Lab1-DataLab</a> (Due:\n10/10/2024)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">07</td>\n<td style=\"text-align: left;\">09/27/2024</td>\n<td style=\"text-align: left;\">机器码 II</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">08</td>\n<td style=\"text-align: left;\">10/10/2024</td>\n<td style=\"text-align: left;\">BombLab发布</td>\n<td style=\"text-align: left;\"><a href=\"BombLab\">Lab2BombLab</a> (Due:\n10/30/2024)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">09</td>\n<td style=\"text-align: left;\">10/11/2023</td>\n<td style=\"text-align: left;\">机器码 III</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">10</td>\n<td style=\"text-align: left;\">10/17/2023</td>\n<td style=\"text-align: left;\">DataLab面试</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">11</td>\n<td style=\"text-align: left;\">10/18/2023</td>\n<td style=\"text-align: left;\">机器码 IV</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">12</td>\n<td style=\"text-align: left;\">10/24/2023</td>\n<td style=\"text-align: left;\">BombLab答疑</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">13</td>\n<td style=\"text-align: left;\">10/25/2023</td>\n<td style=\"text-align: left;\">处理器 I</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">14</td>\n<td style=\"text-align: left;\">10/31/2023</td>\n<td style=\"text-align: left;\">StackLab发布</td>\n<td style=\"text-align: left;\"><a href=\"StackLab\">Lab3-StackLab</a> (Due:\n11/21/2024)</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;coroutine&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">task</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">promise_type</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">task <span class=\"title\">get_return_object</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &#123;&#125;; &#125;</span><br><span class=\"line\">        <span class=\"function\">std::suspend_never <span class=\"title\">initial_suspend</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &#123;&#125;; &#125;</span><br><span class=\"line\">        <span class=\"function\">std::suspend_never <span class=\"title\">final_suspend</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span> </span>&#123; <span class=\"keyword\">return</span> &#123;&#125;; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">return_void</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unhandled_exception</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">task <span class=\"title\">hello</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Hello, ICS 2024!&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">co_return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hello</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<!-- ```cpp\n#include <stdio.h>\n\nvoid trans(int M, int N, int A[M][N], int B[N][M])\n{\n    int i, j, tmp;\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < M; j++)\n        {\n            tmp = A[i][j];\n            B[j][i] = tmp;\n        }\n    }\n}\n\nstatic int A[256][256];\nstatic int B[256][256];\n\nint main()\n{\n    printf(\"try it, and wait for a year\\n\");\n    trans(256, 256, A, B);\n}\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!--</span><br><span class=\"line\">```cpp</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;generator.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    auto coro = []() -&gt; libco::generator&lt;const char&gt; &#123;</span><br><span class=\"line\">        const char str[] = &quot;Hello, ICS 2024!\\n&quot;;</span><br><span class=\"line\">        for (const auto ch : str) &#123;</span><br><span class=\"line\">            co_yield ch;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">    for (const auto ch : coro) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; ch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>--&gt;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Fall, 2024</p>\n<p>Instructor: <a href=\"https://cjinfdu.github.io/\">金城</a></p>\n<p>School of Computer Science, Fudan University</p>\n<hr />\n<h2 id=\"news\">News</h2>\n<ul>\n<li><strong>[Oct 31, 2024]</strong> <a href=\"StackLab\">StackLab</a> is\nreleased.</li>\n<li><strong>[Oct 9, 2024]</strong> <a href=\"BombLab\">BombLab</a> is\nreleased.</li>\n<li><strong>[Sep 25, 2024]</strong> <a href=\"DataLab\">DataLab</a> is\nreleased.</li>\n<li><strong>[Sep 18, 2024]</strong> <a href=\"GitLab\">GitLab</a> is\nreleased.</li>\n<li><strong>[Sep 14, 2024]</strong> <a\nhref=\"ICS实验入门手册\">ICS实验入门手册</a> is released.</li>\n<li><strong>[Sep 14 2024]</strong> Course Website is online.</li>\n</ul>\n<h2 id=\"schedule\">Schedule</h2>\n<table>\n<colgroup>\n<col style=\"width: 4%\" />\n<col style=\"width: 10%\" />\n<col style=\"width: 30%\" />\n<col style=\"width: 54%\" />\n</colgroup>\n<thead>\n<tr>\n<th style=\"text-align: left;\">Num</th>\n<th style=\"text-align: left;\">Date</th>\n<th style=\"text-align: left;\">Subject</th>\n<th style=\"text-align: left;\">Assignment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">01</td>\n<td style=\"text-align: left;\">09/06/2024</td>\n<td style=\"text-align: left;\">数的表示 I</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">02</td>\n<td style=\"text-align: left;\">09/12/2024</td>\n<td style=\"text-align: left;\">环境配置</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">03</td>\n<td style=\"text-align: left;\">09/13/2024</td>\n<td style=\"text-align: left;\">数的表示 II</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">04</td>\n<td style=\"text-align: left;\">09/19/2024</td>\n<td style=\"text-align: left;\">GitLab</td>\n<td style=\"text-align: left;\"><a href=\"GitLab\">Lab0-GitLab</a> (Due:\n09/25/2024)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">05</td>\n<td style=\"text-align: left;\">09/20/2024</td>\n<td style=\"text-align: left;\">机器码 I</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">06</td>\n<td style=\"text-align: left;\">09/26/2024</td>\n<td style=\"text-align: left;\">DataLab发布</td>\n<td style=\"text-align: left;\"><a href=\"DataLab\">Lab1-DataLab</a> (Due:\n10/10/2024)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">07</td>\n<td style=\"text-align: left;\">09/27/2024</td>\n<td style=\"text-align: left;\">机器码 II</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">08</td>\n<td style=\"text-align: left;\">10/10/2024</td>\n<td style=\"text-align: left;\">BombLab发布</td>\n<td style=\"text-align: left;\"><a href=\"BombLab\">Lab2BombLab</a> (Due:\n10/30/2024)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">09</td>\n<td style=\"text-align: left;\">10/11/2023</td>\n<td style=\"text-align: left;\">机器码 III</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">10</td>\n<td style=\"text-align: left;\">10/17/2023</td>\n<td style=\"text-align: left;\">DataLab面试</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">11</td>\n<td style=\"text-align: left;\">10/18/2023</td>\n<td style=\"text-align: left;\">机器码 IV</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">12</td>\n<td style=\"text-align: left;\">10/24/2023</td>\n<td style=\"text-align: left;\">BombLab答疑</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">13</td>\n<td style=\"text-align: left;\">10/25/2023</td>\n<td style=\"text-align: left;\">处理器 I</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">14</td>\n<td style=\"text-align: left;\">10/31/2023</td>\n<td style=\"text-align: left;\">StackLab发布</td>\n<td style=\"text-align: left;\"><a href=\"StackLab\">Lab3-StackLab</a> (Due:\n11/21/2024)</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;coroutine&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">task</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">promise_type</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">task <span class=\"title\">get_return_object</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &#123;&#125;; &#125;</span><br><span class=\"line\">        <span class=\"function\">std::suspend_never <span class=\"title\">initial_suspend</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> &#123;&#125;; &#125;</span><br><span class=\"line\">        <span class=\"function\">std::suspend_never <span class=\"title\">final_suspend</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span> </span>&#123; <span class=\"keyword\">return</span> &#123;&#125;; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">return_void</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unhandled_exception</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">task <span class=\"title\">hello</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Hello, ICS 2024!&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">co_return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hello</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<!-- ```cpp\n#include <stdio.h>\n\nvoid trans(int M, int N, int A[M][N], int B[N][M])\n{\n    int i, j, tmp;\n    for (i = 0; i < N; i++)\n    {\n        for (j = 0; j < M; j++)\n        {\n            tmp = A[i][j];\n            B[j][i] = tmp;\n        }\n    }\n}\n\nstatic int A[256][256];\nstatic int B[256][256];\n\nint main()\n{\n    printf(\"try it, and wait for a year\\n\");\n    trans(256, 256, A, B);\n}\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!--</span><br><span class=\"line\">```cpp</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;generator.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    auto coro = []() -&gt; libco::generator&lt;const char&gt; &#123;</span><br><span class=\"line\">        const char str[] = &quot;Hello, ICS 2024!\\n&quot;;</span><br><span class=\"line\">        for (const auto ch : str) &#123;</span><br><span class=\"line\">            co_yield ch;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">    for (const auto ch : coro) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; ch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>--&gt;</p>\n"},{"title":"staff","_content":"\n## TAs\n\n\n<div style=\"display: flex; margin-bottom: 4.5rem!important;\">\n<div style=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div><image src=\"yangyang.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\"><a href=\"https://www.cameudis.com\">杨洋</a></h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">21307130045@m.fudan.edu.cn</p>\n  <p>⏯️ CoroutineLab</p>\n  <p>A ghost is hunting Shell - the ghost of Grade 4.</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div><image src=\"yuchen.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">王雨晨</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">21307130314@m.fudan.edu.cn</p>\n  <p>⏯️ CoroutineLab</p>\n</div>\n</div>\n</div>\n\n<div style=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div><image src=\"yifan.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">伊凡</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">21307130047@m.fudan.edu.cn</p>\n  <p>🧮 DataLab</p>\n  <p>希望大家在ics的海洋中不沉船[呲牙]</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div><image src=\"houze.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">徐厚泽</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307110054@m.fudan.edu.cn</p>\n  <p>🔀 GitLab</p>\n  <p>💾 CacheLab</p>\n</div>\n</div>\n</div>\n\n\n<div style=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div style=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div><image src=\"jizhou.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">俞霁洲</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307130469@m.fudan.edu.cn</p>\n  <p>💣 BombLab</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div><image src=\"yiyang.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">范意阳</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">18615302908@163.com</p>\n  <p>💾 CacheLab</p>\n  <p>大家不要太卷，放轻松</p>\n</div>\n</div>\n</div>\n\n<div style=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div style=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div><image src=\"lingyu.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">孔令宇</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307110120@m.fudan.edu.cn</p>\n  <p>⏯️ CoroutineLab</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div><image src=\"zhouwu.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">韩周吾</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307130440@m.fudan.edu.cn</p>\n  <p>🌐 Website</p>\n  <p>💣 BombLab</p>\n</div>\n</div>\n</div>\n\n<div style=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div style=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div><image src=\"haotian.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">胥昊天</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307110206@m.fudan.edu.cn</p>\n  <p>⛓️ MakeLab</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div><image src=\"zenghao.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">李增昊</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307130108@m.fudan.edu.cn</p>\n  <p>🧮 DataLab</p>\n</div>\n</div>\n</div>\n\n\n\n\n  <!-- <p>🧮 DataLab</p>\n  <p>💣 BombLab</p>\n  <p>⏯️ CoroutineLab</p>\n  <p>💾 CacheLab</p>\n  <p>⛓️ MakeLab</p>\n  <p>💻 PJ</p> -->","source":"staff/index.md","raw":"---\ntitle: staff\n---\n\n## TAs\n\n\n<div style=\"display: flex; margin-bottom: 4.5rem!important;\">\n<div style=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div><image src=\"yangyang.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\"><a href=\"https://www.cameudis.com\">杨洋</a></h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">21307130045@m.fudan.edu.cn</p>\n  <p>⏯️ CoroutineLab</p>\n  <p>A ghost is hunting Shell - the ghost of Grade 4.</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div><image src=\"yuchen.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">王雨晨</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">21307130314@m.fudan.edu.cn</p>\n  <p>⏯️ CoroutineLab</p>\n</div>\n</div>\n</div>\n\n<div style=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div><image src=\"yifan.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">伊凡</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">21307130047@m.fudan.edu.cn</p>\n  <p>🧮 DataLab</p>\n  <p>希望大家在ics的海洋中不沉船[呲牙]</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div><image src=\"houze.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">徐厚泽</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307110054@m.fudan.edu.cn</p>\n  <p>🔀 GitLab</p>\n  <p>💾 CacheLab</p>\n</div>\n</div>\n</div>\n\n\n<div style=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div style=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div><image src=\"jizhou.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">俞霁洲</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307130469@m.fudan.edu.cn</p>\n  <p>💣 BombLab</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div><image src=\"yiyang.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">范意阳</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">18615302908@163.com</p>\n  <p>💾 CacheLab</p>\n  <p>大家不要太卷，放轻松</p>\n</div>\n</div>\n</div>\n\n<div style=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div style=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div><image src=\"lingyu.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">孔令宇</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307110120@m.fudan.edu.cn</p>\n  <p>⏯️ CoroutineLab</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div><image src=\"zhouwu.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">韩周吾</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307130440@m.fudan.edu.cn</p>\n  <p>🌐 Website</p>\n  <p>💣 BombLab</p>\n</div>\n</div>\n</div>\n\n<div style=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div style=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div><image src=\"haotian.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">胥昊天</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307110206@m.fudan.edu.cn</p>\n  <p>⛓️ MakeLab</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div><image src=\"zenghao.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image></div>\n<div style=\"flex: 1;\">\n  <h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">李增昊</h3>\n  <p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">22307130108@m.fudan.edu.cn</p>\n  <p>🧮 DataLab</p>\n</div>\n</div>\n</div>\n\n\n\n\n  <!-- <p>🧮 DataLab</p>\n  <p>💣 BombLab</p>\n  <p>⏯️ CoroutineLab</p>\n  <p>💾 CacheLab</p>\n  <p>⛓️ MakeLab</p>\n  <p>💻 PJ</p> -->","date":"2024-09-25T13:47:12.354Z","updated":"2024-09-25T13:47:12.354Z","path":"staff/index.html","comments":1,"layout":"page","_id":"cm2yhehkk0002rzx4a5131f9o","content":"<h2 id=\"tas\">TAs</h2>\n<div style=\"display: flex; margin-bottom: 4.5rem!important;\">\n<div\nstyle=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div>\n<image src=\"yangyang.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n<a href=\"https://www.cameudis.com\">杨洋</a>\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n21307130045@m.fudan.edu.cn\n</p>\n<p>\n⏯️ CoroutineLab\n</p>\n<p>\nA ghost is hunting Shell - the ghost of Grade 4.\n</p>\n</div>\n</div>\n<div\nstyle=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div>\n<image src=\"yuchen.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n王雨晨\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n21307130314@m.fudan.edu.cn\n</p>\n<p>\n⏯️ CoroutineLab\n</p>\n</div>\n</div>\n</div>\n<div\nstyle=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div>\n<image src=\"yifan.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n伊凡\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n21307130047@m.fudan.edu.cn\n</p>\n<p>\n🧮 DataLab\n</p>\n<p>\n希望大家在ics的海洋中不沉船[呲牙]\n</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div>\n<image src=\"houze.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n徐厚泽\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307110054@m.fudan.edu.cn\n</p>\n<p>\n🔀 GitLab\n</p>\n<p>\n💾 CacheLab\n</p>\n</div>\n</div>\n</div>\n<div\nstyle=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div\nstyle=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div>\n<image src=\"jizhou.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n俞霁洲\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307130469@m.fudan.edu.cn\n</p>\n<p>\n💣 BombLab\n</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div>\n<image src=\"yiyang.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n范意阳\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n18615302908@163.com\n</p>\n<p>\n💾 CacheLab\n</p>\n<p>\n大家不要太卷，放轻松\n</p>\n</div>\n</div>\n</div>\n<div\nstyle=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div\nstyle=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div>\n<image src=\"lingyu.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n孔令宇\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307110120@m.fudan.edu.cn\n</p>\n<p>\n⏯️ CoroutineLab\n</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div>\n<image src=\"zhouwu.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n韩周吾\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307130440@m.fudan.edu.cn\n</p>\n<p>\n🌐 Website\n</p>\n<p>\n💣 BombLab\n</p>\n</div>\n</div>\n</div>\n<div\nstyle=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div\nstyle=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div>\n<image src=\"haotian.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n胥昊天\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307110206@m.fudan.edu.cn\n</p>\n<p>\n⛓️ MakeLab\n</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div>\n<image src=\"zenghao.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n李增昊\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307130108@m.fudan.edu.cn\n</p>\n<p>\n🧮 DataLab\n</p>\n</div>\n</div>\n</div>\n<p><!-- <p>🧮 DataLab</p>\n  <p>💣 BombLab</p>\n  <p>⏯️ CoroutineLab</p>\n  <p>💾 CacheLab</p>\n  <p>⛓️ MakeLab</p>\n  <p>💻 PJ</p> --></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"tas\">TAs</h2>\n<div style=\"display: flex; margin-bottom: 4.5rem!important;\">\n<div\nstyle=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div>\n<image src=\"yangyang.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n<a href=\"https://www.cameudis.com\">杨洋</a>\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n21307130045@m.fudan.edu.cn\n</p>\n<p>\n⏯️ CoroutineLab\n</p>\n<p>\nA ghost is hunting Shell - the ghost of Grade 4.\n</p>\n</div>\n</div>\n<div\nstyle=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div>\n<image src=\"yuchen.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n王雨晨\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n21307130314@m.fudan.edu.cn\n</p>\n<p>\n⏯️ CoroutineLab\n</p>\n</div>\n</div>\n</div>\n<div\nstyle=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div>\n<image src=\"yifan.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n伊凡\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n21307130047@m.fudan.edu.cn\n</p>\n<p>\n🧮 DataLab\n</p>\n<p>\n希望大家在ics的海洋中不沉船[呲牙]\n</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div>\n<image src=\"houze.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n徐厚泽\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307110054@m.fudan.edu.cn\n</p>\n<p>\n🔀 GitLab\n</p>\n<p>\n💾 CacheLab\n</p>\n</div>\n</div>\n</div>\n<div\nstyle=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div\nstyle=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div>\n<image src=\"jizhou.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n俞霁洲\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307130469@m.fudan.edu.cn\n</p>\n<p>\n💣 BombLab\n</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div>\n<image src=\"yiyang.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n范意阳\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n18615302908@163.com\n</p>\n<p>\n💾 CacheLab\n</p>\n<p>\n大家不要太卷，放轻松\n</p>\n</div>\n</div>\n</div>\n<div\nstyle=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div\nstyle=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div>\n<image src=\"lingyu.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n孔令宇\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307110120@m.fudan.edu.cn\n</p>\n<p>\n⏯️ CoroutineLab\n</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div>\n<image src=\"zhouwu.JPG\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n韩周吾\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307130440@m.fudan.edu.cn\n</p>\n<p>\n🌐 Website\n</p>\n<p>\n💣 BombLab\n</p>\n</div>\n</div>\n</div>\n<div\nstyle=\"display: flex; margin-bottom: 4.5rem!important; margin-top: 2rem\">\n<div\nstyle=\"flex: 1; display: flex; align-self: flex-start; padding-right: 25px;\">\n<div>\n<image src=\"haotian.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n胥昊天\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307110206@m.fudan.edu.cn\n</p>\n<p>\n⛓️ MakeLab\n</p>\n</div>\n</div>\n<div style=\"flex: 1; display: flex; align-self: flex-start;\">\n<div>\n<image src=\"zenghao.jpg\" style=\"width: 90px; height: 90px; border-radius:4%!important; margin-right: 1rem!important;\"></image>\n</div>\n<div style=\"flex: 1;\">\n<h3 style=\"margin-top: 0; margin-bottom: 0rem; color: #0e419c\">\n李增昊\n</h3>\n<p style=\"margin-block-start: 0em; margin-block-end: 0em; font-size=14px; color: #6c757d;\">\n22307130108@m.fudan.edu.cn\n</p>\n<p>\n🧮 DataLab\n</p>\n</div>\n</div>\n</div>\n<p><!-- <p>🧮 DataLab</p>\n  <p>💣 BombLab</p>\n  <p>⏯️ CoroutineLab</p>\n  <p>💾 CacheLab</p>\n  <p>⛓️ MakeLab</p>\n  <p>💻 PJ</p> --></p>\n"}],"Post":[{"title":"BombLab","_content":"\n> Deadline：2024-10-30 23:59:59\n\n## 一、实验简介\n\nCSAPP 第三章配套实验。\n\n本学期，我们对 CSAPP 的经典 BombLab 进行了全面再次升级（包括剧情）。你将综合运用 x86 汇编语言 / Linux / gdb / 数据结构 等的相关知识，解决一系列挑战，提升逆向工程技能。\n\n本次 Lab 由两个部分组成：\n\n- 一个互动式 gdb 教程：gdb-tutor\n- 一个包含若干个关卡的二进制炸弹：bomb++\n\n你的目标是拆除炸弹，无伤通过 bomb++ 的所有关卡。\n\n\n\n## 二、实验剧情\n\n> 前排提醒：剧情内容仅为增加实验趣味性所设，**对解题本身毫无影响**！（也就是说如果不愿意看，可以直接在 `config.txt` 中将 `story_mode` 设定为 false）\n\n2034 年，人工智能（AI）已深入渗透人类生活的每个角落，所有设备都由**中央智能实体（CIE）**所控制。一天，作为全球顶尖科学家之一的你，收到来自 CIE 的紧急消息：一个由古早设计者植入的“炸弹”——隐藏在系统核心代码中的病毒——已经在所有 AI 系统中传播，预计将在 14 天后引爆，可能引发全球性的混乱。\n\n你的使命是回到 2024 年，在第一个带病毒的 AI 设备出现的时刻，从根源解决这枚“炸弹”。你必须深入“炸弹”的汇编代码，寻找若干口令来关闭“炸弹”。在这一过程中，你将不断发现被隐藏的真相……\n\n\n\n## 三、实验内容\n\n### 互动式 gdb 教程 gdb-tutor\n\n> 本部分不占分，也不要求必须完成。\n\n在挑战 BombLab 时，gdb 是一个非常有用的工具。为了降低本 Lab 的上手难度，并帮助大家掌握 gdb，认识这一强大的工具，我们编写了这个互动式的 gdb 教程。\n\n使用方法：直接执行 `./gdb-tutor`，教程源码见 `gdb-tutor.c`。\n\n### 二进制炸弹 bomb++\n\n这是一个包含若干关卡的可执行文件。只有你输入满足条件的关卡口令时，才能通过该关卡，到达下一个关卡。如果口令错误，炸弹就会爆炸！（程序会打印爆炸信息并立刻退出）\n\n你的目标是找到所有关卡的正确口令，让炸弹成功解除。炸弹制造者不小心给出了 `main.cpp` ，其中包含了 bomb++ 的主要流程，你可以参考这个源文件了解炸弹的大致逻辑。\n\n如果炸弹爆炸，它将会输出 `BOOM!!!` 并退出。通过每一关后都会有通关提示（并输出一段剧情）；在通关后，它将会输出 `Cool! your skill on Reverse Engineering is great.` （和普通结局剧情）；而通关真结局后，它将会输出 `You are really a Master of Reverse Engineering!` （与真结局剧情）。（详见 `main.cpp`）\n\n> 炸弹会读取 `fail.txt` 并在爆炸时打印其内容，如果你想要很酷炫的爆炸，可以自行修改 `fail.txt` 或直接将其删去。本次实验附赠一只可爱猫猫～\n\n实验各个关卡涉及的知识大致如下：\n\n1. 函数调用\n2. 循环\n3. 分支\n4. 递归\n5. 面向对象\n6. 单调栈\n\nSecret. ████\n\n请注意，Secret 的解锁条件在第三关中进行了提示，或许你能在 `main.cpp` 的某个函数中发现一些违和之处……\n\n> **关于 config.txt**\n>\n> 1. 本次 BombLab 采用了个性化答案制度，即：每个人的答案会依据自己的学号发生变化。**请务必填写自己的学号！**\n>\n>    这一操作位于 `phase_0` 中，**这个函数中的所有内容都和 bomb++ 的内容无关！不需要阅读！不需要阅读！！不需要阅读！！！**（其中包括了各种 `EVP` 开头的函数）\n>\n>    另外，助教会根据每个人的学号来判断答案，如果漏填学号或者填错学号导致的错误，助教一概不负责！\n>\n> 2. 为了便利，本次 BombLab 提供了**跳题**选项！在 `config.txt` 中设置 `test_phase`，bomb++ 只会来测试相应的关卡。\n>\n>    例如：第 3 关卡关，你可以将 `test_pahse` 设置为 `1, 2, 4, 5, 6`, 然后运行 `./bomb` 即可跳过3。\n>\n>    请确保在提交时，`config.txt` 中，`test_phase` 被设置为 `1, 2, 3, 4, 5, 6`，以便助教们直接测试你的答案。\n>\n> 3. 关于剧情模式：~~两位助教讨论了一整晚想出来的剧情~~ 剧情模式是为了增加做实验过程中的乐趣所设，我们真心希望大家写 Lab 时能乐在其中！当然，如果你觉得剧情模式的大段输出影响到了你正常解题，可以在 `config.txt` 中将 `story_mode` 设置为 false。\n>\n>    请确保在提交时，`config.txt` 中，`story_mode` 被设置为 `false`。\n\n\n\n## 四、实验步骤\n\n- 完整阅读本实验文档、从 github classroom 上拉取实验仓库\n- 跟随 gdb-tutor 学习 gdb 的基础使用方法\n- 按需求配置 `config.txt`，包括需要测试的关卡、是否选择开启剧情模式、学号\n- 使用静态分析与动态分析方法分析 bomb++，尽力找出正确的口令\n- 编写实验报告，并在 github classroom 上提交\n\n\n\n## 五、提交事项\n\n### 内容要求\n\n在项目的**根目录**下，需要有**实验报告** `lab2_<学号>.pdf`（要求转为 pdf 格式）以及**正确口令** `password.txt`。注意，`password.txt` 需要满足可以用重定向秒杀 bomb++ 的要求（我们会在后面介绍什么是重定向），我们会用这个来判断你通过了几关。\n\n你的实验报告应包含以下内容：\n\n1. 姓名和学号\n2. 每个关卡的推演过程（重点），如你推测的函数的功能\n3. 拆弹成功的截图（请关闭剧情模式进行截图）\n4. 如果有，请列出引用的内容以及参考的资料\n5. 意见+建议（可选）\n\n> **关于实验报告**\n>\n> 实验报告是用来判断你是否 **独立思考** 来解决本次 Lab 的。\n>\n> 我们不希望看到冗长或表意混乱的报告，请一定不要把报告写成论文 QaQ\n\n### 提交方法\n\n在终端运行以下指令：\n\n```shell\n# 注：需要在仓库的根目录进行操作\ngit add password.txt lab2_<学号>.pdf\n# e.g. git add password.txt lab2_23307130000.pdf\ngit commit -m \"xxx(可以是你的提交注释)\"\n# 将暂存区的所有更改提交到本地仓库\ngit tag \"final\"\n# 对最后一个 commit，请添加 tag: final\ngit push\n# 将本地仓库推送到远程\n```\n\n### 评分\n\n| 项目                 | 分值 |\n| ------------------- | ---- |\n| 提交格式正确          | 5%   |\n| 通过正常关卡 6\\*13%   | 78%  |\n| 通过隐藏关卡          | 7%   |\n| 实验报告             | 10%  |\n\n另：抄袭倒扣分！！勿谓言之不预。\n\n> **反卷斗士の承诺**\n>\n> 实验过程非抄袭的同学，实验报告部分赋满分。一旦发现抄袭，则零分处理。\n\n请大家不要迟交，迟交扣分：\n\n- 迟交 1 天：-10%\n- 迟交 2 天：-20%\n- 迟交 3 天：-50%\n- 迟交 4 天：-70%\n- 迟交 5 天及以上：-100%\n\n## 六、实验指导\n\n本题本质上是一道**逆向工程**题，需要你在没有源代码的情况下复原程序编写者的意图与程序的逻辑。你可能会好奇，我们为什么要学习逆向工程、学习汇编：作为科班 CS 学生，你需要知道自己写出来的程序到底会变成什么样子，到底如何运行，这样你才能知道如何写出更好的程序——正是这些底层的细节将科班程序员和培训班程序员区分开来。这个 Lab 将会帮助你搞清楚机器码 / 汇编语言具体而言如何运作。\n\n除此以外，这个 Lab 还会带你入门逆向工程。逆向工程作为信息安全的一个研究领域，有着许多有趣的应用领域——注册机、软件破解、游戏安全（如修改器、外挂）……除了这些看起来很恶意的应用场景以外，逆向工程一个非常重要的作用就是帮助白帽黑客们找到程序的漏洞，发掘程序的安全问题。不过，最纯粹的逆向工程热爱者，往往是出于自己的好奇心来逆向闭源的软件——这玩意到底怎么实现的？\n\n如果你对逆向工程感兴趣，可以试着从 **CTF（Capture The Flag）** 竞赛开始。逆向工程是 CTF 竞赛的一个主要领域，比赛中出题人会用各种语言、工具编写赛题，试图隐藏程序的逻辑。参赛者需要使用各种工具、结合各种资料来还原程序逻辑。在比赛与练习中，你会接触到各种软件开发技术（如 python、rust、golang、android……）、各种编码和密码学算法（如 Base64、TEA、RC4……），了解其底层的实现原理。我们学校也有相应的社团 / CTF 战队——信息网络安全协会/六星战队，大家可以了解一下哦~\n\n在逆向工程中，分析方法可以大致归类为两类：动态分析与静态分析。简单来说，动态分析就是运行程序、观察其行为；静态分析就是借助可执行文件中的信息与数据（如机器码）还原程序逻辑。在本节中，我们会分别介绍动态分析、静态分析的方法与工具，然后再介绍一些别的小工具。\n\n### 动态分析\n\n最简单的动态分析就是直接运行程序。你可以试试引爆炸弹先。\n\n正经的动态分析就是使用 `gdb`（全称为 GNU Debugger）等调试工具进行动态调试。动态调试的坏处是可能会一不小心让程序“跑飞了”，错过你想要观察的代码；而好处就是你可以直观地看到程序运行时，各种数据的实际值。\n\n至于如何使用，请参考 `gdb-tutor`。\n\n你可以去网上找一个 gdb cheetsheet（小抄），方便你查找想用的指令。我们也给出一个挺好的英文教程：[Tudor‘s gdb crash course](https://users.umiacs.umd.edu/~tdumitra/courses/ENEE757/Fall15/misc/gdb_tutorial.html)。或者可以直接在 Linux 环境下 `man gdb`（man 为 manual 的缩写，是用来查看系统命令和程序的手册页的命令）查看 gdb 的完整文档。\n\n以下为一些 gdb 的常用指令：\n\n| 命令（缩写）     | 作用                                          | 示例              |\n| -------------- | --------------------------------------------- | ----------------- |\n| tab            | 命令或关键字补全                                |                   |\n| run (r)        | 运行程序                                       | r                 |\n| quit (q)       | 退出 gdb                                      | q                 |\n| break (b)      | 打断点，可指定函数名或具体地址                     | b *0x400540       |\n| continue (c)   | 继续运行程序，一般是从断点处开始                   | c                 |\n| print (p)      | 打印数据，可以指定格式，也可以指定寄存器、内存、变量等 | p /x *($rsp+8)    |\n| display (disp) | 指定的内容和print一样，不过可以重复展示             | display /5i $pc   |\n| info (i)       | 获取信息，可指定寄存器、函数、断点信息等             | i r{egister} pc   |\n| delete         | 删除gdb指定的内容，可指定断点等（默认是断点）        | d {break} 1       |\n| stepi (si)     | 执行一条指令，后可跟数字表示执行多条                | si 10             |\n| examine (x)    | 代码检查，后跟具体地址，可以指定输出的方式和格式      | x /10i $pc        |\n| call           | 在gdb中进行函数调用（很神奇的功能）                | call printf(\"\\n\") |\n| backtrace (bt) | 查看调用栈，即函数调用的情况                       | bt                |\n\n### 静态分析\n\n#### 反汇编\n\n我们回顾一下C程序的编译过程：源代码 -> 汇编代码 -> 机器码，中间两步分别称为**编译**与**汇编**。\n\n在源代码到汇编代码的过程中，编译器作了许多的优化、也删去了很多源代码中的信息，比如局部变量名等等……而汇编代码和机器码则是几乎等价的，汇编语言是机器码的助记符。\n\n因此，有工具能帮我们将可执行文件中的机器码转化为汇编代码也就不足为奇了，这种工具被称为**反汇编器**。至于汇编代码到源代码，这种工具也存在，但由于本次实验旨在帮助大家熟悉汇编代码，因此在本次实验中我们不会介绍它们。我们这里介绍一个非常经典且常用的反汇编器——objdump。\n\n我们在命令行中输入 `objdump -d ./bomb > bomb.S` 就可以获得反汇编文件 `bomb.S`。\n\n`objdump --help` 会打印出 objdump 的所有用法，并且会给出精简的解释。`man objdump` 会打印出详尽的解释。\n\n> **关于 objdump**\n>\n> 你可以尝试在 `objdump` 后加上 `-D` 和/或 `-x` 和/或 `-C`，就像上面出现的 `-d` 一样。你可以通过搜索或读文档的方式了解这会导致什么后果；TA 相信这几个参数会对你的实验有很大帮助！\n\n> **X86 / AMD64 汇编语言的格式**\n>\n> 在 CSAPP 课本上，有一个拓展框介绍了两种汇编语言的格式—— AT&T 以及 Intel。\n>\n> 他们最显著的区别有两个（当然还有别的区别，见课本）：\n>\n> - 两者的源操作数和目的操作数顺序相反\n> - AT&T 中寄存器需要加上 `%` 前缀，而 Intel 语法则不用。\n>\n> 本课程上课教学时使用的语法是 AT&T，这也是 objdump 默认使用的语法。但我们同样推荐你试试 Intel 语法，因为这是安全研究人员更常用的一种语法。想让 objdump 输出语法变为 Intel，只需要给 objdump 添加参数 `-M intel`。\n\n#### 阅读汇编\n\n在拿到汇编代码文件后，我们就需要通过分析它来理解程序的逻辑。如果是一个简短的函数，或许汇编也就几十行；但你很有可能会遇到百来行的函数。如何应对这种复杂的代码？\n\n我们介绍一种理解汇编代码的方法，叫做 **CFG（Control Flow Graph，控制流图）**。显然，汇编代码中没有 if-else / for loop / while loop 这样的结构，而只有各种 jump 和 conditional jump。很容易想到，我们可以把各种 jump 指令把它们的目标用一个箭头连起来，来让代码变得稍微好看懂一点。不过，我们还可以做得更加好一些：\n\n![](cfg.png)\n\n这是一个伪代码的例子，我们同样可以将这个方法运用到汇编语言中。构造 CFG 的基础方法很简单：我们只需要把不含跳转代码当作一个 Block，然后把 Block 们连接起来即可。你可以在草稿纸上使用这个方法，将函数的跳转逻辑理清楚。不要小看了 CFG 的作用，亲自试试吧，或许你会从此觉得读汇编语言也不过如此。\n\n另外一种推荐的技巧是……**将汇编代码打印出来**。没错，虽然我知道手写代码一定是痛苦的体验，但在纸上阅读汇编语言代码确实是一种推荐的方法。这是因为，汇编语言的阅读可能需要大量的标注，在纸上标记会方便很多。不过也请注意，bomb++ 的汇编代码很长，包含了许多不会执行或与实验无关的函数。你可以只在遇到应付不了的关卡时才选择把看不懂的那些函数打印出来。\n\n下面给出一些常见结构的汇编代码：\n\n##### 条件判断\n\nC 语言：\n```cpp\nif (array == 0) return;\n```\n\n汇编语言：\n```assembly\nendbr64 \ntest   %rdi,%rdi                       # 让函数第一个参数和自己作与运算\nje     11cb <for_sum(int*, int)+0x22>  # 若结果为 0，则跳转；相当于判断参数是否为 0，为 0 则跳转     \n```\n\n##### 循环结构\n\nC 语言：\n```cpp\ns = 0\nfor (int i = 0; i < size; ++i) s += array[i];\n```\n\n汇编语言：\n```assembly\nmov    $0x0,%eax                       # 初始化自增条件变量 i = 0\nmov    $0x0,%edx                       # 初始化总和 s = 0\ncmp    %esi,%eax                       # 判断条件变量是否满足条件 i < size ?\njge    11d0 <for_sum(int*, int)+0x27>  # 大于或等于则跳出循环\nadd    (%rdi,%eax,4),%edx              # 用 i 进行数组索引 base + i*4 => array[i]; s += array[i]\nadd    $0x1,%eax                       # 自增 i++\njmp    11bc <for_sum(int*, int)+0x13>  # 回到比较的地方\n```\n\n##### switch case 结构\n\n1. 打表：如果 case 的不同条件比较紧凑规律（比如 0、1、2、3......），则将 case 的条件作为索引、对应的地址（可能是地址偏移量）作为值，创建一个表格存放在内存中。\n\n| case | addr   |\n| ---- | ------ |\n| 0    | 0x1000 |\n| 1    | 0x1004 |\n| 2    | 0x1008 |\n| 3    | 0x1010 |\n\n2. 类似 if else 嵌套：如果 case 比较稀疏，则通过采用连续的比较和条件跳转指令\n\n```assembly\ncmp    $0x61,%dil\nje     1224 <switch_case2(char)+0x1c>\ncmp    $0x7a,%dil\nje     1227 <switch_case2(char)+0x1f>\ncmp    $0xa,%dil\nje     122b <switch_case2(char)+0x23>\nlea    0x1(%rdi),%eax\nretq\n```\n\n##### 递归\n\n函数内部调用了函数本身，需要注意对 callee-save 寄存器的保存和使用\n\nC 语言：\n```cpp\nint recursion(int x){ // 求斐波那契数\n    if (x < 2) return x;\n    return recursion(x-1) + recursion(x-2);\n}\n```\n\n汇编语言：\n```assembly\n000000000000122c <recursion(int)>:\npush   %rbp                       # 保存 rbp\npush   %rbx                       # 保存 ebx\nmov    %edi,%ebx                  # 保存第一个参数 x，因为 x 和 rdi 寄存器后续函数都要使用，因此将 x 保存在新的寄存器中（这里是 ebx），防止后续的函数将 rdi 中存放的 x 覆盖掉，而 ebx 因为是 callee-save，因此提前保存了它\ncmp    $0x1,%edi\njle    1258 <recursion(int)+0x2c> # 小于等于 1 则跳转，相当于 x < 2\nlea    -0x1(%rdi),%edi            # x-1\ncallq  122c <recursion(int)>      # recursion(x-1)\nmov    %eax,%ebp                  # 将得到的返回值放在 rbp 中，因为 rbp 是 callee-save，要提前保存\nlea    -0x2(%rbx),%edi            # x-2，这里也用到了 x，因此需要提前保存x\ncallq  122c <recursion(int)>\n...\n```\n\n##### struct\n\n内部变量按顺序排列，需要对齐\n\n```cpp\ntypedef struct {\n    char a = 'y';             // root     \n    unsigned b = 2333;        // root+0x4 虽然之前的 char 只占了 1 个字节，但是 unsigned 需要 4 字节对齐\n    float c = 123.123;        // root+0x8，0xb-0xf 之间的数值为 0\n    double d = 1930.1231313;  // root+0x10 虽然之前的 float 只占了 4 个字节，但是 double 需要 8 字节对齐\n} node;\n```\n\n##### C++虚函数\n\n类的非静态函数调用时，默认第一个参数是指向该对象的指针 **this**\n\n每一个类有唯一的一个虚函数表（vtable，其中只包含虚函数的指针），不是每个对象都有一个 vtable，恰恰是每个同一个类的对象都有一个指针，这个指针指向该类的 vtable（当然，前提是这个类包含虚函数）。那么，每个对象只额外增加了一个指针的大小。\n\n```assembly\nmov    $0x8,%edi                            \ncallq  1090 <operator new(unsigned long)@plt>  # 申请了 8 个字节的空间\nmov    %rax,%rbx                               # 保存该空闲空间的起始地址，即指向对象的指针\nmov    %rax,%rdi\ncallq  158c <B::B()>                           # 调用初始化函数，进行初始化，第一个参数为空闲空间的起始地址，即指向对象的指针 this\n                                               # 对象已经创建好\nmov    (%rbx),%rax                             # 对象的内容只包含一个指针，这条指令通过 this 指针获取对象的内容，即类的 vtable 的起始地址\nmov    (%rax),%rdx                             # 根据类的 vtable 起始地址获取要调用的函数的地址\nmov    $0x2,%esi                               # 函数的第二个参数为 2\nmov    %rax,%rdi\ncallq  *%rdx                                   # 调用 rdx 位置处的函数（* 号只是做标识用，并非取地址），参数分别为对象的地址（this）和 2\n```\n\n### 其他实验帮助\n\n#### 重定向与管道\n\n上过 C 语言和 C++ 的大家应该知道，命令行程序有三个默认打开的“流”，分别是 stdin，stdout 以及 stderr。在我们运行命令行程序时，标准输入就是我们敲进去的东西，而程序打印东西到 stdout 或者 stderr，其实就是打印到命令行上。\n\n在学习 C 或 C++ 的文件操作的时候，会发现一个很巧的事情——文件读写用到的 API，和标准输入输出用的那些 API 其实都差不多，这是因为文件和标准输入输出本来就是一样的。在 Linux 系统中，**一切皆文件**。不仅传统意义上的文本文件、多媒体文件等普通文件是文件，套接字（网络接口）、键盘鼠标设备等等都是文件，可以用统一的一套文件 API 进行处理。\n\n这种设计不仅带来了极大的统一性，也带来了极大的便捷性。本节介绍的 iostream 重定向和 pipes 管道就与这种设计有关。\n\n既然 stdin 和 stdout 也是**文件流**，那么我们当然可以把他们**重定向**到一个普通文件！我们让一个文件被定向到一个程序的标准输入，或者让一个程序的标准输出定向到一个文件当中。前者我们使用 `< file`，后者我们使用 `> file`，如下所示：\n\n```sh\n$ echo hello > hello.txt  \t\t # 把stdout重定向到hello.txt中\n$ cat hello.txt\nhello\n\n$ cat < hello.txt    \t\t\t\t\t # 把hello.txt重定向到cat的标准输入\nhello\n\n$ cat < hello.txt > hello2.txt # 同时重定向cat的标准输入和标准输出\n$ cat hello2.txt\nhello\n```\n\n如果你找到了所有的正确口令，那么把它们写到一个文本文件 `password.txt` 中，那么使用 `./bomb < password.txt` 就可以直接通过所有的关卡。\n\n除此以外，还有更加便利的 **管道** 操作，可以帮助我们将两个程序的输入和输出相连接，也就是构造一条虚拟的管道。这种神奇的操作是通过 `|` 来完成的：\n\n```sh\n$ cat 1.txt            # 假设我们有这么一个文件\nGODEL\nESCHER\nBACH\n$ cat 1.txt | tail -n1 # 打印 1.txt 的最后一行\nBACH\n$ cat 1.txt | grep CH  # 寻找 1.txt 中带有 CH 的行\nESCHER\nBACH\n```\n\n利用这两种操作，我们可以方便地处理BombLab的输入。我们知道 `cat` 是打开文件，也知道标准输入同样也是一个文件，因此我们可以用 `cat -` 打开标准输入文件，这时候 `cat` 就相当于一个 `echo`，可以复读我们说的话：\n\n```sh\n$ cat -\nHello, world!\nHello, world!\n```\n\n除此以外，cat 还可以打开多个文件，如下所示：\n\n```sh\n$ cat 1.txt\nhello\n$ cat 2.txt\nworld\n$ cat 1.txt 2.txt\nhello\nworld\n```\n\n如果你在做 BombLab 时，已经找到了前面某些阶段的口令，不想在后续步骤中再一遍遍重新输入它们的话，就可以将已知的口令写入一个文本文件中，然后用 `cat` 打开那个文本文件以及标准输入，然后利用管道机制将这两个文件的内容导向 bomb++ 的输入：\n\n```sh\n$ cat password.txt - | ./bomb\n```\n\n使用这种操作时注意，由于 bomb++ 每一阶段都会重新读取一行，所以文件结尾多出的换行符会导致 bomb++ 下一阶段读到一个寂寞，从而导致炸弹爆炸。因此，你的口令文件的末尾，应该**有且仅有**一个空行。\n\n> **文件拓展名**\n>\n> 熟悉 Windows 的各位同学一定对诸如 `.exe` `.docx` `.xls` `.png` `.jpeg` 等拓展名见惯不惯了，Windows 系统会通过文件名中的这些后缀来判断如何打开这个程序。\n>\n> 不过在使用 Linux 时，通常不需要你为文件加上拓展名，这是因为 Linux 系统往往通过文件头中的**魔数**来区分文件类型。因此，我们在这里为文本文件标上 `.txt` 后缀类似于注释一样，是为了让大家看得更清楚一些。\n\n#### “超纲”的汇编指令\n\n大家在实验过程中，或许会遇到一些课上没有讲过的汇编指令，我们在这里介绍一下其中一个。\n\n`endbr64`：一种用于防御 ROP（Return Oriented Programming）攻击的机制 —— CET（Control-flow Enforcement）的一部分，但大多的 CPU 现在还没有实装，因此它们执行到这条指令时会直接略过。本次实验并不涉及相关的内容，你也可以直接略过。~~如果对二进制漏洞攻防感兴趣，大家也可以关注信息网络安全协会的相关活动。~~\n\n如果遇到其他没见过的汇编指令，我们建议自己查询互联网。如果你有钻研的精神，欢迎你试着查询 Intel 的官方手册 [英特尔® 64 位和 IA-32 架构开发人员手册](https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html)（5000 行），真正理解这个指令的细节。在查询这种奇厚无比的手册时，请一定记得利用好目录以及搜索功能。\n\n\n\n## 七、参考资料 & 推荐资料\n\n- <http://csapp.cs.cmu.edu/3e/labs.html> 原版 Lab\n- 本实验参考 22、23 年的实验开发\n- [从汇编角度学习 C/C++ - 看雪](https://bbs.kanxue.com/homepage-category-835440-293.htm)\n\n\n\n## 八、实验彩蛋\n\n* 2023ICS BombLab：\n\n<img src=\"meme.jpg\" style=\"width: 320px; height: 320px;display: flex; justify-content: center; align-items: center;\">\n\n\n\n* 曾经可能会出现的剧情\n\n  <img src=\"PlotAdvices.png\" style=\"width: 400px; display: flex; justify-content: center; align-items: center;\">\n","source":"_posts/BombLab.md","raw":"---\ntitle: BombLab\n---\n\n> Deadline：2024-10-30 23:59:59\n\n## 一、实验简介\n\nCSAPP 第三章配套实验。\n\n本学期，我们对 CSAPP 的经典 BombLab 进行了全面再次升级（包括剧情）。你将综合运用 x86 汇编语言 / Linux / gdb / 数据结构 等的相关知识，解决一系列挑战，提升逆向工程技能。\n\n本次 Lab 由两个部分组成：\n\n- 一个互动式 gdb 教程：gdb-tutor\n- 一个包含若干个关卡的二进制炸弹：bomb++\n\n你的目标是拆除炸弹，无伤通过 bomb++ 的所有关卡。\n\n\n\n## 二、实验剧情\n\n> 前排提醒：剧情内容仅为增加实验趣味性所设，**对解题本身毫无影响**！（也就是说如果不愿意看，可以直接在 `config.txt` 中将 `story_mode` 设定为 false）\n\n2034 年，人工智能（AI）已深入渗透人类生活的每个角落，所有设备都由**中央智能实体（CIE）**所控制。一天，作为全球顶尖科学家之一的你，收到来自 CIE 的紧急消息：一个由古早设计者植入的“炸弹”——隐藏在系统核心代码中的病毒——已经在所有 AI 系统中传播，预计将在 14 天后引爆，可能引发全球性的混乱。\n\n你的使命是回到 2024 年，在第一个带病毒的 AI 设备出现的时刻，从根源解决这枚“炸弹”。你必须深入“炸弹”的汇编代码，寻找若干口令来关闭“炸弹”。在这一过程中，你将不断发现被隐藏的真相……\n\n\n\n## 三、实验内容\n\n### 互动式 gdb 教程 gdb-tutor\n\n> 本部分不占分，也不要求必须完成。\n\n在挑战 BombLab 时，gdb 是一个非常有用的工具。为了降低本 Lab 的上手难度，并帮助大家掌握 gdb，认识这一强大的工具，我们编写了这个互动式的 gdb 教程。\n\n使用方法：直接执行 `./gdb-tutor`，教程源码见 `gdb-tutor.c`。\n\n### 二进制炸弹 bomb++\n\n这是一个包含若干关卡的可执行文件。只有你输入满足条件的关卡口令时，才能通过该关卡，到达下一个关卡。如果口令错误，炸弹就会爆炸！（程序会打印爆炸信息并立刻退出）\n\n你的目标是找到所有关卡的正确口令，让炸弹成功解除。炸弹制造者不小心给出了 `main.cpp` ，其中包含了 bomb++ 的主要流程，你可以参考这个源文件了解炸弹的大致逻辑。\n\n如果炸弹爆炸，它将会输出 `BOOM!!!` 并退出。通过每一关后都会有通关提示（并输出一段剧情）；在通关后，它将会输出 `Cool! your skill on Reverse Engineering is great.` （和普通结局剧情）；而通关真结局后，它将会输出 `You are really a Master of Reverse Engineering!` （与真结局剧情）。（详见 `main.cpp`）\n\n> 炸弹会读取 `fail.txt` 并在爆炸时打印其内容，如果你想要很酷炫的爆炸，可以自行修改 `fail.txt` 或直接将其删去。本次实验附赠一只可爱猫猫～\n\n实验各个关卡涉及的知识大致如下：\n\n1. 函数调用\n2. 循环\n3. 分支\n4. 递归\n5. 面向对象\n6. 单调栈\n\nSecret. ████\n\n请注意，Secret 的解锁条件在第三关中进行了提示，或许你能在 `main.cpp` 的某个函数中发现一些违和之处……\n\n> **关于 config.txt**\n>\n> 1. 本次 BombLab 采用了个性化答案制度，即：每个人的答案会依据自己的学号发生变化。**请务必填写自己的学号！**\n>\n>    这一操作位于 `phase_0` 中，**这个函数中的所有内容都和 bomb++ 的内容无关！不需要阅读！不需要阅读！！不需要阅读！！！**（其中包括了各种 `EVP` 开头的函数）\n>\n>    另外，助教会根据每个人的学号来判断答案，如果漏填学号或者填错学号导致的错误，助教一概不负责！\n>\n> 2. 为了便利，本次 BombLab 提供了**跳题**选项！在 `config.txt` 中设置 `test_phase`，bomb++ 只会来测试相应的关卡。\n>\n>    例如：第 3 关卡关，你可以将 `test_pahse` 设置为 `1, 2, 4, 5, 6`, 然后运行 `./bomb` 即可跳过3。\n>\n>    请确保在提交时，`config.txt` 中，`test_phase` 被设置为 `1, 2, 3, 4, 5, 6`，以便助教们直接测试你的答案。\n>\n> 3. 关于剧情模式：~~两位助教讨论了一整晚想出来的剧情~~ 剧情模式是为了增加做实验过程中的乐趣所设，我们真心希望大家写 Lab 时能乐在其中！当然，如果你觉得剧情模式的大段输出影响到了你正常解题，可以在 `config.txt` 中将 `story_mode` 设置为 false。\n>\n>    请确保在提交时，`config.txt` 中，`story_mode` 被设置为 `false`。\n\n\n\n## 四、实验步骤\n\n- 完整阅读本实验文档、从 github classroom 上拉取实验仓库\n- 跟随 gdb-tutor 学习 gdb 的基础使用方法\n- 按需求配置 `config.txt`，包括需要测试的关卡、是否选择开启剧情模式、学号\n- 使用静态分析与动态分析方法分析 bomb++，尽力找出正确的口令\n- 编写实验报告，并在 github classroom 上提交\n\n\n\n## 五、提交事项\n\n### 内容要求\n\n在项目的**根目录**下，需要有**实验报告** `lab2_<学号>.pdf`（要求转为 pdf 格式）以及**正确口令** `password.txt`。注意，`password.txt` 需要满足可以用重定向秒杀 bomb++ 的要求（我们会在后面介绍什么是重定向），我们会用这个来判断你通过了几关。\n\n你的实验报告应包含以下内容：\n\n1. 姓名和学号\n2. 每个关卡的推演过程（重点），如你推测的函数的功能\n3. 拆弹成功的截图（请关闭剧情模式进行截图）\n4. 如果有，请列出引用的内容以及参考的资料\n5. 意见+建议（可选）\n\n> **关于实验报告**\n>\n> 实验报告是用来判断你是否 **独立思考** 来解决本次 Lab 的。\n>\n> 我们不希望看到冗长或表意混乱的报告，请一定不要把报告写成论文 QaQ\n\n### 提交方法\n\n在终端运行以下指令：\n\n```shell\n# 注：需要在仓库的根目录进行操作\ngit add password.txt lab2_<学号>.pdf\n# e.g. git add password.txt lab2_23307130000.pdf\ngit commit -m \"xxx(可以是你的提交注释)\"\n# 将暂存区的所有更改提交到本地仓库\ngit tag \"final\"\n# 对最后一个 commit，请添加 tag: final\ngit push\n# 将本地仓库推送到远程\n```\n\n### 评分\n\n| 项目                 | 分值 |\n| ------------------- | ---- |\n| 提交格式正确          | 5%   |\n| 通过正常关卡 6\\*13%   | 78%  |\n| 通过隐藏关卡          | 7%   |\n| 实验报告             | 10%  |\n\n另：抄袭倒扣分！！勿谓言之不预。\n\n> **反卷斗士の承诺**\n>\n> 实验过程非抄袭的同学，实验报告部分赋满分。一旦发现抄袭，则零分处理。\n\n请大家不要迟交，迟交扣分：\n\n- 迟交 1 天：-10%\n- 迟交 2 天：-20%\n- 迟交 3 天：-50%\n- 迟交 4 天：-70%\n- 迟交 5 天及以上：-100%\n\n## 六、实验指导\n\n本题本质上是一道**逆向工程**题，需要你在没有源代码的情况下复原程序编写者的意图与程序的逻辑。你可能会好奇，我们为什么要学习逆向工程、学习汇编：作为科班 CS 学生，你需要知道自己写出来的程序到底会变成什么样子，到底如何运行，这样你才能知道如何写出更好的程序——正是这些底层的细节将科班程序员和培训班程序员区分开来。这个 Lab 将会帮助你搞清楚机器码 / 汇编语言具体而言如何运作。\n\n除此以外，这个 Lab 还会带你入门逆向工程。逆向工程作为信息安全的一个研究领域，有着许多有趣的应用领域——注册机、软件破解、游戏安全（如修改器、外挂）……除了这些看起来很恶意的应用场景以外，逆向工程一个非常重要的作用就是帮助白帽黑客们找到程序的漏洞，发掘程序的安全问题。不过，最纯粹的逆向工程热爱者，往往是出于自己的好奇心来逆向闭源的软件——这玩意到底怎么实现的？\n\n如果你对逆向工程感兴趣，可以试着从 **CTF（Capture The Flag）** 竞赛开始。逆向工程是 CTF 竞赛的一个主要领域，比赛中出题人会用各种语言、工具编写赛题，试图隐藏程序的逻辑。参赛者需要使用各种工具、结合各种资料来还原程序逻辑。在比赛与练习中，你会接触到各种软件开发技术（如 python、rust、golang、android……）、各种编码和密码学算法（如 Base64、TEA、RC4……），了解其底层的实现原理。我们学校也有相应的社团 / CTF 战队——信息网络安全协会/六星战队，大家可以了解一下哦~\n\n在逆向工程中，分析方法可以大致归类为两类：动态分析与静态分析。简单来说，动态分析就是运行程序、观察其行为；静态分析就是借助可执行文件中的信息与数据（如机器码）还原程序逻辑。在本节中，我们会分别介绍动态分析、静态分析的方法与工具，然后再介绍一些别的小工具。\n\n### 动态分析\n\n最简单的动态分析就是直接运行程序。你可以试试引爆炸弹先。\n\n正经的动态分析就是使用 `gdb`（全称为 GNU Debugger）等调试工具进行动态调试。动态调试的坏处是可能会一不小心让程序“跑飞了”，错过你想要观察的代码；而好处就是你可以直观地看到程序运行时，各种数据的实际值。\n\n至于如何使用，请参考 `gdb-tutor`。\n\n你可以去网上找一个 gdb cheetsheet（小抄），方便你查找想用的指令。我们也给出一个挺好的英文教程：[Tudor‘s gdb crash course](https://users.umiacs.umd.edu/~tdumitra/courses/ENEE757/Fall15/misc/gdb_tutorial.html)。或者可以直接在 Linux 环境下 `man gdb`（man 为 manual 的缩写，是用来查看系统命令和程序的手册页的命令）查看 gdb 的完整文档。\n\n以下为一些 gdb 的常用指令：\n\n| 命令（缩写）     | 作用                                          | 示例              |\n| -------------- | --------------------------------------------- | ----------------- |\n| tab            | 命令或关键字补全                                |                   |\n| run (r)        | 运行程序                                       | r                 |\n| quit (q)       | 退出 gdb                                      | q                 |\n| break (b)      | 打断点，可指定函数名或具体地址                     | b *0x400540       |\n| continue (c)   | 继续运行程序，一般是从断点处开始                   | c                 |\n| print (p)      | 打印数据，可以指定格式，也可以指定寄存器、内存、变量等 | p /x *($rsp+8)    |\n| display (disp) | 指定的内容和print一样，不过可以重复展示             | display /5i $pc   |\n| info (i)       | 获取信息，可指定寄存器、函数、断点信息等             | i r{egister} pc   |\n| delete         | 删除gdb指定的内容，可指定断点等（默认是断点）        | d {break} 1       |\n| stepi (si)     | 执行一条指令，后可跟数字表示执行多条                | si 10             |\n| examine (x)    | 代码检查，后跟具体地址，可以指定输出的方式和格式      | x /10i $pc        |\n| call           | 在gdb中进行函数调用（很神奇的功能）                | call printf(\"\\n\") |\n| backtrace (bt) | 查看调用栈，即函数调用的情况                       | bt                |\n\n### 静态分析\n\n#### 反汇编\n\n我们回顾一下C程序的编译过程：源代码 -> 汇编代码 -> 机器码，中间两步分别称为**编译**与**汇编**。\n\n在源代码到汇编代码的过程中，编译器作了许多的优化、也删去了很多源代码中的信息，比如局部变量名等等……而汇编代码和机器码则是几乎等价的，汇编语言是机器码的助记符。\n\n因此，有工具能帮我们将可执行文件中的机器码转化为汇编代码也就不足为奇了，这种工具被称为**反汇编器**。至于汇编代码到源代码，这种工具也存在，但由于本次实验旨在帮助大家熟悉汇编代码，因此在本次实验中我们不会介绍它们。我们这里介绍一个非常经典且常用的反汇编器——objdump。\n\n我们在命令行中输入 `objdump -d ./bomb > bomb.S` 就可以获得反汇编文件 `bomb.S`。\n\n`objdump --help` 会打印出 objdump 的所有用法，并且会给出精简的解释。`man objdump` 会打印出详尽的解释。\n\n> **关于 objdump**\n>\n> 你可以尝试在 `objdump` 后加上 `-D` 和/或 `-x` 和/或 `-C`，就像上面出现的 `-d` 一样。你可以通过搜索或读文档的方式了解这会导致什么后果；TA 相信这几个参数会对你的实验有很大帮助！\n\n> **X86 / AMD64 汇编语言的格式**\n>\n> 在 CSAPP 课本上，有一个拓展框介绍了两种汇编语言的格式—— AT&T 以及 Intel。\n>\n> 他们最显著的区别有两个（当然还有别的区别，见课本）：\n>\n> - 两者的源操作数和目的操作数顺序相反\n> - AT&T 中寄存器需要加上 `%` 前缀，而 Intel 语法则不用。\n>\n> 本课程上课教学时使用的语法是 AT&T，这也是 objdump 默认使用的语法。但我们同样推荐你试试 Intel 语法，因为这是安全研究人员更常用的一种语法。想让 objdump 输出语法变为 Intel，只需要给 objdump 添加参数 `-M intel`。\n\n#### 阅读汇编\n\n在拿到汇编代码文件后，我们就需要通过分析它来理解程序的逻辑。如果是一个简短的函数，或许汇编也就几十行；但你很有可能会遇到百来行的函数。如何应对这种复杂的代码？\n\n我们介绍一种理解汇编代码的方法，叫做 **CFG（Control Flow Graph，控制流图）**。显然，汇编代码中没有 if-else / for loop / while loop 这样的结构，而只有各种 jump 和 conditional jump。很容易想到，我们可以把各种 jump 指令把它们的目标用一个箭头连起来，来让代码变得稍微好看懂一点。不过，我们还可以做得更加好一些：\n\n![](cfg.png)\n\n这是一个伪代码的例子，我们同样可以将这个方法运用到汇编语言中。构造 CFG 的基础方法很简单：我们只需要把不含跳转代码当作一个 Block，然后把 Block 们连接起来即可。你可以在草稿纸上使用这个方法，将函数的跳转逻辑理清楚。不要小看了 CFG 的作用，亲自试试吧，或许你会从此觉得读汇编语言也不过如此。\n\n另外一种推荐的技巧是……**将汇编代码打印出来**。没错，虽然我知道手写代码一定是痛苦的体验，但在纸上阅读汇编语言代码确实是一种推荐的方法。这是因为，汇编语言的阅读可能需要大量的标注，在纸上标记会方便很多。不过也请注意，bomb++ 的汇编代码很长，包含了许多不会执行或与实验无关的函数。你可以只在遇到应付不了的关卡时才选择把看不懂的那些函数打印出来。\n\n下面给出一些常见结构的汇编代码：\n\n##### 条件判断\n\nC 语言：\n```cpp\nif (array == 0) return;\n```\n\n汇编语言：\n```assembly\nendbr64 \ntest   %rdi,%rdi                       # 让函数第一个参数和自己作与运算\nje     11cb <for_sum(int*, int)+0x22>  # 若结果为 0，则跳转；相当于判断参数是否为 0，为 0 则跳转     \n```\n\n##### 循环结构\n\nC 语言：\n```cpp\ns = 0\nfor (int i = 0; i < size; ++i) s += array[i];\n```\n\n汇编语言：\n```assembly\nmov    $0x0,%eax                       # 初始化自增条件变量 i = 0\nmov    $0x0,%edx                       # 初始化总和 s = 0\ncmp    %esi,%eax                       # 判断条件变量是否满足条件 i < size ?\njge    11d0 <for_sum(int*, int)+0x27>  # 大于或等于则跳出循环\nadd    (%rdi,%eax,4),%edx              # 用 i 进行数组索引 base + i*4 => array[i]; s += array[i]\nadd    $0x1,%eax                       # 自增 i++\njmp    11bc <for_sum(int*, int)+0x13>  # 回到比较的地方\n```\n\n##### switch case 结构\n\n1. 打表：如果 case 的不同条件比较紧凑规律（比如 0、1、2、3......），则将 case 的条件作为索引、对应的地址（可能是地址偏移量）作为值，创建一个表格存放在内存中。\n\n| case | addr   |\n| ---- | ------ |\n| 0    | 0x1000 |\n| 1    | 0x1004 |\n| 2    | 0x1008 |\n| 3    | 0x1010 |\n\n2. 类似 if else 嵌套：如果 case 比较稀疏，则通过采用连续的比较和条件跳转指令\n\n```assembly\ncmp    $0x61,%dil\nje     1224 <switch_case2(char)+0x1c>\ncmp    $0x7a,%dil\nje     1227 <switch_case2(char)+0x1f>\ncmp    $0xa,%dil\nje     122b <switch_case2(char)+0x23>\nlea    0x1(%rdi),%eax\nretq\n```\n\n##### 递归\n\n函数内部调用了函数本身，需要注意对 callee-save 寄存器的保存和使用\n\nC 语言：\n```cpp\nint recursion(int x){ // 求斐波那契数\n    if (x < 2) return x;\n    return recursion(x-1) + recursion(x-2);\n}\n```\n\n汇编语言：\n```assembly\n000000000000122c <recursion(int)>:\npush   %rbp                       # 保存 rbp\npush   %rbx                       # 保存 ebx\nmov    %edi,%ebx                  # 保存第一个参数 x，因为 x 和 rdi 寄存器后续函数都要使用，因此将 x 保存在新的寄存器中（这里是 ebx），防止后续的函数将 rdi 中存放的 x 覆盖掉，而 ebx 因为是 callee-save，因此提前保存了它\ncmp    $0x1,%edi\njle    1258 <recursion(int)+0x2c> # 小于等于 1 则跳转，相当于 x < 2\nlea    -0x1(%rdi),%edi            # x-1\ncallq  122c <recursion(int)>      # recursion(x-1)\nmov    %eax,%ebp                  # 将得到的返回值放在 rbp 中，因为 rbp 是 callee-save，要提前保存\nlea    -0x2(%rbx),%edi            # x-2，这里也用到了 x，因此需要提前保存x\ncallq  122c <recursion(int)>\n...\n```\n\n##### struct\n\n内部变量按顺序排列，需要对齐\n\n```cpp\ntypedef struct {\n    char a = 'y';             // root     \n    unsigned b = 2333;        // root+0x4 虽然之前的 char 只占了 1 个字节，但是 unsigned 需要 4 字节对齐\n    float c = 123.123;        // root+0x8，0xb-0xf 之间的数值为 0\n    double d = 1930.1231313;  // root+0x10 虽然之前的 float 只占了 4 个字节，但是 double 需要 8 字节对齐\n} node;\n```\n\n##### C++虚函数\n\n类的非静态函数调用时，默认第一个参数是指向该对象的指针 **this**\n\n每一个类有唯一的一个虚函数表（vtable，其中只包含虚函数的指针），不是每个对象都有一个 vtable，恰恰是每个同一个类的对象都有一个指针，这个指针指向该类的 vtable（当然，前提是这个类包含虚函数）。那么，每个对象只额外增加了一个指针的大小。\n\n```assembly\nmov    $0x8,%edi                            \ncallq  1090 <operator new(unsigned long)@plt>  # 申请了 8 个字节的空间\nmov    %rax,%rbx                               # 保存该空闲空间的起始地址，即指向对象的指针\nmov    %rax,%rdi\ncallq  158c <B::B()>                           # 调用初始化函数，进行初始化，第一个参数为空闲空间的起始地址，即指向对象的指针 this\n                                               # 对象已经创建好\nmov    (%rbx),%rax                             # 对象的内容只包含一个指针，这条指令通过 this 指针获取对象的内容，即类的 vtable 的起始地址\nmov    (%rax),%rdx                             # 根据类的 vtable 起始地址获取要调用的函数的地址\nmov    $0x2,%esi                               # 函数的第二个参数为 2\nmov    %rax,%rdi\ncallq  *%rdx                                   # 调用 rdx 位置处的函数（* 号只是做标识用，并非取地址），参数分别为对象的地址（this）和 2\n```\n\n### 其他实验帮助\n\n#### 重定向与管道\n\n上过 C 语言和 C++ 的大家应该知道，命令行程序有三个默认打开的“流”，分别是 stdin，stdout 以及 stderr。在我们运行命令行程序时，标准输入就是我们敲进去的东西，而程序打印东西到 stdout 或者 stderr，其实就是打印到命令行上。\n\n在学习 C 或 C++ 的文件操作的时候，会发现一个很巧的事情——文件读写用到的 API，和标准输入输出用的那些 API 其实都差不多，这是因为文件和标准输入输出本来就是一样的。在 Linux 系统中，**一切皆文件**。不仅传统意义上的文本文件、多媒体文件等普通文件是文件，套接字（网络接口）、键盘鼠标设备等等都是文件，可以用统一的一套文件 API 进行处理。\n\n这种设计不仅带来了极大的统一性，也带来了极大的便捷性。本节介绍的 iostream 重定向和 pipes 管道就与这种设计有关。\n\n既然 stdin 和 stdout 也是**文件流**，那么我们当然可以把他们**重定向**到一个普通文件！我们让一个文件被定向到一个程序的标准输入，或者让一个程序的标准输出定向到一个文件当中。前者我们使用 `< file`，后者我们使用 `> file`，如下所示：\n\n```sh\n$ echo hello > hello.txt  \t\t # 把stdout重定向到hello.txt中\n$ cat hello.txt\nhello\n\n$ cat < hello.txt    \t\t\t\t\t # 把hello.txt重定向到cat的标准输入\nhello\n\n$ cat < hello.txt > hello2.txt # 同时重定向cat的标准输入和标准输出\n$ cat hello2.txt\nhello\n```\n\n如果你找到了所有的正确口令，那么把它们写到一个文本文件 `password.txt` 中，那么使用 `./bomb < password.txt` 就可以直接通过所有的关卡。\n\n除此以外，还有更加便利的 **管道** 操作，可以帮助我们将两个程序的输入和输出相连接，也就是构造一条虚拟的管道。这种神奇的操作是通过 `|` 来完成的：\n\n```sh\n$ cat 1.txt            # 假设我们有这么一个文件\nGODEL\nESCHER\nBACH\n$ cat 1.txt | tail -n1 # 打印 1.txt 的最后一行\nBACH\n$ cat 1.txt | grep CH  # 寻找 1.txt 中带有 CH 的行\nESCHER\nBACH\n```\n\n利用这两种操作，我们可以方便地处理BombLab的输入。我们知道 `cat` 是打开文件，也知道标准输入同样也是一个文件，因此我们可以用 `cat -` 打开标准输入文件，这时候 `cat` 就相当于一个 `echo`，可以复读我们说的话：\n\n```sh\n$ cat -\nHello, world!\nHello, world!\n```\n\n除此以外，cat 还可以打开多个文件，如下所示：\n\n```sh\n$ cat 1.txt\nhello\n$ cat 2.txt\nworld\n$ cat 1.txt 2.txt\nhello\nworld\n```\n\n如果你在做 BombLab 时，已经找到了前面某些阶段的口令，不想在后续步骤中再一遍遍重新输入它们的话，就可以将已知的口令写入一个文本文件中，然后用 `cat` 打开那个文本文件以及标准输入，然后利用管道机制将这两个文件的内容导向 bomb++ 的输入：\n\n```sh\n$ cat password.txt - | ./bomb\n```\n\n使用这种操作时注意，由于 bomb++ 每一阶段都会重新读取一行，所以文件结尾多出的换行符会导致 bomb++ 下一阶段读到一个寂寞，从而导致炸弹爆炸。因此，你的口令文件的末尾，应该**有且仅有**一个空行。\n\n> **文件拓展名**\n>\n> 熟悉 Windows 的各位同学一定对诸如 `.exe` `.docx` `.xls` `.png` `.jpeg` 等拓展名见惯不惯了，Windows 系统会通过文件名中的这些后缀来判断如何打开这个程序。\n>\n> 不过在使用 Linux 时，通常不需要你为文件加上拓展名，这是因为 Linux 系统往往通过文件头中的**魔数**来区分文件类型。因此，我们在这里为文本文件标上 `.txt` 后缀类似于注释一样，是为了让大家看得更清楚一些。\n\n#### “超纲”的汇编指令\n\n大家在实验过程中，或许会遇到一些课上没有讲过的汇编指令，我们在这里介绍一下其中一个。\n\n`endbr64`：一种用于防御 ROP（Return Oriented Programming）攻击的机制 —— CET（Control-flow Enforcement）的一部分，但大多的 CPU 现在还没有实装，因此它们执行到这条指令时会直接略过。本次实验并不涉及相关的内容，你也可以直接略过。~~如果对二进制漏洞攻防感兴趣，大家也可以关注信息网络安全协会的相关活动。~~\n\n如果遇到其他没见过的汇编指令，我们建议自己查询互联网。如果你有钻研的精神，欢迎你试着查询 Intel 的官方手册 [英特尔® 64 位和 IA-32 架构开发人员手册](https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html)（5000 行），真正理解这个指令的细节。在查询这种奇厚无比的手册时，请一定记得利用好目录以及搜索功能。\n\n\n\n## 七、参考资料 & 推荐资料\n\n- <http://csapp.cs.cmu.edu/3e/labs.html> 原版 Lab\n- 本实验参考 22、23 年的实验开发\n- [从汇编角度学习 C/C++ - 看雪](https://bbs.kanxue.com/homepage-category-835440-293.htm)\n\n\n\n## 八、实验彩蛋\n\n* 2023ICS BombLab：\n\n<img src=\"meme.jpg\" style=\"width: 320px; height: 320px;display: flex; justify-content: center; align-items: center;\">\n\n\n\n* 曾经可能会出现的剧情\n\n  <img src=\"PlotAdvices.png\" style=\"width: 400px; display: flex; justify-content: center; align-items: center;\">\n","slug":"BombLab","published":1,"date":"2024-10-09T15:35:23.670Z","updated":"2024-10-10T01:42:24.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2yhehkf0001rzx4gfsjftu8","content":"<blockquote>\n<p>Deadline：2024-10-30 23:59:59</p>\n</blockquote>\n<h2 id=\"一实验简介\">一、实验简介</h2>\n<p>CSAPP 第三章配套实验。</p>\n<p>本学期，我们对 CSAPP 的经典 BombLab\n进行了全面再次升级（包括剧情）。你将综合运用 x86 汇编语言 / Linux / gdb\n/ 数据结构 等的相关知识，解决一系列挑战，提升逆向工程技能。</p>\n<p>本次 Lab 由两个部分组成：</p>\n<ul>\n<li>一个互动式 gdb 教程：gdb-tutor</li>\n<li>一个包含若干个关卡的二进制炸弹：bomb++</li>\n</ul>\n<p>你的目标是拆除炸弹，无伤通过 bomb++ 的所有关卡。</p>\n<h2 id=\"二实验剧情\">二、实验剧情</h2>\n<blockquote>\n<p>前排提醒：剧情内容仅为增加实验趣味性所设，<strong>对解题本身毫无影响</strong>！（也就是说如果不愿意看，可以直接在\n<code>config.txt</code> 中将 <code>story_mode</code> 设定为 false）</p>\n</blockquote>\n<p>2034\n年，人工智能（AI）已深入渗透人类生活的每个角落，所有设备都由<strong>中央智能实体（CIE）</strong>所控制。一天，作为全球顶尖科学家之一的你，收到来自\nCIE\n的紧急消息：一个由古早设计者植入的“炸弹”——隐藏在系统核心代码中的病毒——已经在所有\nAI 系统中传播，预计将在 14 天后引爆，可能引发全球性的混乱。</p>\n<p>你的使命是回到 2024 年，在第一个带病毒的 AI\n设备出现的时刻，从根源解决这枚“炸弹”。你必须深入“炸弹”的汇编代码，寻找若干口令来关闭“炸弹”。在这一过程中，你将不断发现被隐藏的真相……</p>\n<h2 id=\"三实验内容\">三、实验内容</h2>\n<h3 id=\"互动式-gdb-教程-gdb-tutor\">互动式 gdb 教程 gdb-tutor</h3>\n<blockquote>\n<p>本部分不占分，也不要求必须完成。</p>\n</blockquote>\n<p>在挑战 BombLab 时，gdb 是一个非常有用的工具。为了降低本 Lab\n的上手难度，并帮助大家掌握\ngdb，认识这一强大的工具，我们编写了这个互动式的 gdb 教程。</p>\n<p>使用方法：直接执行 <code>./gdb-tutor</code>，教程源码见\n<code>gdb-tutor.c</code>。</p>\n<h3 id=\"二进制炸弹-bomb\">二进制炸弹 bomb++</h3>\n<p>这是一个包含若干关卡的可执行文件。只有你输入满足条件的关卡口令时，才能通过该关卡，到达下一个关卡。如果口令错误，炸弹就会爆炸！（程序会打印爆炸信息并立刻退出）</p>\n<p>你的目标是找到所有关卡的正确口令，让炸弹成功解除。炸弹制造者不小心给出了\n<code>main.cpp</code> ，其中包含了 bomb++\n的主要流程，你可以参考这个源文件了解炸弹的大致逻辑。</p>\n<p>如果炸弹爆炸，它将会输出 <code>BOOM!!!</code>\n并退出。通过每一关后都会有通关提示（并输出一段剧情）；在通关后，它将会输出\n<code>Cool! your skill on Reverse Engineering is great.</code>\n（和普通结局剧情）；而通关真结局后，它将会输出\n<code>You are really a Master of Reverse Engineering!</code>\n（与真结局剧情）。（详见 <code>main.cpp</code>）</p>\n<blockquote>\n<p>炸弹会读取 <code>fail.txt</code>\n并在爆炸时打印其内容，如果你想要很酷炫的爆炸，可以自行修改\n<code>fail.txt</code> 或直接将其删去。本次实验附赠一只可爱猫猫～</p>\n</blockquote>\n<p>实验各个关卡涉及的知识大致如下：</p>\n<ol type=\"1\">\n<li>函数调用</li>\n<li>循环</li>\n<li>分支</li>\n<li>递归</li>\n<li>面向对象</li>\n<li>单调栈</li>\n</ol>\n<p>Secret. ████</p>\n<p>请注意，Secret 的解锁条件在第三关中进行了提示，或许你能在\n<code>main.cpp</code> 的某个函数中发现一些违和之处……</p>\n<blockquote>\n<p><strong>关于 config.txt</strong></p>\n<ol type=\"1\">\n<li><p>本次 BombLab\n采用了个性化答案制度，即：每个人的答案会依据自己的学号发生变化。<strong>请务必填写自己的学号！</strong></p>\n<p>这一操作位于 <code>phase_0</code>\n中，<strong>这个函数中的所有内容都和 bomb++\n的内容无关！不需要阅读！不需要阅读！！不需要阅读！！！</strong>（其中包括了各种\n<code>EVP</code> 开头的函数）</p>\n<p>另外，助教会根据每个人的学号来判断答案，如果漏填学号或者填错学号导致的错误，助教一概不负责！</p></li>\n<li><p>为了便利，本次 BombLab 提供了<strong>跳题</strong>选项！在\n<code>config.txt</code> 中设置 <code>test_phase</code>，bomb++\n只会来测试相应的关卡。</p>\n<p>例如：第 3 关卡关，你可以将 <code>test_pahse</code> 设置为\n<code>1, 2, 4, 5, 6</code>, 然后运行 <code>./bomb</code> 即可跳过3。</p>\n<p>请确保在提交时，<code>config.txt</code> 中，<code>test_phase</code>\n被设置为\n<code>1, 2, 3, 4, 5, 6</code>，以便助教们直接测试你的答案。</p></li>\n<li><p>关于剧情模式：<del>两位助教讨论了一整晚想出来的剧情</del>\n剧情模式是为了增加做实验过程中的乐趣所设，我们真心希望大家写 Lab\n时能乐在其中！当然，如果你觉得剧情模式的大段输出影响到了你正常解题，可以在\n<code>config.txt</code> 中将 <code>story_mode</code> 设置为 false。</p>\n<p>请确保在提交时，<code>config.txt</code> 中，<code>story_mode</code>\n被设置为 <code>false</code>。</p></li>\n</ol>\n</blockquote>\n<h2 id=\"四实验步骤\">四、实验步骤</h2>\n<ul>\n<li>完整阅读本实验文档、从 github classroom 上拉取实验仓库</li>\n<li>跟随 gdb-tutor 学习 gdb 的基础使用方法</li>\n<li>按需求配置\n<code>config.txt</code>，包括需要测试的关卡、是否选择开启剧情模式、学号</li>\n<li>使用静态分析与动态分析方法分析 bomb++，尽力找出正确的口令</li>\n<li>编写实验报告，并在 github classroom 上提交</li>\n</ul>\n<h2 id=\"五提交事项\">五、提交事项</h2>\n<h3 id=\"内容要求\">内容要求</h3>\n<p>在项目的<strong>根目录</strong>下，需要有<strong>实验报告</strong>\n<code>lab2_&lt;学号&gt;.pdf</code>（要求转为 pdf\n格式）以及<strong>正确口令</strong>\n<code>password.txt</code>。注意，<code>password.txt</code>\n需要满足可以用重定向秒杀 bomb++\n的要求（我们会在后面介绍什么是重定向），我们会用这个来判断你通过了几关。</p>\n<p>你的实验报告应包含以下内容：</p>\n<ol type=\"1\">\n<li>姓名和学号</li>\n<li>每个关卡的推演过程（重点），如你推测的函数的功能</li>\n<li>拆弹成功的截图（请关闭剧情模式进行截图）</li>\n<li>如果有，请列出引用的内容以及参考的资料</li>\n<li>意见+建议（可选）</li>\n</ol>\n<blockquote>\n<p><strong>关于实验报告</strong></p>\n<p>实验报告是用来判断你是否 <strong>独立思考</strong> 来解决本次 Lab\n的。</p>\n<p>我们不希望看到冗长或表意混乱的报告，请一定不要把报告写成论文 QaQ</p>\n</blockquote>\n<h3 id=\"提交方法\">提交方法</h3>\n<p>在终端运行以下指令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">注：需要在仓库的根目录进行操作</span></span><br><span class=\"line\">git add password.txt lab2_&lt;学号&gt;.pdf</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">e.g. git add password.txt lab2_23307130000.pdf</span></span><br><span class=\"line\">git commit -m &quot;xxx(可以是你的提交注释)&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将暂存区的所有更改提交到本地仓库</span></span><br><span class=\"line\">git tag &quot;final&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">对最后一个 commit，请添加 tag: final</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将本地仓库推送到远程</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"评分\">评分</h3>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>分值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>提交格式正确</td>\n<td>5%</td>\n</tr>\n<tr>\n<td>通过正常关卡 6*13%</td>\n<td>78%</td>\n</tr>\n<tr>\n<td>通过隐藏关卡</td>\n<td>7%</td>\n</tr>\n<tr>\n<td>实验报告</td>\n<td>10%</td>\n</tr>\n</tbody>\n</table>\n<p>另：抄袭倒扣分！！勿谓言之不预。</p>\n<blockquote>\n<p><strong>反卷斗士の承诺</strong></p>\n<p>实验过程非抄袭的同学，实验报告部分赋满分。一旦发现抄袭，则零分处理。</p>\n</blockquote>\n<p>请大家不要迟交，迟交扣分：</p>\n<ul>\n<li>迟交 1 天：-10%</li>\n<li>迟交 2 天：-20%</li>\n<li>迟交 3 天：-50%</li>\n<li>迟交 4 天：-70%</li>\n<li>迟交 5 天及以上：-100%</li>\n</ul>\n<h2 id=\"六实验指导\">六、实验指导</h2>\n<p>本题本质上是一道<strong>逆向工程</strong>题，需要你在没有源代码的情况下复原程序编写者的意图与程序的逻辑。你可能会好奇，我们为什么要学习逆向工程、学习汇编：作为科班\nCS\n学生，你需要知道自己写出来的程序到底会变成什么样子，到底如何运行，这样你才能知道如何写出更好的程序——正是这些底层的细节将科班程序员和培训班程序员区分开来。这个\nLab 将会帮助你搞清楚机器码 / 汇编语言具体而言如何运作。</p>\n<p>除此以外，这个 Lab\n还会带你入门逆向工程。逆向工程作为信息安全的一个研究领域，有着许多有趣的应用领域——注册机、软件破解、游戏安全（如修改器、外挂）……除了这些看起来很恶意的应用场景以外，逆向工程一个非常重要的作用就是帮助白帽黑客们找到程序的漏洞，发掘程序的安全问题。不过，最纯粹的逆向工程热爱者，往往是出于自己的好奇心来逆向闭源的软件——这玩意到底怎么实现的？</p>\n<p>如果你对逆向工程感兴趣，可以试着从 <strong>CTF（Capture The\nFlag）</strong> 竞赛开始。逆向工程是 CTF\n竞赛的一个主要领域，比赛中出题人会用各种语言、工具编写赛题，试图隐藏程序的逻辑。参赛者需要使用各种工具、结合各种资料来还原程序逻辑。在比赛与练习中，你会接触到各种软件开发技术（如\npython、rust、golang、android……）、各种编码和密码学算法（如\nBase64、TEA、RC4……），了解其底层的实现原理。我们学校也有相应的社团 / CTF\n战队——信息网络安全协会/六星战队，大家可以了解一下哦~</p>\n<p>在逆向工程中，分析方法可以大致归类为两类：动态分析与静态分析。简单来说，动态分析就是运行程序、观察其行为；静态分析就是借助可执行文件中的信息与数据（如机器码）还原程序逻辑。在本节中，我们会分别介绍动态分析、静态分析的方法与工具，然后再介绍一些别的小工具。</p>\n<h3 id=\"动态分析\">动态分析</h3>\n<p>最简单的动态分析就是直接运行程序。你可以试试引爆炸弹先。</p>\n<p>正经的动态分析就是使用 <code>gdb</code>（全称为 GNU\nDebugger）等调试工具进行动态调试。动态调试的坏处是可能会一不小心让程序“跑飞了”，错过你想要观察的代码；而好处就是你可以直观地看到程序运行时，各种数据的实际值。</p>\n<p>至于如何使用，请参考 <code>gdb-tutor</code>。</p>\n<p>你可以去网上找一个 gdb\ncheetsheet（小抄），方便你查找想用的指令。我们也给出一个挺好的英文教程：<a\nhref=\"https://users.umiacs.umd.edu/~tdumitra/courses/ENEE757/Fall15/misc/gdb_tutorial.html\">Tudor‘s\ngdb crash course</a>。或者可以直接在 Linux 环境下\n<code>man gdb</code>（man 为 manual\n的缩写，是用来查看系统命令和程序的手册页的命令）查看 gdb\n的完整文档。</p>\n<p>以下为一些 gdb 的常用指令：</p>\n<table>\n<colgroup>\n<col style=\"width: 18%\" />\n<col style=\"width: 59%\" />\n<col style=\"width: 22%\" />\n</colgroup>\n<thead>\n<tr>\n<th>命令（缩写）</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>tab</td>\n<td>命令或关键字补全</td>\n<td></td>\n</tr>\n<tr>\n<td>run (r)</td>\n<td>运行程序</td>\n<td>r</td>\n</tr>\n<tr>\n<td>quit (q)</td>\n<td>退出 gdb</td>\n<td>q</td>\n</tr>\n<tr>\n<td>break (b)</td>\n<td>打断点，可指定函数名或具体地址</td>\n<td>b *0x400540</td>\n</tr>\n<tr>\n<td>continue (c)</td>\n<td>继续运行程序，一般是从断点处开始</td>\n<td>c</td>\n</tr>\n<tr>\n<td>print (p)</td>\n<td>打印数据，可以指定格式，也可以指定寄存器、内存、变量等</td>\n<td>p /x *($rsp+8)</td>\n</tr>\n<tr>\n<td>display (disp)</td>\n<td>指定的内容和print一样，不过可以重复展示</td>\n<td>display /5i $pc</td>\n</tr>\n<tr>\n<td>info (i)</td>\n<td>获取信息，可指定寄存器、函数、断点信息等</td>\n<td>i r{egister} pc</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>删除gdb指定的内容，可指定断点等（默认是断点）</td>\n<td>d {break} 1</td>\n</tr>\n<tr>\n<td>stepi (si)</td>\n<td>执行一条指令，后可跟数字表示执行多条</td>\n<td>si 10</td>\n</tr>\n<tr>\n<td>examine (x)</td>\n<td>代码检查，后跟具体地址，可以指定输出的方式和格式</td>\n<td>x /10i $pc</td>\n</tr>\n<tr>\n<td>call</td>\n<td>在gdb中进行函数调用（很神奇的功能）</td>\n<td>call printf(\"\")</td>\n</tr>\n<tr>\n<td>backtrace (bt)</td>\n<td>查看调用栈，即函数调用的情况</td>\n<td>bt</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"静态分析\">静态分析</h3>\n<h4 id=\"反汇编\">反汇编</h4>\n<p>我们回顾一下C程序的编译过程：源代码 -&gt; 汇编代码 -&gt;\n机器码，中间两步分别称为<strong>编译</strong>与<strong>汇编</strong>。</p>\n<p>在源代码到汇编代码的过程中，编译器作了许多的优化、也删去了很多源代码中的信息，比如局部变量名等等……而汇编代码和机器码则是几乎等价的，汇编语言是机器码的助记符。</p>\n<p>因此，有工具能帮我们将可执行文件中的机器码转化为汇编代码也就不足为奇了，这种工具被称为<strong>反汇编器</strong>。至于汇编代码到源代码，这种工具也存在，但由于本次实验旨在帮助大家熟悉汇编代码，因此在本次实验中我们不会介绍它们。我们这里介绍一个非常经典且常用的反汇编器——objdump。</p>\n<p>我们在命令行中输入 <code>objdump -d ./bomb &gt; bomb.S</code>\n就可以获得反汇编文件 <code>bomb.S</code>。</p>\n<p><code>objdump --help</code> 会打印出 objdump\n的所有用法，并且会给出精简的解释。<code>man objdump</code>\n会打印出详尽的解释。</p>\n<blockquote>\n<p><strong>关于 objdump</strong></p>\n<p>你可以尝试在 <code>objdump</code> 后加上 <code>-D</code> 和/或\n<code>-x</code> 和/或 <code>-C</code>，就像上面出现的 <code>-d</code>\n一样。你可以通过搜索或读文档的方式了解这会导致什么后果；TA\n相信这几个参数会对你的实验有很大帮助！</p>\n</blockquote>\n<blockquote>\n<p><strong>X86 / AMD64 汇编语言的格式</strong></p>\n<p>在 CSAPP 课本上，有一个拓展框介绍了两种汇编语言的格式—— AT&amp;T 以及\nIntel。</p>\n<p>他们最显著的区别有两个（当然还有别的区别，见课本）：</p>\n<ul>\n<li>两者的源操作数和目的操作数顺序相反</li>\n<li>AT&amp;T 中寄存器需要加上 <code>%</code> 前缀，而 Intel\n语法则不用。</li>\n</ul>\n<p>本课程上课教学时使用的语法是 AT&amp;T，这也是 objdump\n默认使用的语法。但我们同样推荐你试试 Intel\n语法，因为这是安全研究人员更常用的一种语法。想让 objdump 输出语法变为\nIntel，只需要给 objdump 添加参数 <code>-M intel</code>。</p>\n</blockquote>\n<h4 id=\"阅读汇编\">阅读汇编</h4>\n<p>在拿到汇编代码文件后，我们就需要通过分析它来理解程序的逻辑。如果是一个简短的函数，或许汇编也就几十行；但你很有可能会遇到百来行的函数。如何应对这种复杂的代码？</p>\n<p>我们介绍一种理解汇编代码的方法，叫做 <strong>CFG（Control Flow\nGraph，控制流图）</strong>。显然，汇编代码中没有 if-else / for loop /\nwhile loop 这样的结构，而只有各种 jump 和 conditional\njump。很容易想到，我们可以把各种 jump\n指令把它们的目标用一个箭头连起来，来让代码变得稍微好看懂一点。不过，我们还可以做得更加好一些：</p>\n<p><img src=\"cfg.png\" /></p>\n<p>这是一个伪代码的例子，我们同样可以将这个方法运用到汇编语言中。构造\nCFG 的基础方法很简单：我们只需要把不含跳转代码当作一个 Block，然后把\nBlock\n们连接起来即可。你可以在草稿纸上使用这个方法，将函数的跳转逻辑理清楚。不要小看了\nCFG 的作用，亲自试试吧，或许你会从此觉得读汇编语言也不过如此。</p>\n<p>另外一种推荐的技巧是……<strong>将汇编代码打印出来</strong>。没错，虽然我知道手写代码一定是痛苦的体验，但在纸上阅读汇编语言代码确实是一种推荐的方法。这是因为，汇编语言的阅读可能需要大量的标注，在纸上标记会方便很多。不过也请注意，bomb++\n的汇编代码很长，包含了许多不会执行或与实验无关的函数。你可以只在遇到应付不了的关卡时才选择把看不懂的那些函数打印出来。</p>\n<p>下面给出一些常见结构的汇编代码：</p>\n<h5 id=\"条件判断\">条件判断</h5>\n<p>C 语言： <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (array == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br></pre></td></tr></table></figure></p>\n<p>汇编语言： <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">endbr64 </span><br><span class=\"line\">test   %rdi,%rdi                       # 让函数第一个参数和自己作与运算</span><br><span class=\"line\">je     11cb &lt;for_sum(int*, int)+0x22&gt;  # 若结果为 0，则跳转；相当于判断参数是否为 0，为 0 则跳转     </span><br></pre></td></tr></table></figure></p>\n<h5 id=\"循环结构\">循环结构</h5>\n<p>C 语言： <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) s += array[i];</span><br></pre></td></tr></table></figure></p>\n<p>汇编语言： <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov    $0x0,%eax                       # 初始化自增条件变量 i = 0</span><br><span class=\"line\">mov    $0x0,%edx                       # 初始化总和 s = 0</span><br><span class=\"line\">cmp    %esi,%eax                       # 判断条件变量是否满足条件 i &lt; size ?</span><br><span class=\"line\">jge    11d0 &lt;for_sum(int*, int)+0x27&gt;  # 大于或等于则跳出循环</span><br><span class=\"line\">add    (%rdi,%eax,4),%edx              # 用 i 进行数组索引 base + i*4 =&gt; array[i]; s += array[i]</span><br><span class=\"line\">add    $0x1,%eax                       # 自增 i++</span><br><span class=\"line\">jmp    11bc &lt;for_sum(int*, int)+0x13&gt;  # 回到比较的地方</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"switch-case-结构\">switch case 结构</h5>\n<ol type=\"1\">\n<li>打表：如果 case 的不同条件比较紧凑规律（比如\n0、1、2、3......），则将 case\n的条件作为索引、对应的地址（可能是地址偏移量）作为值，创建一个表格存放在内存中。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>case</th>\n<th>addr</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0x1000</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0x1004</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0x1008</td>\n</tr>\n<tr>\n<td>3</td>\n<td>0x1010</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"2\" type=\"1\">\n<li>类似 if else 嵌套：如果 case\n比较稀疏，则通过采用连续的比较和条件跳转指令</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmp    $0x61,%dil</span><br><span class=\"line\">je     1224 &lt;switch_case2(char)+0x1c&gt;</span><br><span class=\"line\">cmp    $0x7a,%dil</span><br><span class=\"line\">je     1227 &lt;switch_case2(char)+0x1f&gt;</span><br><span class=\"line\">cmp    $0xa,%dil</span><br><span class=\"line\">je     122b &lt;switch_case2(char)+0x23&gt;</span><br><span class=\"line\">lea    0x1(%rdi),%eax</span><br><span class=\"line\">retq</span><br></pre></td></tr></table></figure>\n<h5 id=\"递归\">递归</h5>\n<p>函数内部调用了函数本身，需要注意对 callee-save 寄存器的保存和使用</p>\n<p>C 语言： <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">recursion</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123; <span class=\"comment\">// 求斐波那契数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">recursion</span>(x<span class=\"number\">-1</span>) + <span class=\"built_in\">recursion</span>(x<span class=\"number\">-2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>汇编语言： <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">000000000000122c &lt;recursion(int)&gt;:</span><br><span class=\"line\">push   %rbp                       # 保存 rbp</span><br><span class=\"line\">push   %rbx                       # 保存 ebx</span><br><span class=\"line\">mov    %edi,%ebx                  # 保存第一个参数 x，因为 x 和 rdi 寄存器后续函数都要使用，因此将 x 保存在新的寄存器中（这里是 ebx），防止后续的函数将 rdi 中存放的 x 覆盖掉，而 ebx 因为是 callee-save，因此提前保存了它</span><br><span class=\"line\">cmp    $0x1,%edi</span><br><span class=\"line\">jle    1258 &lt;recursion(int)+0x2c&gt; # 小于等于 1 则跳转，相当于 x &lt; 2</span><br><span class=\"line\">lea    -0x1(%rdi),%edi            # x-1</span><br><span class=\"line\">callq  122c &lt;recursion(int)&gt;      # recursion(x-1)</span><br><span class=\"line\">mov    %eax,%ebp                  # 将得到的返回值放在 rbp 中，因为 rbp 是 callee-save，要提前保存</span><br><span class=\"line\">lea    -0x2(%rbx),%edi            # x-2，这里也用到了 x，因此需要提前保存x</span><br><span class=\"line\">callq  122c &lt;recursion(int)&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"struct\">struct</h5>\n<p>内部变量按顺序排列，需要对齐</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> a = <span class=\"string\">&#x27;y&#x27;</span>;             <span class=\"comment\">// root     </span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> b = <span class=\"number\">2333</span>;        <span class=\"comment\">// root+0x4 虽然之前的 char 只占了 1 个字节，但是 unsigned 需要 4 字节对齐</span></span><br><span class=\"line\">    <span class=\"type\">float</span> c = <span class=\"number\">123.123</span>;        <span class=\"comment\">// root+0x8，0xb-0xf 之间的数值为 0</span></span><br><span class=\"line\">    <span class=\"type\">double</span> d = <span class=\"number\">1930.1231313</span>;  <span class=\"comment\">// root+0x10 虽然之前的 float 只占了 4 个字节，但是 double 需要 8 字节对齐</span></span><br><span class=\"line\">&#125; node;</span><br></pre></td></tr></table></figure>\n<h5 id=\"c虚函数\">C++虚函数</h5>\n<p>类的非静态函数调用时，默认第一个参数是指向该对象的指针\n<strong>this</strong></p>\n<p>每一个类有唯一的一个虚函数表（vtable，其中只包含虚函数的指针），不是每个对象都有一个\nvtable，恰恰是每个同一个类的对象都有一个指针，这个指针指向该类的\nvtable（当然，前提是这个类包含虚函数）。那么，每个对象只额外增加了一个指针的大小。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov    $0x8,%edi                            </span><br><span class=\"line\">callq  1090 &lt;operator new(unsigned long)@plt&gt;  # 申请了 8 个字节的空间</span><br><span class=\"line\">mov    %rax,%rbx                               # 保存该空闲空间的起始地址，即指向对象的指针</span><br><span class=\"line\">mov    %rax,%rdi</span><br><span class=\"line\">callq  158c &lt;B::B()&gt;                           # 调用初始化函数，进行初始化，第一个参数为空闲空间的起始地址，即指向对象的指针 this</span><br><span class=\"line\">                                               # 对象已经创建好</span><br><span class=\"line\">mov    (%rbx),%rax                             # 对象的内容只包含一个指针，这条指令通过 this 指针获取对象的内容，即类的 vtable 的起始地址</span><br><span class=\"line\">mov    (%rax),%rdx                             # 根据类的 vtable 起始地址获取要调用的函数的地址</span><br><span class=\"line\">mov    $0x2,%esi                               # 函数的第二个参数为 2</span><br><span class=\"line\">mov    %rax,%rdi</span><br><span class=\"line\">callq  *%rdx                                   # 调用 rdx 位置处的函数（* 号只是做标识用，并非取地址），参数分别为对象的地址（this）和 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"其他实验帮助\">其他实验帮助</h3>\n<h4 id=\"重定向与管道\">重定向与管道</h4>\n<p>上过 C 语言和 C++\n的大家应该知道，命令行程序有三个默认打开的“流”，分别是 stdin，stdout\n以及\nstderr。在我们运行命令行程序时，标准输入就是我们敲进去的东西，而程序打印东西到\nstdout 或者 stderr，其实就是打印到命令行上。</p>\n<p>在学习 C 或 C++\n的文件操作的时候，会发现一个很巧的事情——文件读写用到的\nAPI，和标准输入输出用的那些 API\n其实都差不多，这是因为文件和标准输入输出本来就是一样的。在 Linux\n系统中，<strong>一切皆文件</strong>。不仅传统意义上的文本文件、多媒体文件等普通文件是文件，套接字（网络接口）、键盘鼠标设备等等都是文件，可以用统一的一套文件\nAPI 进行处理。</p>\n<p>这种设计不仅带来了极大的统一性，也带来了极大的便捷性。本节介绍的\niostream 重定向和 pipes 管道就与这种设计有关。</p>\n<p>既然 stdin 和 stdout\n也是<strong>文件流</strong>，那么我们当然可以把他们<strong>重定向</strong>到一个普通文件！我们让一个文件被定向到一个程序的标准输入，或者让一个程序的标准输出定向到一个文件当中。前者我们使用\n<code>&lt; file</code>，后者我们使用\n<code>&gt; file</code>，如下所示：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> hello &gt; hello.txt  \t\t <span class=\"comment\"># 把stdout重定向到hello.txt中</span></span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> hello.txt</span><br><span class=\"line\">hello</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> &lt; hello.txt    \t\t\t\t\t <span class=\"comment\"># 把hello.txt重定向到cat的标准输入</span></span><br><span class=\"line\">hello</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> &lt; hello.txt &gt; hello2.txt <span class=\"comment\"># 同时重定向cat的标准输入和标准输出</span></span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> hello2.txt</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n<p>如果你找到了所有的正确口令，那么把它们写到一个文本文件\n<code>password.txt</code> 中，那么使用\n<code>./bomb &lt; password.txt</code> 就可以直接通过所有的关卡。</p>\n<p>除此以外，还有更加便利的 <strong>管道</strong>\n操作，可以帮助我们将两个程序的输入和输出相连接，也就是构造一条虚拟的管道。这种神奇的操作是通过\n<code>|</code> 来完成的：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> 1.txt            <span class=\"comment\"># 假设我们有这么一个文件</span></span><br><span class=\"line\">GODEL</span><br><span class=\"line\">ESCHER</span><br><span class=\"line\">BACH</span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> 1.txt | <span class=\"built_in\">tail</span> -n1 <span class=\"comment\"># 打印 1.txt 的最后一行</span></span><br><span class=\"line\">BACH</span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> 1.txt | grep CH  <span class=\"comment\"># 寻找 1.txt 中带有 CH 的行</span></span><br><span class=\"line\">ESCHER</span><br><span class=\"line\">BACH</span><br></pre></td></tr></table></figure>\n<p>利用这两种操作，我们可以方便地处理BombLab的输入。我们知道\n<code>cat</code>\n是打开文件，也知道标准输入同样也是一个文件，因此我们可以用\n<code>cat -</code> 打开标准输入文件，这时候 <code>cat</code>\n就相当于一个 <code>echo</code>，可以复读我们说的话：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> -</span><br><span class=\"line\">Hello, world!</span><br><span class=\"line\">Hello, world!</span><br></pre></td></tr></table></figure>\n<p>除此以外，cat 还可以打开多个文件，如下所示：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> 1.txt</span><br><span class=\"line\">hello</span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> 2.txt</span><br><span class=\"line\">world</span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> 1.txt 2.txt</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n<p>如果你在做 BombLab\n时，已经找到了前面某些阶段的口令，不想在后续步骤中再一遍遍重新输入它们的话，就可以将已知的口令写入一个文本文件中，然后用\n<code>cat</code>\n打开那个文本文件以及标准输入，然后利用管道机制将这两个文件的内容导向\nbomb++ 的输入：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> password.txt - | ./bomb</span><br></pre></td></tr></table></figure>\n<p>使用这种操作时注意，由于 bomb++\n每一阶段都会重新读取一行，所以文件结尾多出的换行符会导致 bomb++\n下一阶段读到一个寂寞，从而导致炸弹爆炸。因此，你的口令文件的末尾，应该<strong>有且仅有</strong>一个空行。</p>\n<blockquote>\n<p><strong>文件拓展名</strong></p>\n<p>熟悉 Windows 的各位同学一定对诸如 <code>.exe</code>\n<code>.docx</code> <code>.xls</code> <code>.png</code>\n<code>.jpeg</code> 等拓展名见惯不惯了，Windows\n系统会通过文件名中的这些后缀来判断如何打开这个程序。</p>\n<p>不过在使用 Linux 时，通常不需要你为文件加上拓展名，这是因为 Linux\n系统往往通过文件头中的<strong>魔数</strong>来区分文件类型。因此，我们在这里为文本文件标上\n<code>.txt</code> 后缀类似于注释一样，是为了让大家看得更清楚一些。</p>\n</blockquote>\n<h4 id=\"超纲的汇编指令\">“超纲”的汇编指令</h4>\n<p>大家在实验过程中，或许会遇到一些课上没有讲过的汇编指令，我们在这里介绍一下其中一个。</p>\n<p><code>endbr64</code>：一种用于防御 ROP（Return Oriented\nProgramming）攻击的机制 —— CET（Control-flow\nEnforcement）的一部分，但大多的 CPU\n现在还没有实装，因此它们执行到这条指令时会直接略过。本次实验并不涉及相关的内容，你也可以直接略过。<del>如果对二进制漏洞攻防感兴趣，大家也可以关注信息网络安全协会的相关活动。</del></p>\n<p>如果遇到其他没见过的汇编指令，我们建议自己查询互联网。如果你有钻研的精神，欢迎你试着查询\nIntel 的官方手册 <a\nhref=\"https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html\">英特尔®\n64 位和 IA-32 架构开发人员手册</a>（5000\n行），真正理解这个指令的细节。在查询这种奇厚无比的手册时，请一定记得利用好目录以及搜索功能。</p>\n<h2 id=\"七参考资料-推荐资料\">七、参考资料 &amp; 推荐资料</h2>\n<ul>\n<li><a href=\"http://csapp.cs.cmu.edu/3e/labs.html\"\nclass=\"uri\">http://csapp.cs.cmu.edu/3e/labs.html</a> 原版 Lab</li>\n<li>本实验参考 22、23 年的实验开发</li>\n<li><a\nhref=\"https://bbs.kanxue.com/homepage-category-835440-293.htm\">从汇编角度学习\nC/C++ - 看雪</a></li>\n</ul>\n<h2 id=\"八实验彩蛋\">八、实验彩蛋</h2>\n<ul>\n<li>2023ICS BombLab：</li>\n</ul>\n<p><img src=\"meme.jpg\" style=\"width: 320px; height: 320px;display: flex; justify-content: center; align-items: center;\"></p>\n<ul>\n<li><p>曾经可能会出现的剧情</p>\n<p><img src=\"PlotAdvices.png\" style=\"width: 400px; display: flex; justify-content: center; align-items: center;\"></p></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Deadline：2024-10-30 23:59:59</p>\n</blockquote>\n<h2 id=\"一实验简介\">一、实验简介</h2>\n<p>CSAPP 第三章配套实验。</p>\n<p>本学期，我们对 CSAPP 的经典 BombLab\n进行了全面再次升级（包括剧情）。你将综合运用 x86 汇编语言 / Linux / gdb\n/ 数据结构 等的相关知识，解决一系列挑战，提升逆向工程技能。</p>\n<p>本次 Lab 由两个部分组成：</p>\n<ul>\n<li>一个互动式 gdb 教程：gdb-tutor</li>\n<li>一个包含若干个关卡的二进制炸弹：bomb++</li>\n</ul>\n<p>你的目标是拆除炸弹，无伤通过 bomb++ 的所有关卡。</p>\n<h2 id=\"二实验剧情\">二、实验剧情</h2>\n<blockquote>\n<p>前排提醒：剧情内容仅为增加实验趣味性所设，<strong>对解题本身毫无影响</strong>！（也就是说如果不愿意看，可以直接在\n<code>config.txt</code> 中将 <code>story_mode</code> 设定为 false）</p>\n</blockquote>\n<p>2034\n年，人工智能（AI）已深入渗透人类生活的每个角落，所有设备都由<strong>中央智能实体（CIE）</strong>所控制。一天，作为全球顶尖科学家之一的你，收到来自\nCIE\n的紧急消息：一个由古早设计者植入的“炸弹”——隐藏在系统核心代码中的病毒——已经在所有\nAI 系统中传播，预计将在 14 天后引爆，可能引发全球性的混乱。</p>\n<p>你的使命是回到 2024 年，在第一个带病毒的 AI\n设备出现的时刻，从根源解决这枚“炸弹”。你必须深入“炸弹”的汇编代码，寻找若干口令来关闭“炸弹”。在这一过程中，你将不断发现被隐藏的真相……</p>\n<h2 id=\"三实验内容\">三、实验内容</h2>\n<h3 id=\"互动式-gdb-教程-gdb-tutor\">互动式 gdb 教程 gdb-tutor</h3>\n<blockquote>\n<p>本部分不占分，也不要求必须完成。</p>\n</blockquote>\n<p>在挑战 BombLab 时，gdb 是一个非常有用的工具。为了降低本 Lab\n的上手难度，并帮助大家掌握\ngdb，认识这一强大的工具，我们编写了这个互动式的 gdb 教程。</p>\n<p>使用方法：直接执行 <code>./gdb-tutor</code>，教程源码见\n<code>gdb-tutor.c</code>。</p>\n<h3 id=\"二进制炸弹-bomb\">二进制炸弹 bomb++</h3>\n<p>这是一个包含若干关卡的可执行文件。只有你输入满足条件的关卡口令时，才能通过该关卡，到达下一个关卡。如果口令错误，炸弹就会爆炸！（程序会打印爆炸信息并立刻退出）</p>\n<p>你的目标是找到所有关卡的正确口令，让炸弹成功解除。炸弹制造者不小心给出了\n<code>main.cpp</code> ，其中包含了 bomb++\n的主要流程，你可以参考这个源文件了解炸弹的大致逻辑。</p>\n<p>如果炸弹爆炸，它将会输出 <code>BOOM!!!</code>\n并退出。通过每一关后都会有通关提示（并输出一段剧情）；在通关后，它将会输出\n<code>Cool! your skill on Reverse Engineering is great.</code>\n（和普通结局剧情）；而通关真结局后，它将会输出\n<code>You are really a Master of Reverse Engineering!</code>\n（与真结局剧情）。（详见 <code>main.cpp</code>）</p>\n<blockquote>\n<p>炸弹会读取 <code>fail.txt</code>\n并在爆炸时打印其内容，如果你想要很酷炫的爆炸，可以自行修改\n<code>fail.txt</code> 或直接将其删去。本次实验附赠一只可爱猫猫～</p>\n</blockquote>\n<p>实验各个关卡涉及的知识大致如下：</p>\n<ol type=\"1\">\n<li>函数调用</li>\n<li>循环</li>\n<li>分支</li>\n<li>递归</li>\n<li>面向对象</li>\n<li>单调栈</li>\n</ol>\n<p>Secret. ████</p>\n<p>请注意，Secret 的解锁条件在第三关中进行了提示，或许你能在\n<code>main.cpp</code> 的某个函数中发现一些违和之处……</p>\n<blockquote>\n<p><strong>关于 config.txt</strong></p>\n<ol type=\"1\">\n<li><p>本次 BombLab\n采用了个性化答案制度，即：每个人的答案会依据自己的学号发生变化。<strong>请务必填写自己的学号！</strong></p>\n<p>这一操作位于 <code>phase_0</code>\n中，<strong>这个函数中的所有内容都和 bomb++\n的内容无关！不需要阅读！不需要阅读！！不需要阅读！！！</strong>（其中包括了各种\n<code>EVP</code> 开头的函数）</p>\n<p>另外，助教会根据每个人的学号来判断答案，如果漏填学号或者填错学号导致的错误，助教一概不负责！</p></li>\n<li><p>为了便利，本次 BombLab 提供了<strong>跳题</strong>选项！在\n<code>config.txt</code> 中设置 <code>test_phase</code>，bomb++\n只会来测试相应的关卡。</p>\n<p>例如：第 3 关卡关，你可以将 <code>test_pahse</code> 设置为\n<code>1, 2, 4, 5, 6</code>, 然后运行 <code>./bomb</code> 即可跳过3。</p>\n<p>请确保在提交时，<code>config.txt</code> 中，<code>test_phase</code>\n被设置为\n<code>1, 2, 3, 4, 5, 6</code>，以便助教们直接测试你的答案。</p></li>\n<li><p>关于剧情模式：<del>两位助教讨论了一整晚想出来的剧情</del>\n剧情模式是为了增加做实验过程中的乐趣所设，我们真心希望大家写 Lab\n时能乐在其中！当然，如果你觉得剧情模式的大段输出影响到了你正常解题，可以在\n<code>config.txt</code> 中将 <code>story_mode</code> 设置为 false。</p>\n<p>请确保在提交时，<code>config.txt</code> 中，<code>story_mode</code>\n被设置为 <code>false</code>。</p></li>\n</ol>\n</blockquote>\n<h2 id=\"四实验步骤\">四、实验步骤</h2>\n<ul>\n<li>完整阅读本实验文档、从 github classroom 上拉取实验仓库</li>\n<li>跟随 gdb-tutor 学习 gdb 的基础使用方法</li>\n<li>按需求配置\n<code>config.txt</code>，包括需要测试的关卡、是否选择开启剧情模式、学号</li>\n<li>使用静态分析与动态分析方法分析 bomb++，尽力找出正确的口令</li>\n<li>编写实验报告，并在 github classroom 上提交</li>\n</ul>\n<h2 id=\"五提交事项\">五、提交事项</h2>\n<h3 id=\"内容要求\">内容要求</h3>\n<p>在项目的<strong>根目录</strong>下，需要有<strong>实验报告</strong>\n<code>lab2_&lt;学号&gt;.pdf</code>（要求转为 pdf\n格式）以及<strong>正确口令</strong>\n<code>password.txt</code>。注意，<code>password.txt</code>\n需要满足可以用重定向秒杀 bomb++\n的要求（我们会在后面介绍什么是重定向），我们会用这个来判断你通过了几关。</p>\n<p>你的实验报告应包含以下内容：</p>\n<ol type=\"1\">\n<li>姓名和学号</li>\n<li>每个关卡的推演过程（重点），如你推测的函数的功能</li>\n<li>拆弹成功的截图（请关闭剧情模式进行截图）</li>\n<li>如果有，请列出引用的内容以及参考的资料</li>\n<li>意见+建议（可选）</li>\n</ol>\n<blockquote>\n<p><strong>关于实验报告</strong></p>\n<p>实验报告是用来判断你是否 <strong>独立思考</strong> 来解决本次 Lab\n的。</p>\n<p>我们不希望看到冗长或表意混乱的报告，请一定不要把报告写成论文 QaQ</p>\n</blockquote>\n<h3 id=\"提交方法\">提交方法</h3>\n<p>在终端运行以下指令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">注：需要在仓库的根目录进行操作</span></span><br><span class=\"line\">git add password.txt lab2_&lt;学号&gt;.pdf</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">e.g. git add password.txt lab2_23307130000.pdf</span></span><br><span class=\"line\">git commit -m &quot;xxx(可以是你的提交注释)&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将暂存区的所有更改提交到本地仓库</span></span><br><span class=\"line\">git tag &quot;final&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">对最后一个 commit，请添加 tag: final</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将本地仓库推送到远程</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"评分\">评分</h3>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>分值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>提交格式正确</td>\n<td>5%</td>\n</tr>\n<tr>\n<td>通过正常关卡 6*13%</td>\n<td>78%</td>\n</tr>\n<tr>\n<td>通过隐藏关卡</td>\n<td>7%</td>\n</tr>\n<tr>\n<td>实验报告</td>\n<td>10%</td>\n</tr>\n</tbody>\n</table>\n<p>另：抄袭倒扣分！！勿谓言之不预。</p>\n<blockquote>\n<p><strong>反卷斗士の承诺</strong></p>\n<p>实验过程非抄袭的同学，实验报告部分赋满分。一旦发现抄袭，则零分处理。</p>\n</blockquote>\n<p>请大家不要迟交，迟交扣分：</p>\n<ul>\n<li>迟交 1 天：-10%</li>\n<li>迟交 2 天：-20%</li>\n<li>迟交 3 天：-50%</li>\n<li>迟交 4 天：-70%</li>\n<li>迟交 5 天及以上：-100%</li>\n</ul>\n<h2 id=\"六实验指导\">六、实验指导</h2>\n<p>本题本质上是一道<strong>逆向工程</strong>题，需要你在没有源代码的情况下复原程序编写者的意图与程序的逻辑。你可能会好奇，我们为什么要学习逆向工程、学习汇编：作为科班\nCS\n学生，你需要知道自己写出来的程序到底会变成什么样子，到底如何运行，这样你才能知道如何写出更好的程序——正是这些底层的细节将科班程序员和培训班程序员区分开来。这个\nLab 将会帮助你搞清楚机器码 / 汇编语言具体而言如何运作。</p>\n<p>除此以外，这个 Lab\n还会带你入门逆向工程。逆向工程作为信息安全的一个研究领域，有着许多有趣的应用领域——注册机、软件破解、游戏安全（如修改器、外挂）……除了这些看起来很恶意的应用场景以外，逆向工程一个非常重要的作用就是帮助白帽黑客们找到程序的漏洞，发掘程序的安全问题。不过，最纯粹的逆向工程热爱者，往往是出于自己的好奇心来逆向闭源的软件——这玩意到底怎么实现的？</p>\n<p>如果你对逆向工程感兴趣，可以试着从 <strong>CTF（Capture The\nFlag）</strong> 竞赛开始。逆向工程是 CTF\n竞赛的一个主要领域，比赛中出题人会用各种语言、工具编写赛题，试图隐藏程序的逻辑。参赛者需要使用各种工具、结合各种资料来还原程序逻辑。在比赛与练习中，你会接触到各种软件开发技术（如\npython、rust、golang、android……）、各种编码和密码学算法（如\nBase64、TEA、RC4……），了解其底层的实现原理。我们学校也有相应的社团 / CTF\n战队——信息网络安全协会/六星战队，大家可以了解一下哦~</p>\n<p>在逆向工程中，分析方法可以大致归类为两类：动态分析与静态分析。简单来说，动态分析就是运行程序、观察其行为；静态分析就是借助可执行文件中的信息与数据（如机器码）还原程序逻辑。在本节中，我们会分别介绍动态分析、静态分析的方法与工具，然后再介绍一些别的小工具。</p>\n<h3 id=\"动态分析\">动态分析</h3>\n<p>最简单的动态分析就是直接运行程序。你可以试试引爆炸弹先。</p>\n<p>正经的动态分析就是使用 <code>gdb</code>（全称为 GNU\nDebugger）等调试工具进行动态调试。动态调试的坏处是可能会一不小心让程序“跑飞了”，错过你想要观察的代码；而好处就是你可以直观地看到程序运行时，各种数据的实际值。</p>\n<p>至于如何使用，请参考 <code>gdb-tutor</code>。</p>\n<p>你可以去网上找一个 gdb\ncheetsheet（小抄），方便你查找想用的指令。我们也给出一个挺好的英文教程：<a\nhref=\"https://users.umiacs.umd.edu/~tdumitra/courses/ENEE757/Fall15/misc/gdb_tutorial.html\">Tudor‘s\ngdb crash course</a>。或者可以直接在 Linux 环境下\n<code>man gdb</code>（man 为 manual\n的缩写，是用来查看系统命令和程序的手册页的命令）查看 gdb\n的完整文档。</p>\n<p>以下为一些 gdb 的常用指令：</p>\n<table>\n<colgroup>\n<col style=\"width: 18%\" />\n<col style=\"width: 59%\" />\n<col style=\"width: 22%\" />\n</colgroup>\n<thead>\n<tr>\n<th>命令（缩写）</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>tab</td>\n<td>命令或关键字补全</td>\n<td></td>\n</tr>\n<tr>\n<td>run (r)</td>\n<td>运行程序</td>\n<td>r</td>\n</tr>\n<tr>\n<td>quit (q)</td>\n<td>退出 gdb</td>\n<td>q</td>\n</tr>\n<tr>\n<td>break (b)</td>\n<td>打断点，可指定函数名或具体地址</td>\n<td>b *0x400540</td>\n</tr>\n<tr>\n<td>continue (c)</td>\n<td>继续运行程序，一般是从断点处开始</td>\n<td>c</td>\n</tr>\n<tr>\n<td>print (p)</td>\n<td>打印数据，可以指定格式，也可以指定寄存器、内存、变量等</td>\n<td>p /x *($rsp+8)</td>\n</tr>\n<tr>\n<td>display (disp)</td>\n<td>指定的内容和print一样，不过可以重复展示</td>\n<td>display /5i $pc</td>\n</tr>\n<tr>\n<td>info (i)</td>\n<td>获取信息，可指定寄存器、函数、断点信息等</td>\n<td>i r{egister} pc</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>删除gdb指定的内容，可指定断点等（默认是断点）</td>\n<td>d {break} 1</td>\n</tr>\n<tr>\n<td>stepi (si)</td>\n<td>执行一条指令，后可跟数字表示执行多条</td>\n<td>si 10</td>\n</tr>\n<tr>\n<td>examine (x)</td>\n<td>代码检查，后跟具体地址，可以指定输出的方式和格式</td>\n<td>x /10i $pc</td>\n</tr>\n<tr>\n<td>call</td>\n<td>在gdb中进行函数调用（很神奇的功能）</td>\n<td>call printf(\"\")</td>\n</tr>\n<tr>\n<td>backtrace (bt)</td>\n<td>查看调用栈，即函数调用的情况</td>\n<td>bt</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"静态分析\">静态分析</h3>\n<h4 id=\"反汇编\">反汇编</h4>\n<p>我们回顾一下C程序的编译过程：源代码 -&gt; 汇编代码 -&gt;\n机器码，中间两步分别称为<strong>编译</strong>与<strong>汇编</strong>。</p>\n<p>在源代码到汇编代码的过程中，编译器作了许多的优化、也删去了很多源代码中的信息，比如局部变量名等等……而汇编代码和机器码则是几乎等价的，汇编语言是机器码的助记符。</p>\n<p>因此，有工具能帮我们将可执行文件中的机器码转化为汇编代码也就不足为奇了，这种工具被称为<strong>反汇编器</strong>。至于汇编代码到源代码，这种工具也存在，但由于本次实验旨在帮助大家熟悉汇编代码，因此在本次实验中我们不会介绍它们。我们这里介绍一个非常经典且常用的反汇编器——objdump。</p>\n<p>我们在命令行中输入 <code>objdump -d ./bomb &gt; bomb.S</code>\n就可以获得反汇编文件 <code>bomb.S</code>。</p>\n<p><code>objdump --help</code> 会打印出 objdump\n的所有用法，并且会给出精简的解释。<code>man objdump</code>\n会打印出详尽的解释。</p>\n<blockquote>\n<p><strong>关于 objdump</strong></p>\n<p>你可以尝试在 <code>objdump</code> 后加上 <code>-D</code> 和/或\n<code>-x</code> 和/或 <code>-C</code>，就像上面出现的 <code>-d</code>\n一样。你可以通过搜索或读文档的方式了解这会导致什么后果；TA\n相信这几个参数会对你的实验有很大帮助！</p>\n</blockquote>\n<blockquote>\n<p><strong>X86 / AMD64 汇编语言的格式</strong></p>\n<p>在 CSAPP 课本上，有一个拓展框介绍了两种汇编语言的格式—— AT&amp;T 以及\nIntel。</p>\n<p>他们最显著的区别有两个（当然还有别的区别，见课本）：</p>\n<ul>\n<li>两者的源操作数和目的操作数顺序相反</li>\n<li>AT&amp;T 中寄存器需要加上 <code>%</code> 前缀，而 Intel\n语法则不用。</li>\n</ul>\n<p>本课程上课教学时使用的语法是 AT&amp;T，这也是 objdump\n默认使用的语法。但我们同样推荐你试试 Intel\n语法，因为这是安全研究人员更常用的一种语法。想让 objdump 输出语法变为\nIntel，只需要给 objdump 添加参数 <code>-M intel</code>。</p>\n</blockquote>\n<h4 id=\"阅读汇编\">阅读汇编</h4>\n<p>在拿到汇编代码文件后，我们就需要通过分析它来理解程序的逻辑。如果是一个简短的函数，或许汇编也就几十行；但你很有可能会遇到百来行的函数。如何应对这种复杂的代码？</p>\n<p>我们介绍一种理解汇编代码的方法，叫做 <strong>CFG（Control Flow\nGraph，控制流图）</strong>。显然，汇编代码中没有 if-else / for loop /\nwhile loop 这样的结构，而只有各种 jump 和 conditional\njump。很容易想到，我们可以把各种 jump\n指令把它们的目标用一个箭头连起来，来让代码变得稍微好看懂一点。不过，我们还可以做得更加好一些：</p>\n<p><img src=\"cfg.png\" /></p>\n<p>这是一个伪代码的例子，我们同样可以将这个方法运用到汇编语言中。构造\nCFG 的基础方法很简单：我们只需要把不含跳转代码当作一个 Block，然后把\nBlock\n们连接起来即可。你可以在草稿纸上使用这个方法，将函数的跳转逻辑理清楚。不要小看了\nCFG 的作用，亲自试试吧，或许你会从此觉得读汇编语言也不过如此。</p>\n<p>另外一种推荐的技巧是……<strong>将汇编代码打印出来</strong>。没错，虽然我知道手写代码一定是痛苦的体验，但在纸上阅读汇编语言代码确实是一种推荐的方法。这是因为，汇编语言的阅读可能需要大量的标注，在纸上标记会方便很多。不过也请注意，bomb++\n的汇编代码很长，包含了许多不会执行或与实验无关的函数。你可以只在遇到应付不了的关卡时才选择把看不懂的那些函数打印出来。</p>\n<p>下面给出一些常见结构的汇编代码：</p>\n<h5 id=\"条件判断\">条件判断</h5>\n<p>C 语言： <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (array == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br></pre></td></tr></table></figure></p>\n<p>汇编语言： <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">endbr64 </span><br><span class=\"line\">test   %rdi,%rdi                       # 让函数第一个参数和自己作与运算</span><br><span class=\"line\">je     11cb &lt;for_sum(int*, int)+0x22&gt;  # 若结果为 0，则跳转；相当于判断参数是否为 0，为 0 则跳转     </span><br></pre></td></tr></table></figure></p>\n<h5 id=\"循环结构\">循环结构</h5>\n<p>C 语言： <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) s += array[i];</span><br></pre></td></tr></table></figure></p>\n<p>汇编语言： <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov    $0x0,%eax                       # 初始化自增条件变量 i = 0</span><br><span class=\"line\">mov    $0x0,%edx                       # 初始化总和 s = 0</span><br><span class=\"line\">cmp    %esi,%eax                       # 判断条件变量是否满足条件 i &lt; size ?</span><br><span class=\"line\">jge    11d0 &lt;for_sum(int*, int)+0x27&gt;  # 大于或等于则跳出循环</span><br><span class=\"line\">add    (%rdi,%eax,4),%edx              # 用 i 进行数组索引 base + i*4 =&gt; array[i]; s += array[i]</span><br><span class=\"line\">add    $0x1,%eax                       # 自增 i++</span><br><span class=\"line\">jmp    11bc &lt;for_sum(int*, int)+0x13&gt;  # 回到比较的地方</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"switch-case-结构\">switch case 结构</h5>\n<ol type=\"1\">\n<li>打表：如果 case 的不同条件比较紧凑规律（比如\n0、1、2、3......），则将 case\n的条件作为索引、对应的地址（可能是地址偏移量）作为值，创建一个表格存放在内存中。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>case</th>\n<th>addr</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0x1000</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0x1004</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0x1008</td>\n</tr>\n<tr>\n<td>3</td>\n<td>0x1010</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"2\" type=\"1\">\n<li>类似 if else 嵌套：如果 case\n比较稀疏，则通过采用连续的比较和条件跳转指令</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmp    $0x61,%dil</span><br><span class=\"line\">je     1224 &lt;switch_case2(char)+0x1c&gt;</span><br><span class=\"line\">cmp    $0x7a,%dil</span><br><span class=\"line\">je     1227 &lt;switch_case2(char)+0x1f&gt;</span><br><span class=\"line\">cmp    $0xa,%dil</span><br><span class=\"line\">je     122b &lt;switch_case2(char)+0x23&gt;</span><br><span class=\"line\">lea    0x1(%rdi),%eax</span><br><span class=\"line\">retq</span><br></pre></td></tr></table></figure>\n<h5 id=\"递归\">递归</h5>\n<p>函数内部调用了函数本身，需要注意对 callee-save 寄存器的保存和使用</p>\n<p>C 语言： <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">recursion</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123; <span class=\"comment\">// 求斐波那契数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">recursion</span>(x<span class=\"number\">-1</span>) + <span class=\"built_in\">recursion</span>(x<span class=\"number\">-2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>汇编语言： <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">000000000000122c &lt;recursion(int)&gt;:</span><br><span class=\"line\">push   %rbp                       # 保存 rbp</span><br><span class=\"line\">push   %rbx                       # 保存 ebx</span><br><span class=\"line\">mov    %edi,%ebx                  # 保存第一个参数 x，因为 x 和 rdi 寄存器后续函数都要使用，因此将 x 保存在新的寄存器中（这里是 ebx），防止后续的函数将 rdi 中存放的 x 覆盖掉，而 ebx 因为是 callee-save，因此提前保存了它</span><br><span class=\"line\">cmp    $0x1,%edi</span><br><span class=\"line\">jle    1258 &lt;recursion(int)+0x2c&gt; # 小于等于 1 则跳转，相当于 x &lt; 2</span><br><span class=\"line\">lea    -0x1(%rdi),%edi            # x-1</span><br><span class=\"line\">callq  122c &lt;recursion(int)&gt;      # recursion(x-1)</span><br><span class=\"line\">mov    %eax,%ebp                  # 将得到的返回值放在 rbp 中，因为 rbp 是 callee-save，要提前保存</span><br><span class=\"line\">lea    -0x2(%rbx),%edi            # x-2，这里也用到了 x，因此需要提前保存x</span><br><span class=\"line\">callq  122c &lt;recursion(int)&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"struct\">struct</h5>\n<p>内部变量按顺序排列，需要对齐</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> a = <span class=\"string\">&#x27;y&#x27;</span>;             <span class=\"comment\">// root     </span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> b = <span class=\"number\">2333</span>;        <span class=\"comment\">// root+0x4 虽然之前的 char 只占了 1 个字节，但是 unsigned 需要 4 字节对齐</span></span><br><span class=\"line\">    <span class=\"type\">float</span> c = <span class=\"number\">123.123</span>;        <span class=\"comment\">// root+0x8，0xb-0xf 之间的数值为 0</span></span><br><span class=\"line\">    <span class=\"type\">double</span> d = <span class=\"number\">1930.1231313</span>;  <span class=\"comment\">// root+0x10 虽然之前的 float 只占了 4 个字节，但是 double 需要 8 字节对齐</span></span><br><span class=\"line\">&#125; node;</span><br></pre></td></tr></table></figure>\n<h5 id=\"c虚函数\">C++虚函数</h5>\n<p>类的非静态函数调用时，默认第一个参数是指向该对象的指针\n<strong>this</strong></p>\n<p>每一个类有唯一的一个虚函数表（vtable，其中只包含虚函数的指针），不是每个对象都有一个\nvtable，恰恰是每个同一个类的对象都有一个指针，这个指针指向该类的\nvtable（当然，前提是这个类包含虚函数）。那么，每个对象只额外增加了一个指针的大小。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov    $0x8,%edi                            </span><br><span class=\"line\">callq  1090 &lt;operator new(unsigned long)@plt&gt;  # 申请了 8 个字节的空间</span><br><span class=\"line\">mov    %rax,%rbx                               # 保存该空闲空间的起始地址，即指向对象的指针</span><br><span class=\"line\">mov    %rax,%rdi</span><br><span class=\"line\">callq  158c &lt;B::B()&gt;                           # 调用初始化函数，进行初始化，第一个参数为空闲空间的起始地址，即指向对象的指针 this</span><br><span class=\"line\">                                               # 对象已经创建好</span><br><span class=\"line\">mov    (%rbx),%rax                             # 对象的内容只包含一个指针，这条指令通过 this 指针获取对象的内容，即类的 vtable 的起始地址</span><br><span class=\"line\">mov    (%rax),%rdx                             # 根据类的 vtable 起始地址获取要调用的函数的地址</span><br><span class=\"line\">mov    $0x2,%esi                               # 函数的第二个参数为 2</span><br><span class=\"line\">mov    %rax,%rdi</span><br><span class=\"line\">callq  *%rdx                                   # 调用 rdx 位置处的函数（* 号只是做标识用，并非取地址），参数分别为对象的地址（this）和 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"其他实验帮助\">其他实验帮助</h3>\n<h4 id=\"重定向与管道\">重定向与管道</h4>\n<p>上过 C 语言和 C++\n的大家应该知道，命令行程序有三个默认打开的“流”，分别是 stdin，stdout\n以及\nstderr。在我们运行命令行程序时，标准输入就是我们敲进去的东西，而程序打印东西到\nstdout 或者 stderr，其实就是打印到命令行上。</p>\n<p>在学习 C 或 C++\n的文件操作的时候，会发现一个很巧的事情——文件读写用到的\nAPI，和标准输入输出用的那些 API\n其实都差不多，这是因为文件和标准输入输出本来就是一样的。在 Linux\n系统中，<strong>一切皆文件</strong>。不仅传统意义上的文本文件、多媒体文件等普通文件是文件，套接字（网络接口）、键盘鼠标设备等等都是文件，可以用统一的一套文件\nAPI 进行处理。</p>\n<p>这种设计不仅带来了极大的统一性，也带来了极大的便捷性。本节介绍的\niostream 重定向和 pipes 管道就与这种设计有关。</p>\n<p>既然 stdin 和 stdout\n也是<strong>文件流</strong>，那么我们当然可以把他们<strong>重定向</strong>到一个普通文件！我们让一个文件被定向到一个程序的标准输入，或者让一个程序的标准输出定向到一个文件当中。前者我们使用\n<code>&lt; file</code>，后者我们使用\n<code>&gt; file</code>，如下所示：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> hello &gt; hello.txt  \t\t <span class=\"comment\"># 把stdout重定向到hello.txt中</span></span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> hello.txt</span><br><span class=\"line\">hello</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> &lt; hello.txt    \t\t\t\t\t <span class=\"comment\"># 把hello.txt重定向到cat的标准输入</span></span><br><span class=\"line\">hello</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> &lt; hello.txt &gt; hello2.txt <span class=\"comment\"># 同时重定向cat的标准输入和标准输出</span></span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> hello2.txt</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n<p>如果你找到了所有的正确口令，那么把它们写到一个文本文件\n<code>password.txt</code> 中，那么使用\n<code>./bomb &lt; password.txt</code> 就可以直接通过所有的关卡。</p>\n<p>除此以外，还有更加便利的 <strong>管道</strong>\n操作，可以帮助我们将两个程序的输入和输出相连接，也就是构造一条虚拟的管道。这种神奇的操作是通过\n<code>|</code> 来完成的：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> 1.txt            <span class=\"comment\"># 假设我们有这么一个文件</span></span><br><span class=\"line\">GODEL</span><br><span class=\"line\">ESCHER</span><br><span class=\"line\">BACH</span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> 1.txt | <span class=\"built_in\">tail</span> -n1 <span class=\"comment\"># 打印 1.txt 的最后一行</span></span><br><span class=\"line\">BACH</span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> 1.txt | grep CH  <span class=\"comment\"># 寻找 1.txt 中带有 CH 的行</span></span><br><span class=\"line\">ESCHER</span><br><span class=\"line\">BACH</span><br></pre></td></tr></table></figure>\n<p>利用这两种操作，我们可以方便地处理BombLab的输入。我们知道\n<code>cat</code>\n是打开文件，也知道标准输入同样也是一个文件，因此我们可以用\n<code>cat -</code> 打开标准输入文件，这时候 <code>cat</code>\n就相当于一个 <code>echo</code>，可以复读我们说的话：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> -</span><br><span class=\"line\">Hello, world!</span><br><span class=\"line\">Hello, world!</span><br></pre></td></tr></table></figure>\n<p>除此以外，cat 还可以打开多个文件，如下所示：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> 1.txt</span><br><span class=\"line\">hello</span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> 2.txt</span><br><span class=\"line\">world</span><br><span class=\"line\">$ <span class=\"built_in\">cat</span> 1.txt 2.txt</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n<p>如果你在做 BombLab\n时，已经找到了前面某些阶段的口令，不想在后续步骤中再一遍遍重新输入它们的话，就可以将已知的口令写入一个文本文件中，然后用\n<code>cat</code>\n打开那个文本文件以及标准输入，然后利用管道机制将这两个文件的内容导向\nbomb++ 的输入：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> password.txt - | ./bomb</span><br></pre></td></tr></table></figure>\n<p>使用这种操作时注意，由于 bomb++\n每一阶段都会重新读取一行，所以文件结尾多出的换行符会导致 bomb++\n下一阶段读到一个寂寞，从而导致炸弹爆炸。因此，你的口令文件的末尾，应该<strong>有且仅有</strong>一个空行。</p>\n<blockquote>\n<p><strong>文件拓展名</strong></p>\n<p>熟悉 Windows 的各位同学一定对诸如 <code>.exe</code>\n<code>.docx</code> <code>.xls</code> <code>.png</code>\n<code>.jpeg</code> 等拓展名见惯不惯了，Windows\n系统会通过文件名中的这些后缀来判断如何打开这个程序。</p>\n<p>不过在使用 Linux 时，通常不需要你为文件加上拓展名，这是因为 Linux\n系统往往通过文件头中的<strong>魔数</strong>来区分文件类型。因此，我们在这里为文本文件标上\n<code>.txt</code> 后缀类似于注释一样，是为了让大家看得更清楚一些。</p>\n</blockquote>\n<h4 id=\"超纲的汇编指令\">“超纲”的汇编指令</h4>\n<p>大家在实验过程中，或许会遇到一些课上没有讲过的汇编指令，我们在这里介绍一下其中一个。</p>\n<p><code>endbr64</code>：一种用于防御 ROP（Return Oriented\nProgramming）攻击的机制 —— CET（Control-flow\nEnforcement）的一部分，但大多的 CPU\n现在还没有实装，因此它们执行到这条指令时会直接略过。本次实验并不涉及相关的内容，你也可以直接略过。<del>如果对二进制漏洞攻防感兴趣，大家也可以关注信息网络安全协会的相关活动。</del></p>\n<p>如果遇到其他没见过的汇编指令，我们建议自己查询互联网。如果你有钻研的精神，欢迎你试着查询\nIntel 的官方手册 <a\nhref=\"https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html\">英特尔®\n64 位和 IA-32 架构开发人员手册</a>（5000\n行），真正理解这个指令的细节。在查询这种奇厚无比的手册时，请一定记得利用好目录以及搜索功能。</p>\n<h2 id=\"七参考资料-推荐资料\">七、参考资料 &amp; 推荐资料</h2>\n<ul>\n<li><a href=\"http://csapp.cs.cmu.edu/3e/labs.html\"\nclass=\"uri\">http://csapp.cs.cmu.edu/3e/labs.html</a> 原版 Lab</li>\n<li>本实验参考 22、23 年的实验开发</li>\n<li><a\nhref=\"https://bbs.kanxue.com/homepage-category-835440-293.htm\">从汇编角度学习\nC/C++ - 看雪</a></li>\n</ul>\n<h2 id=\"八实验彩蛋\">八、实验彩蛋</h2>\n<ul>\n<li>2023ICS BombLab：</li>\n</ul>\n<p><img src=\"meme.jpg\" style=\"width: 320px; height: 320px;display: flex; justify-content: center; align-items: center;\"></p>\n<ul>\n<li><p>曾经可能会出现的剧情</p>\n<p><img src=\"PlotAdvices.png\" style=\"width: 400px; display: flex; justify-content: center; align-items: center;\"></p></li>\n</ul>\n"},{"title":"DataLab","_content":"\n> Deadline: 2024.10.10 8:00AM\n\n## 一、实验简介\n\nCSAPP 第一章配套实验。\n\n本实验的目的是加深同学们对整数和浮点数二进制表示的认识。同学们需要解出若干程序谜题，编写代码并通过正确性测试，最后提交代码和报告。希望同学们多加思考，在解题过程中能学到的远不止二进制本身，还能加深对位运算的理解，以及学到一些算法知识。\n\n本实验分为常规部和荣誉部分。荣誉部分的难度较高，是本课程比较有挑战性的部分。\n\n荣誉部分虽然占分，但是占分并不高，大家可以自己决定要不要做荣誉部分。Use your discretion！\n\n\n\n## 二、部署实验环境\n\n### （1）下载\n\n从 [github classroom](https://classroom.github.com/a/KMsW51a1) 拉取`ICS2024_datalab` 文件夹，其中的内容就是本次实验用到的的文件了，拉取指令如下：\n\n```shell\ngit clone xxx  # 将 xxx 替换为对应链接\ncd ICS2024_datalab\n```\n\n### （2）准备工作\n\n#### - 确保已安装了 gcc\n\n在终端中检查是否安装了 gcc：\n\n```shell\ngcc -v\n```\n\n如果已安装，终端将会反馈版本信息，否则会反馈 `command not found` 。\n\n如未安装，尝试执行以下命令进行安装：\n\n```shell\nsudo apt-get install gcc\n```\n\n\n\n#### - 确保已安装了 make\n\n检查是否安装 make，在终端输入：\n\n```shell\nmake -v\n```\n\n同理，如未安装，尝试以此执行以下命令：\n\n```shell\nsudo apt-get update\nsudo apt-get install make\nsudo apt-get install libc6 libc6-dev libc6-dev-i386\n```\n\n\n\n#### - 确保实验文件能正常 make 并运行测试\n\n在终端中进入 `datalab/`  文件夹目录。\n\n键入 `ls` 查看内容，你应当看到如下文件：\n\n```shell\nDriverhdrs.pm  Makefile  bits.c  btest.c  decl.c  driver.pl  ishow.c\nDriverlib.pm   README    bits.h  btest.h  dlc     fshow.c    tests.c\n```\n\n在终端中依次执行如下命令，以生成可执行文件并执行：\n\n```shell\nmake clean\nmake all\n./btest\n```\n\n如果过程顺利，最后会输出测试结果，最后一行为 `Total points: 0/69` 。\n\n如果过程中出现如下报错：\n\n```shell\n/usr/bin/ld: cannot found -lgcc\n```\n\n那么尝试执行：\n\n```shell\nsudo apt install gcc-multilib\n```\n\n\n\n#### - 确保 dlc（data lab compiler）能正常执行\n\n依然在 `datalab/`  目录下，\n\n执行：\n\n```shell\n./dlc bits.c\n```\n\n如果遇到 `./dlc: Permission denied`，说明没有当前文件的执行权限，执行:\n```shell\nchmod +x dlc\n```\n增加执行权限。\n\n如果执行立即结束并且没有任何反馈，则没有问题。\n\n\n\n## 三、实验提示与说明\n\n### （1）如何入手\n\n推荐阅读顺序：本文档 > `README` > `bits.c` 的注释部分。\n\n`README` 文档中对实验文件做了较为详细的介绍。\n\n`bits.c` 是同学们唯一需要编辑的文件，其中包含了谜题规则介绍， 18 个谜题以及谜题内容、难度、分数等。\n\n上面的两个文件请务必仔细阅读。\n\n\n\n注意到，每一个谜题包含了如下信息：\n\n* 能使用的运算符。\n* 能使用的运算符总数量。\n* 能使用的常数的值域范围。\n* 变量类型。\n* 能否使用控制语句（如 `if` ）等。\n\n\n\n### （2）测试\n\n* 除了 `bits.c` ，你不应该编辑任何其余文件。\n\n* 完成谜题后，需要检验自己的代码是否正确：\n\n  * 首先，执行下述指令，检查每个函数使用的运算符类型、数目是否符合要求：\n\n  * ```shell\n    ./dlc -e bits.c\n    ```\n\n  * 如没有任何报错，按顺序执行下述指令，测试每个函数的正确性：\n\n  * ```shell\n    make clean\n    make all\n    ./btest\n    ```\n\n  * `btest` 执行时会给出每个谜题（函数）是否通过测试（未通过时会给出测试数据），并且会计算你的最终得分。\n\n* 你可以利用上 `./ishow` 和 `./fshow` 来帮助你调试（用法见 `README`）。\n\n\n\n## 四、提交实验\n\n### （1）内容要求\n\n你需要提交至少两份文件，包含你的 `bits.c` 和一份实验报告。\n\n实验报告应该包含以下内容：\n\n* 实验标题，你的姓名，学号。\n\n* 你在终端中执行 `./dlc -e bits.c` 后的截图。\n* 你在终端中执行 `./btest` 后的截图。\n* 描述你实现每个函数的思路。bits.c中不要求给自己的代码写注释（写了也无妨）\n* 如果有，请务必在报告中列出引用的内容以及参考的资料。\n* 对本实验的感受（可选）。\n* 对助教们的建议（可选）。\n\n### （2）格式要求\n\n可提交 `.md` 文件或者 `.pdf` 文件。不要提交 `.doc` 或 `.docx` 文件。  \n（如果提交 `.md` 文件，请确保助教能同时看到你报告中的截图！）\n\n### （3）上传\n\n在终端运行以下指令：\n\n```shell\ngit add -A\n# 提交当前文件夹下的所有更改到暂存区\ngit commit -m \"xxx(可以是你的提交注释)\"\n# 将暂存区的所有更改提交到本地仓库\ngit push\n# 将本地仓库推送到远程\n```\n\n### （4）打分规则\n\n* 实验报告要求简洁清晰，不必追求字数，描述清楚思路即可\n* 对每道谜题请先做思考，不要立即使用搜索引擎。\n* 不允许抄袭其它人的代码，一旦发现，零分处理。\n\n\n\n## 五、参考资料\n\n* http://csapp.cs.cmu.edu/3e/labs.html （lab 来源，本实验相较原文件有改动）\n\n* 本文档编写时参考了22, 23年的实验文档。\n\n* 负责助教:\n  * 伊凡 21307130047@m.fudan.edu.cn\n  * 李增昊 22307130108@m.fudan.edu.cn\n","source":"_posts/DataLab.md","raw":"---\ntitle: DataLab\n---\n\n> Deadline: 2024.10.10 8:00AM\n\n## 一、实验简介\n\nCSAPP 第一章配套实验。\n\n本实验的目的是加深同学们对整数和浮点数二进制表示的认识。同学们需要解出若干程序谜题，编写代码并通过正确性测试，最后提交代码和报告。希望同学们多加思考，在解题过程中能学到的远不止二进制本身，还能加深对位运算的理解，以及学到一些算法知识。\n\n本实验分为常规部和荣誉部分。荣誉部分的难度较高，是本课程比较有挑战性的部分。\n\n荣誉部分虽然占分，但是占分并不高，大家可以自己决定要不要做荣誉部分。Use your discretion！\n\n\n\n## 二、部署实验环境\n\n### （1）下载\n\n从 [github classroom](https://classroom.github.com/a/KMsW51a1) 拉取`ICS2024_datalab` 文件夹，其中的内容就是本次实验用到的的文件了，拉取指令如下：\n\n```shell\ngit clone xxx  # 将 xxx 替换为对应链接\ncd ICS2024_datalab\n```\n\n### （2）准备工作\n\n#### - 确保已安装了 gcc\n\n在终端中检查是否安装了 gcc：\n\n```shell\ngcc -v\n```\n\n如果已安装，终端将会反馈版本信息，否则会反馈 `command not found` 。\n\n如未安装，尝试执行以下命令进行安装：\n\n```shell\nsudo apt-get install gcc\n```\n\n\n\n#### - 确保已安装了 make\n\n检查是否安装 make，在终端输入：\n\n```shell\nmake -v\n```\n\n同理，如未安装，尝试以此执行以下命令：\n\n```shell\nsudo apt-get update\nsudo apt-get install make\nsudo apt-get install libc6 libc6-dev libc6-dev-i386\n```\n\n\n\n#### - 确保实验文件能正常 make 并运行测试\n\n在终端中进入 `datalab/`  文件夹目录。\n\n键入 `ls` 查看内容，你应当看到如下文件：\n\n```shell\nDriverhdrs.pm  Makefile  bits.c  btest.c  decl.c  driver.pl  ishow.c\nDriverlib.pm   README    bits.h  btest.h  dlc     fshow.c    tests.c\n```\n\n在终端中依次执行如下命令，以生成可执行文件并执行：\n\n```shell\nmake clean\nmake all\n./btest\n```\n\n如果过程顺利，最后会输出测试结果，最后一行为 `Total points: 0/69` 。\n\n如果过程中出现如下报错：\n\n```shell\n/usr/bin/ld: cannot found -lgcc\n```\n\n那么尝试执行：\n\n```shell\nsudo apt install gcc-multilib\n```\n\n\n\n#### - 确保 dlc（data lab compiler）能正常执行\n\n依然在 `datalab/`  目录下，\n\n执行：\n\n```shell\n./dlc bits.c\n```\n\n如果遇到 `./dlc: Permission denied`，说明没有当前文件的执行权限，执行:\n```shell\nchmod +x dlc\n```\n增加执行权限。\n\n如果执行立即结束并且没有任何反馈，则没有问题。\n\n\n\n## 三、实验提示与说明\n\n### （1）如何入手\n\n推荐阅读顺序：本文档 > `README` > `bits.c` 的注释部分。\n\n`README` 文档中对实验文件做了较为详细的介绍。\n\n`bits.c` 是同学们唯一需要编辑的文件，其中包含了谜题规则介绍， 18 个谜题以及谜题内容、难度、分数等。\n\n上面的两个文件请务必仔细阅读。\n\n\n\n注意到，每一个谜题包含了如下信息：\n\n* 能使用的运算符。\n* 能使用的运算符总数量。\n* 能使用的常数的值域范围。\n* 变量类型。\n* 能否使用控制语句（如 `if` ）等。\n\n\n\n### （2）测试\n\n* 除了 `bits.c` ，你不应该编辑任何其余文件。\n\n* 完成谜题后，需要检验自己的代码是否正确：\n\n  * 首先，执行下述指令，检查每个函数使用的运算符类型、数目是否符合要求：\n\n  * ```shell\n    ./dlc -e bits.c\n    ```\n\n  * 如没有任何报错，按顺序执行下述指令，测试每个函数的正确性：\n\n  * ```shell\n    make clean\n    make all\n    ./btest\n    ```\n\n  * `btest` 执行时会给出每个谜题（函数）是否通过测试（未通过时会给出测试数据），并且会计算你的最终得分。\n\n* 你可以利用上 `./ishow` 和 `./fshow` 来帮助你调试（用法见 `README`）。\n\n\n\n## 四、提交实验\n\n### （1）内容要求\n\n你需要提交至少两份文件，包含你的 `bits.c` 和一份实验报告。\n\n实验报告应该包含以下内容：\n\n* 实验标题，你的姓名，学号。\n\n* 你在终端中执行 `./dlc -e bits.c` 后的截图。\n* 你在终端中执行 `./btest` 后的截图。\n* 描述你实现每个函数的思路。bits.c中不要求给自己的代码写注释（写了也无妨）\n* 如果有，请务必在报告中列出引用的内容以及参考的资料。\n* 对本实验的感受（可选）。\n* 对助教们的建议（可选）。\n\n### （2）格式要求\n\n可提交 `.md` 文件或者 `.pdf` 文件。不要提交 `.doc` 或 `.docx` 文件。  \n（如果提交 `.md` 文件，请确保助教能同时看到你报告中的截图！）\n\n### （3）上传\n\n在终端运行以下指令：\n\n```shell\ngit add -A\n# 提交当前文件夹下的所有更改到暂存区\ngit commit -m \"xxx(可以是你的提交注释)\"\n# 将暂存区的所有更改提交到本地仓库\ngit push\n# 将本地仓库推送到远程\n```\n\n### （4）打分规则\n\n* 实验报告要求简洁清晰，不必追求字数，描述清楚思路即可\n* 对每道谜题请先做思考，不要立即使用搜索引擎。\n* 不允许抄袭其它人的代码，一旦发现，零分处理。\n\n\n\n## 五、参考资料\n\n* http://csapp.cs.cmu.edu/3e/labs.html （lab 来源，本实验相较原文件有改动）\n\n* 本文档编写时参考了22, 23年的实验文档。\n\n* 负责助教:\n  * 伊凡 21307130047@m.fudan.edu.cn\n  * 李增昊 22307130108@m.fudan.edu.cn\n","slug":"DataLab","published":1,"date":"2024-09-25T13:47:12.340Z","updated":"2024-09-25T13:47:12.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2yhehkl0003rzx47jnhfuk2","content":"<blockquote>\n<p>Deadline: 2024.10.10 8:00AM</p>\n</blockquote>\n<h2 id=\"一实验简介\">一、实验简介</h2>\n<p>CSAPP 第一章配套实验。</p>\n<p>本实验的目的是加深同学们对整数和浮点数二进制表示的认识。同学们需要解出若干程序谜题，编写代码并通过正确性测试，最后提交代码和报告。希望同学们多加思考，在解题过程中能学到的远不止二进制本身，还能加深对位运算的理解，以及学到一些算法知识。</p>\n<p>本实验分为常规部和荣誉部分。荣誉部分的难度较高，是本课程比较有挑战性的部分。</p>\n<p>荣誉部分虽然占分，但是占分并不高，大家可以自己决定要不要做荣誉部分。Use\nyour discretion！</p>\n<h2 id=\"二部署实验环境\">二、部署实验环境</h2>\n<h3 id=\"下载\">（1）下载</h3>\n<p>从 <a href=\"https://classroom.github.com/a/KMsW51a1\">github\nclassroom</a> 拉取<code>ICS2024_datalab</code>\n文件夹，其中的内容就是本次实验用到的的文件了，拉取指令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone xxx  # 将 xxx 替换为对应链接</span><br><span class=\"line\">cd ICS2024_datalab</span><br></pre></td></tr></table></figure>\n<h3 id=\"准备工作\">（2）准备工作</h3>\n<h4 id=\"确保已安装了-gcc\">- 确保已安装了 gcc</h4>\n<p>在终端中检查是否安装了 gcc：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -v</span><br></pre></td></tr></table></figure>\n<p>如果已安装，终端将会反馈版本信息，否则会反馈\n<code>command not found</code> 。</p>\n<p>如未安装，尝试执行以下命令进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gcc</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保已安装了-make\">- 确保已安装了 make</h4>\n<p>检查是否安装 make，在终端输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make -v</span><br></pre></td></tr></table></figure>\n<p>同理，如未安装，尝试以此执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install make</span><br><span class=\"line\">sudo apt-get install libc6 libc6-dev libc6-dev-i386</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保实验文件能正常-make-并运行测试\">- 确保实验文件能正常 make\n并运行测试</h4>\n<p>在终端中进入 <code>datalab/</code> 文件夹目录。</p>\n<p>键入 <code>ls</code> 查看内容，你应当看到如下文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Driverhdrs.pm  Makefile  bits.c  btest.c  decl.c  driver.pl  ishow.c</span><br><span class=\"line\">Driverlib.pm   README    bits.h  btest.h  dlc     fshow.c    tests.c</span><br></pre></td></tr></table></figure>\n<p>在终端中依次执行如下命令，以生成可执行文件并执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make clean</span><br><span class=\"line\">make all</span><br><span class=\"line\">./btest</span><br></pre></td></tr></table></figure>\n<p>如果过程顺利，最后会输出测试结果，最后一行为\n<code>Total points: 0/69</code> 。</p>\n<p>如果过程中出现如下报错：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ld: cannot found -lgcc</span><br></pre></td></tr></table></figure>\n<p>那么尝试执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install gcc-multilib</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保-dlcdata-lab-compiler能正常执行\">- 确保 dlc（data lab\ncompiler）能正常执行</h4>\n<p>依然在 <code>datalab/</code> 目录下，</p>\n<p>执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./dlc bits.c</span><br></pre></td></tr></table></figure>\n<p>如果遇到\n<code>./dlc: Permission denied</code>，说明没有当前文件的执行权限，执行:\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x dlc</span><br></pre></td></tr></table></figure> 增加执行权限。</p>\n<p>如果执行立即结束并且没有任何反馈，则没有问题。</p>\n<h2 id=\"三实验提示与说明\">三、实验提示与说明</h2>\n<h3 id=\"如何入手\">（1）如何入手</h3>\n<p>推荐阅读顺序：本文档 &gt; <code>README</code> &gt;\n<code>bits.c</code> 的注释部分。</p>\n<p><code>README</code> 文档中对实验文件做了较为详细的介绍。</p>\n<p><code>bits.c</code>\n是同学们唯一需要编辑的文件，其中包含了谜题规则介绍， 18\n个谜题以及谜题内容、难度、分数等。</p>\n<p>上面的两个文件请务必仔细阅读。</p>\n<p>注意到，每一个谜题包含了如下信息：</p>\n<ul>\n<li>能使用的运算符。</li>\n<li>能使用的运算符总数量。</li>\n<li>能使用的常数的值域范围。</li>\n<li>变量类型。</li>\n<li>能否使用控制语句（如 <code>if</code> ）等。</li>\n</ul>\n<h3 id=\"测试\">（2）测试</h3>\n<ul>\n<li><p>除了 <code>bits.c</code> ，你不应该编辑任何其余文件。</p></li>\n<li><p>完成谜题后，需要检验自己的代码是否正确：</p>\n<ul>\n<li><p>首先，执行下述指令，检查每个函数使用的运算符类型、数目是否符合要求：</p></li>\n<li><p>```shell ./dlc -e bits.c <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 如没有任何报错，按顺序执行下述指令，测试每个函数的正确性：</span><br><span class=\"line\"></span><br><span class=\"line\">* ```shell</span><br><span class=\"line\">  make clean</span><br><span class=\"line\">  make all</span><br><span class=\"line\">  ./btest</span><br></pre></td></tr></table></figure></p></li>\n<li><p><code>btest</code>\n执行时会给出每个谜题（函数）是否通过测试（未通过时会给出测试数据），并且会计算你的最终得分。</p></li>\n</ul></li>\n<li><p>你可以利用上 <code>./ishow</code> 和 <code>./fshow</code>\n来帮助你调试（用法见 <code>README</code>）。</p></li>\n</ul>\n<h2 id=\"四提交实验\">四、提交实验</h2>\n<h3 id=\"内容要求\">（1）内容要求</h3>\n<p>你需要提交至少两份文件，包含你的 <code>bits.c</code>\n和一份实验报告。</p>\n<p>实验报告应该包含以下内容：</p>\n<ul>\n<li><p>实验标题，你的姓名，学号。</p></li>\n<li><p>你在终端中执行 <code>./dlc -e bits.c</code> 后的截图。</p></li>\n<li><p>你在终端中执行 <code>./btest</code> 后的截图。</p></li>\n<li><p>描述你实现每个函数的思路。bits.c中不要求给自己的代码写注释（写了也无妨）</p></li>\n<li><p>如果有，请务必在报告中列出引用的内容以及参考的资料。</p></li>\n<li><p>对本实验的感受（可选）。</p></li>\n<li><p>对助教们的建议（可选）。</p></li>\n</ul>\n<h3 id=\"格式要求\">（2）格式要求</h3>\n<p>可提交 <code>.md</code> 文件或者 <code>.pdf</code> 文件。不要提交\n<code>.doc</code> 或 <code>.docx</code> 文件。<br />\n（如果提交 <code>.md</code>\n文件，请确保助教能同时看到你报告中的截图！）</p>\n<h3 id=\"上传\">（3）上传</h3>\n<p>在终端运行以下指令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -A</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">提交当前文件夹下的所有更改到暂存区</span></span><br><span class=\"line\">git commit -m &quot;xxx(可以是你的提交注释)&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将暂存区的所有更改提交到本地仓库</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将本地仓库推送到远程</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"打分规则\">（4）打分规则</h3>\n<ul>\n<li>实验报告要求简洁清晰，不必追求字数，描述清楚思路即可</li>\n<li>对每道谜题请先做思考，不要立即使用搜索引擎。</li>\n<li>不允许抄袭其它人的代码，一旦发现，零分处理。</li>\n</ul>\n<h2 id=\"五参考资料\">五、参考资料</h2>\n<ul>\n<li><p>http://csapp.cs.cmu.edu/3e/labs.html （lab\n来源，本实验相较原文件有改动）</p></li>\n<li><p>本文档编写时参考了22, 23年的实验文档。</p></li>\n<li><p>负责助教:</p>\n<ul>\n<li>伊凡 21307130047@m.fudan.edu.cn</li>\n<li>李增昊 22307130108@m.fudan.edu.cn</li>\n</ul></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Deadline: 2024.10.10 8:00AM</p>\n</blockquote>\n<h2 id=\"一实验简介\">一、实验简介</h2>\n<p>CSAPP 第一章配套实验。</p>\n<p>本实验的目的是加深同学们对整数和浮点数二进制表示的认识。同学们需要解出若干程序谜题，编写代码并通过正确性测试，最后提交代码和报告。希望同学们多加思考，在解题过程中能学到的远不止二进制本身，还能加深对位运算的理解，以及学到一些算法知识。</p>\n<p>本实验分为常规部和荣誉部分。荣誉部分的难度较高，是本课程比较有挑战性的部分。</p>\n<p>荣誉部分虽然占分，但是占分并不高，大家可以自己决定要不要做荣誉部分。Use\nyour discretion！</p>\n<h2 id=\"二部署实验环境\">二、部署实验环境</h2>\n<h3 id=\"下载\">（1）下载</h3>\n<p>从 <a href=\"https://classroom.github.com/a/KMsW51a1\">github\nclassroom</a> 拉取<code>ICS2024_datalab</code>\n文件夹，其中的内容就是本次实验用到的的文件了，拉取指令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone xxx  # 将 xxx 替换为对应链接</span><br><span class=\"line\">cd ICS2024_datalab</span><br></pre></td></tr></table></figure>\n<h3 id=\"准备工作\">（2）准备工作</h3>\n<h4 id=\"确保已安装了-gcc\">- 确保已安装了 gcc</h4>\n<p>在终端中检查是否安装了 gcc：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -v</span><br></pre></td></tr></table></figure>\n<p>如果已安装，终端将会反馈版本信息，否则会反馈\n<code>command not found</code> 。</p>\n<p>如未安装，尝试执行以下命令进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gcc</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保已安装了-make\">- 确保已安装了 make</h4>\n<p>检查是否安装 make，在终端输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make -v</span><br></pre></td></tr></table></figure>\n<p>同理，如未安装，尝试以此执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install make</span><br><span class=\"line\">sudo apt-get install libc6 libc6-dev libc6-dev-i386</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保实验文件能正常-make-并运行测试\">- 确保实验文件能正常 make\n并运行测试</h4>\n<p>在终端中进入 <code>datalab/</code> 文件夹目录。</p>\n<p>键入 <code>ls</code> 查看内容，你应当看到如下文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Driverhdrs.pm  Makefile  bits.c  btest.c  decl.c  driver.pl  ishow.c</span><br><span class=\"line\">Driverlib.pm   README    bits.h  btest.h  dlc     fshow.c    tests.c</span><br></pre></td></tr></table></figure>\n<p>在终端中依次执行如下命令，以生成可执行文件并执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make clean</span><br><span class=\"line\">make all</span><br><span class=\"line\">./btest</span><br></pre></td></tr></table></figure>\n<p>如果过程顺利，最后会输出测试结果，最后一行为\n<code>Total points: 0/69</code> 。</p>\n<p>如果过程中出现如下报错：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ld: cannot found -lgcc</span><br></pre></td></tr></table></figure>\n<p>那么尝试执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install gcc-multilib</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保-dlcdata-lab-compiler能正常执行\">- 确保 dlc（data lab\ncompiler）能正常执行</h4>\n<p>依然在 <code>datalab/</code> 目录下，</p>\n<p>执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./dlc bits.c</span><br></pre></td></tr></table></figure>\n<p>如果遇到\n<code>./dlc: Permission denied</code>，说明没有当前文件的执行权限，执行:\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x dlc</span><br></pre></td></tr></table></figure> 增加执行权限。</p>\n<p>如果执行立即结束并且没有任何反馈，则没有问题。</p>\n<h2 id=\"三实验提示与说明\">三、实验提示与说明</h2>\n<h3 id=\"如何入手\">（1）如何入手</h3>\n<p>推荐阅读顺序：本文档 &gt; <code>README</code> &gt;\n<code>bits.c</code> 的注释部分。</p>\n<p><code>README</code> 文档中对实验文件做了较为详细的介绍。</p>\n<p><code>bits.c</code>\n是同学们唯一需要编辑的文件，其中包含了谜题规则介绍， 18\n个谜题以及谜题内容、难度、分数等。</p>\n<p>上面的两个文件请务必仔细阅读。</p>\n<p>注意到，每一个谜题包含了如下信息：</p>\n<ul>\n<li>能使用的运算符。</li>\n<li>能使用的运算符总数量。</li>\n<li>能使用的常数的值域范围。</li>\n<li>变量类型。</li>\n<li>能否使用控制语句（如 <code>if</code> ）等。</li>\n</ul>\n<h3 id=\"测试\">（2）测试</h3>\n<ul>\n<li><p>除了 <code>bits.c</code> ，你不应该编辑任何其余文件。</p></li>\n<li><p>完成谜题后，需要检验自己的代码是否正确：</p>\n<ul>\n<li><p>首先，执行下述指令，检查每个函数使用的运算符类型、数目是否符合要求：</p></li>\n<li><p>```shell ./dlc -e bits.c <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 如没有任何报错，按顺序执行下述指令，测试每个函数的正确性：</span><br><span class=\"line\"></span><br><span class=\"line\">* ```shell</span><br><span class=\"line\">  make clean</span><br><span class=\"line\">  make all</span><br><span class=\"line\">  ./btest</span><br></pre></td></tr></table></figure></p></li>\n<li><p><code>btest</code>\n执行时会给出每个谜题（函数）是否通过测试（未通过时会给出测试数据），并且会计算你的最终得分。</p></li>\n</ul></li>\n<li><p>你可以利用上 <code>./ishow</code> 和 <code>./fshow</code>\n来帮助你调试（用法见 <code>README</code>）。</p></li>\n</ul>\n<h2 id=\"四提交实验\">四、提交实验</h2>\n<h3 id=\"内容要求\">（1）内容要求</h3>\n<p>你需要提交至少两份文件，包含你的 <code>bits.c</code>\n和一份实验报告。</p>\n<p>实验报告应该包含以下内容：</p>\n<ul>\n<li><p>实验标题，你的姓名，学号。</p></li>\n<li><p>你在终端中执行 <code>./dlc -e bits.c</code> 后的截图。</p></li>\n<li><p>你在终端中执行 <code>./btest</code> 后的截图。</p></li>\n<li><p>描述你实现每个函数的思路。bits.c中不要求给自己的代码写注释（写了也无妨）</p></li>\n<li><p>如果有，请务必在报告中列出引用的内容以及参考的资料。</p></li>\n<li><p>对本实验的感受（可选）。</p></li>\n<li><p>对助教们的建议（可选）。</p></li>\n</ul>\n<h3 id=\"格式要求\">（2）格式要求</h3>\n<p>可提交 <code>.md</code> 文件或者 <code>.pdf</code> 文件。不要提交\n<code>.doc</code> 或 <code>.docx</code> 文件。<br />\n（如果提交 <code>.md</code>\n文件，请确保助教能同时看到你报告中的截图！）</p>\n<h3 id=\"上传\">（3）上传</h3>\n<p>在终端运行以下指令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -A</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">提交当前文件夹下的所有更改到暂存区</span></span><br><span class=\"line\">git commit -m &quot;xxx(可以是你的提交注释)&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将暂存区的所有更改提交到本地仓库</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将本地仓库推送到远程</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"打分规则\">（4）打分规则</h3>\n<ul>\n<li>实验报告要求简洁清晰，不必追求字数，描述清楚思路即可</li>\n<li>对每道谜题请先做思考，不要立即使用搜索引擎。</li>\n<li>不允许抄袭其它人的代码，一旦发现，零分处理。</li>\n</ul>\n<h2 id=\"五参考资料\">五、参考资料</h2>\n<ul>\n<li><p>http://csapp.cs.cmu.edu/3e/labs.html （lab\n来源，本实验相较原文件有改动）</p></li>\n<li><p>本文档编写时参考了22, 23年的实验文档。</p></li>\n<li><p>负责助教:</p>\n<ul>\n<li>伊凡 21307130047@m.fudan.edu.cn</li>\n<li>李增昊 22307130108@m.fudan.edu.cn</li>\n</ul></li>\n</ul>\n"},{"title":"GitLab","author":"徐厚泽","email":"22307110054@m.fudan.edu.cn","_content":"\n> Deadline: 2024-09-25 23:59:59\n\n## 一、实验介绍\n\n* 你需要学会使用一些基本的 git 功能。\n* ~~这个实验非强制性要求~~，但学会使用 git 是大有裨益的\n\n## 二、To-Do List\n\n* git 与 github 基础相关：\n  * 在 wsl（或你使用的其他虚拟机）中安转 git\n  * 在 wsl 中配置 ssh key\n  * 创建 github 账号\n  * 为 github 账号添加 wsl 的 ssh key\n\n* github classroom 相关（也是今后 lab 的发布与提交流程）：\n  * 在 github classroom 中接受作业\n  * 将作业内容 clone 至本地（虚拟机）\n  * 修改本地仓库，上传一个文件，并推送至远程仓库\n\n* （非必需，但推荐）简单学习一下 git 的常用指令\n\n* **完成本次作业需要一次成功的commit，提交内容见下文**\n\n## 三、实验指引\n\n* git 的安装\n  \n  * 参考[这个网站](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git)\n\n  * 本课程只需要在linux环境下安装git，具体流程为：\n    * 打开终端，更新软件包列表：\n\n      ```bash\n      sudo apt update\n      ```\n\n    * 安装 Git：\n\n      ```bash\n      sudo apt install git\n      ```\n\n    * 验证安装是否成功：\n\n      ```bash\n      git --version\n      ```\n\n* 你需要注册一个 [github](https://github.com/) 账号\n* github 配置 **ssh key**\n\n  **NOTE:** 由于我们的实验都在虚拟机 linux 环境下进行，所以无需为本地主机配置 ssh key。如果你以后希望将本地的仓库推送到远程，只要在本地的终端进行下面的配置。\n  \n  * 1.打开 wsl\n  * 2.检查是否已经存在 ssh key。终端运行：\n  \n    ```shell\n    ls ~/.ssh\n    # 列出 ~/.ssh 目录下的所有内容，相当于查看 ~/.ssh 目录是否存在\n    ```\n  \n    如果输出如下， 则跳到第 4 步\n  \n    ![](3.png)\n  \n    若显示 `No such file or directory`，则继续进行第 3 步\n  \n  * 3.生成 ssh key。终端运行\n  \n    ```shell\n    ssh-keygen -t rsa -C \"xxx@xx.com\"\n    # 引号以及里面的内容替换为你的邮箱\n    # 执行后一直回车使用默认值即可（没必要设置密码）\n    ```\n  \n  * 4.获取 ssh key 公钥内容（id_rsa.pub）\n  \n    ```shell\n    cat ~/.ssh/id_rsa.pub\n    # cat 命令用于连接文件并打印到标准输出设备\n    ```\n  \n    如下图所示：\n  \n    ![](4.png)\n  \n    复制该内容（从 ssh-rsa 开始）\n  \n  * 5.github 账号上添加公钥\n    * 点击进入 settings - SSH and GPG keys\n  \n    ![](5.png)\n  \n    * 点击 \"New SSH keys\"，将刚刚复制的公钥粘贴，并给它起个名字，例如 wsl-key\n  * 6.验证是否成功\n\n    ![](6.png)\n  \n* 进入课堂\n\n  * 点击加入 [github classroom](https://classroom.github.com/a/S5MWFPp9)\n\n  * 你将显示如下页面：\n    ![](1.png)\n\n  * 选择和你对应的学号/姓名\n\n  * 完成后：\n    ![](2.png)\n\n  * 这个链接是你的远程仓库（你只能访问自己的，需要保持 github 的登录状态）\n\n* 创建本地仓库（你也可以直接点进链接，直接更新远程仓库，但是推荐使用本地仓库）\n  * 打开 wsl，新建一个 lab 文件夹\n\n    ```shell\n    cd ~\n    # 进入默认文件夹\n    mkdir lab0\n    # 创建名为 lab0 的文件夹（你也可以在此之前创建一个总的课程文件夹，进入之后创建每个 lab 的文件夹）\n    cd lab0\n    # 进入 lab0 文件夹\n    ```\n  \n  * 在网页中访问刚刚获取的链接，点击 \"Code\" 下的 \"SSH\"，复制\n\n    ![](7.png)\n\n  * 运行\n\n    ```shell\n    git clone xxxx\n    # (将 xxxx 替换为刚刚获取的 SSH)\n    # git clone 指令用于将远程仓库克隆到本地\n    ```\n\n    ![](8.png)\n\n    你会发现当前目录下有一个文件夹\n\n    ![](10.png)\n\n  * **NOTE:** 如果你是第一次使用git，你需要配置你的用户信息：\n\n    ```bash\n    git config --global user.name \"你的姓名\"\n    git config --global user.email \"你的邮箱地址\"\n    ```\n\n    * `user.name`：设置提交者的姓名。\n    * `user.email`：设置提交者的邮箱。\n\n    例如：\n\n    ```bash\n    git config --global user.name \"Li Hua\"\n    git config --global user.email \"lihua@example.com\"\n    ```\n\n* 修改本地仓库（vscode 打开）\n  ![](9.png)\n  * 你需要成功上传一个文件，格式为.pdf/.md，内容可以是对这门课的期待~~或者是一只猫猫？~~\n\n* 上传！\n  * 你需要先在终端进入克隆下来的文件夹\n    ![](11.png)\n\n  * 在终端运行以下指令：\n\n    ```shell\n    git add -A\n    # 提交当前文件夹下的所有更改到暂存区\n    git commit -m \"xxx(可以是你的提交注释)\"\n    # 将暂存区的所有更改提交到本地仓库\n    git push\n    # 将本地仓库推送到远程\n    ```\n\n  * 你也可以使用 vscode 自带的提交功能\n\n* 在这里简单介绍一下 git 的功能：\n  * git 是一种**分布式版本控制系统**，可以记录文件的不同版本，方便阶段性保存、回滚等操作，也能确保团队中的多人可以同时在同一项目上工作而不冲突。\n  * 在 git 中，工作区、缓存区和本地仓库是三个核心概念，它们共同构成了 git 的版本控制流程。\n    * **工作区**是实际操作项目文件的地方，可以在这里编辑、删除或添加文件。当你对文件进行修改后，这些更改首先出现在工作区中。此时，文件处于“未跟踪”或“已修改”的状态，git 并未正式记录这些修改。\n    * **缓存区**是一个临时存储区，记录你希望包含在下一个提交（commit）中的更改。也就是说，文件从工作区进入缓存区后，git 会认为这些更改已经准备好被提交。\n    * **本地仓库**是你项目的完整历史记录库。每次提交（commit）都会将缓存区的内容永久保存到本地仓库中。提交后，这些修改就会成为项目历史的一部分。\n    * 另外还有**远程仓库**（如 github）。本地仓库的提交可以推送（push）到远程仓库中，与其他开发者共享。\n\n## 四、参考资料\n\n* [github classroom 的使用](https://www.bilibili.com/video/BV12L41147r7?vd_source=4c29bc15f944e68c9ed01279da29e70e)\n\n* 更多的 git 操作可以参考 lab 文档下的 `Git 基本使用` 或 [这个链接](https://www.fducslg.com/git-and-github/)\n\n* 源网站：https://github.com/fduTristin/Lab0","source":"_posts/GitLab.md","raw":"---\ntitle: GitLab\nauthor: 徐厚泽\nemail: 22307110054@m.fudan.edu.cn\n---\n\n> Deadline: 2024-09-25 23:59:59\n\n## 一、实验介绍\n\n* 你需要学会使用一些基本的 git 功能。\n* ~~这个实验非强制性要求~~，但学会使用 git 是大有裨益的\n\n## 二、To-Do List\n\n* git 与 github 基础相关：\n  * 在 wsl（或你使用的其他虚拟机）中安转 git\n  * 在 wsl 中配置 ssh key\n  * 创建 github 账号\n  * 为 github 账号添加 wsl 的 ssh key\n\n* github classroom 相关（也是今后 lab 的发布与提交流程）：\n  * 在 github classroom 中接受作业\n  * 将作业内容 clone 至本地（虚拟机）\n  * 修改本地仓库，上传一个文件，并推送至远程仓库\n\n* （非必需，但推荐）简单学习一下 git 的常用指令\n\n* **完成本次作业需要一次成功的commit，提交内容见下文**\n\n## 三、实验指引\n\n* git 的安装\n  \n  * 参考[这个网站](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git)\n\n  * 本课程只需要在linux环境下安装git，具体流程为：\n    * 打开终端，更新软件包列表：\n\n      ```bash\n      sudo apt update\n      ```\n\n    * 安装 Git：\n\n      ```bash\n      sudo apt install git\n      ```\n\n    * 验证安装是否成功：\n\n      ```bash\n      git --version\n      ```\n\n* 你需要注册一个 [github](https://github.com/) 账号\n* github 配置 **ssh key**\n\n  **NOTE:** 由于我们的实验都在虚拟机 linux 环境下进行，所以无需为本地主机配置 ssh key。如果你以后希望将本地的仓库推送到远程，只要在本地的终端进行下面的配置。\n  \n  * 1.打开 wsl\n  * 2.检查是否已经存在 ssh key。终端运行：\n  \n    ```shell\n    ls ~/.ssh\n    # 列出 ~/.ssh 目录下的所有内容，相当于查看 ~/.ssh 目录是否存在\n    ```\n  \n    如果输出如下， 则跳到第 4 步\n  \n    ![](3.png)\n  \n    若显示 `No such file or directory`，则继续进行第 3 步\n  \n  * 3.生成 ssh key。终端运行\n  \n    ```shell\n    ssh-keygen -t rsa -C \"xxx@xx.com\"\n    # 引号以及里面的内容替换为你的邮箱\n    # 执行后一直回车使用默认值即可（没必要设置密码）\n    ```\n  \n  * 4.获取 ssh key 公钥内容（id_rsa.pub）\n  \n    ```shell\n    cat ~/.ssh/id_rsa.pub\n    # cat 命令用于连接文件并打印到标准输出设备\n    ```\n  \n    如下图所示：\n  \n    ![](4.png)\n  \n    复制该内容（从 ssh-rsa 开始）\n  \n  * 5.github 账号上添加公钥\n    * 点击进入 settings - SSH and GPG keys\n  \n    ![](5.png)\n  \n    * 点击 \"New SSH keys\"，将刚刚复制的公钥粘贴，并给它起个名字，例如 wsl-key\n  * 6.验证是否成功\n\n    ![](6.png)\n  \n* 进入课堂\n\n  * 点击加入 [github classroom](https://classroom.github.com/a/S5MWFPp9)\n\n  * 你将显示如下页面：\n    ![](1.png)\n\n  * 选择和你对应的学号/姓名\n\n  * 完成后：\n    ![](2.png)\n\n  * 这个链接是你的远程仓库（你只能访问自己的，需要保持 github 的登录状态）\n\n* 创建本地仓库（你也可以直接点进链接，直接更新远程仓库，但是推荐使用本地仓库）\n  * 打开 wsl，新建一个 lab 文件夹\n\n    ```shell\n    cd ~\n    # 进入默认文件夹\n    mkdir lab0\n    # 创建名为 lab0 的文件夹（你也可以在此之前创建一个总的课程文件夹，进入之后创建每个 lab 的文件夹）\n    cd lab0\n    # 进入 lab0 文件夹\n    ```\n  \n  * 在网页中访问刚刚获取的链接，点击 \"Code\" 下的 \"SSH\"，复制\n\n    ![](7.png)\n\n  * 运行\n\n    ```shell\n    git clone xxxx\n    # (将 xxxx 替换为刚刚获取的 SSH)\n    # git clone 指令用于将远程仓库克隆到本地\n    ```\n\n    ![](8.png)\n\n    你会发现当前目录下有一个文件夹\n\n    ![](10.png)\n\n  * **NOTE:** 如果你是第一次使用git，你需要配置你的用户信息：\n\n    ```bash\n    git config --global user.name \"你的姓名\"\n    git config --global user.email \"你的邮箱地址\"\n    ```\n\n    * `user.name`：设置提交者的姓名。\n    * `user.email`：设置提交者的邮箱。\n\n    例如：\n\n    ```bash\n    git config --global user.name \"Li Hua\"\n    git config --global user.email \"lihua@example.com\"\n    ```\n\n* 修改本地仓库（vscode 打开）\n  ![](9.png)\n  * 你需要成功上传一个文件，格式为.pdf/.md，内容可以是对这门课的期待~~或者是一只猫猫？~~\n\n* 上传！\n  * 你需要先在终端进入克隆下来的文件夹\n    ![](11.png)\n\n  * 在终端运行以下指令：\n\n    ```shell\n    git add -A\n    # 提交当前文件夹下的所有更改到暂存区\n    git commit -m \"xxx(可以是你的提交注释)\"\n    # 将暂存区的所有更改提交到本地仓库\n    git push\n    # 将本地仓库推送到远程\n    ```\n\n  * 你也可以使用 vscode 自带的提交功能\n\n* 在这里简单介绍一下 git 的功能：\n  * git 是一种**分布式版本控制系统**，可以记录文件的不同版本，方便阶段性保存、回滚等操作，也能确保团队中的多人可以同时在同一项目上工作而不冲突。\n  * 在 git 中，工作区、缓存区和本地仓库是三个核心概念，它们共同构成了 git 的版本控制流程。\n    * **工作区**是实际操作项目文件的地方，可以在这里编辑、删除或添加文件。当你对文件进行修改后，这些更改首先出现在工作区中。此时，文件处于“未跟踪”或“已修改”的状态，git 并未正式记录这些修改。\n    * **缓存区**是一个临时存储区，记录你希望包含在下一个提交（commit）中的更改。也就是说，文件从工作区进入缓存区后，git 会认为这些更改已经准备好被提交。\n    * **本地仓库**是你项目的完整历史记录库。每次提交（commit）都会将缓存区的内容永久保存到本地仓库中。提交后，这些修改就会成为项目历史的一部分。\n    * 另外还有**远程仓库**（如 github）。本地仓库的提交可以推送（push）到远程仓库中，与其他开发者共享。\n\n## 四、参考资料\n\n* [github classroom 的使用](https://www.bilibili.com/video/BV12L41147r7?vd_source=4c29bc15f944e68c9ed01279da29e70e)\n\n* 更多的 git 操作可以参考 lab 文档下的 `Git 基本使用` 或 [这个链接](https://www.fducslg.com/git-and-github/)\n\n* 源网站：https://github.com/fduTristin/Lab0","slug":"GitLab","published":1,"date":"2024-09-25T13:47:12.347Z","updated":"2024-09-25T13:47:12.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2yhehkl0004rzx4fywkcu3z","content":"<blockquote>\n<p>Deadline: 2024-09-25 23:59:59</p>\n</blockquote>\n<h2 id=\"一实验介绍\">一、实验介绍</h2>\n<ul>\n<li>你需要学会使用一些基本的 git 功能。</li>\n<li><del>这个实验非强制性要求</del>，但学会使用 git 是大有裨益的</li>\n</ul>\n<h2 id=\"二to-do-list\">二、To-Do List</h2>\n<ul>\n<li><p>git 与 github 基础相关：</p>\n<ul>\n<li>在 wsl（或你使用的其他虚拟机）中安转 git</li>\n<li>在 wsl 中配置 ssh key</li>\n<li>创建 github 账号</li>\n<li>为 github 账号添加 wsl 的 ssh key</li>\n</ul></li>\n<li><p>github classroom 相关（也是今后 lab 的发布与提交流程）：</p>\n<ul>\n<li>在 github classroom 中接受作业</li>\n<li>将作业内容 clone 至本地（虚拟机）</li>\n<li>修改本地仓库，上传一个文件，并推送至远程仓库</li>\n</ul></li>\n<li><p>（非必需，但推荐）简单学习一下 git 的常用指令</p></li>\n<li><p><strong>完成本次作业需要一次成功的commit，提交内容见下文</strong></p></li>\n</ul>\n<h2 id=\"三实验指引\">三、实验指引</h2>\n<ul>\n<li><p>git 的安装</p>\n<ul>\n<li><p>参考<a\nhref=\"https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git\">这个网站</a></p></li>\n<li><p>本课程只需要在linux环境下安装git，具体流程为：</p>\n<ul>\n<li><p>打开终端，更新软件包列表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure></li>\n<li><p>安装 Git：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install git</span><br></pre></td></tr></table></figure></li>\n<li><p>验证安装是否成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git --version</span><br></pre></td></tr></table></figure></li>\n</ul></li>\n</ul></li>\n<li><p>你需要注册一个 <a href=\"https://github.com/\">github</a>\n账号</p></li>\n<li><p>github 配置 <strong>ssh key</strong></p>\n<p><strong>NOTE:</strong> 由于我们的实验都在虚拟机 linux\n环境下进行，所以无需为本地主机配置 ssh\nkey。如果你以后希望将本地的仓库推送到远程，只要在本地的终端进行下面的配置。</p>\n<ul>\n<li><p>1.打开 wsl</p></li>\n<li><p>2.检查是否已经存在 ssh key。终端运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls ~/.ssh</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">列出 ~/.ssh 目录下的所有内容，相当于查看 ~/.ssh 目录是否存在</span></span><br></pre></td></tr></table></figure>\n<p>如果输出如下， 则跳到第 4 步</p>\n<p><img src=\"3.png\" /></p>\n<p>若显示 <code>No such file or directory</code>，则继续进行第 3\n步</p></li>\n<li><p>3.生成 ssh key。终端运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;xxx@xx.com&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">引号以及里面的内容替换为你的邮箱</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">执行后一直回车使用默认值即可（没必要设置密码）</span></span><br></pre></td></tr></table></figure></li>\n<li><p>4.获取 ssh key 公钥内容（id_rsa.pub）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> 命令用于连接文件并打印到标准输出设备</span></span><br></pre></td></tr></table></figure>\n<p>如下图所示：</p>\n<p><img src=\"4.png\" /></p>\n<p>复制该内容（从 ssh-rsa 开始）</p></li>\n<li><p>5.github 账号上添加公钥</p>\n<ul>\n<li>点击进入 settings - SSH and GPG keys</li>\n</ul>\n<p><img src=\"5.png\" /></p>\n<ul>\n<li>点击 \"New SSH keys\"，将刚刚复制的公钥粘贴，并给它起个名字，例如\nwsl-key</li>\n</ul></li>\n<li><p>6.验证是否成功</p>\n<p><img src=\"6.png\" /></p></li>\n</ul></li>\n<li><p>进入课堂</p>\n<ul>\n<li><p>点击加入 <a href=\"https://classroom.github.com/a/S5MWFPp9\">github\nclassroom</a></p></li>\n<li><p>你将显示如下页面： <img src=\"1.png\" /></p></li>\n<li><p>选择和你对应的学号/姓名</p></li>\n<li><p>完成后： <img src=\"2.png\" /></p></li>\n<li><p>这个链接是你的远程仓库（你只能访问自己的，需要保持 github\n的登录状态）</p></li>\n</ul></li>\n<li><p>创建本地仓库（你也可以直接点进链接，直接更新远程仓库，但是推荐使用本地仓库）</p>\n<ul>\n<li><p>打开 wsl，新建一个 lab 文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入默认文件夹</span></span><br><span class=\"line\">mkdir lab0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">创建名为 lab0 的文件夹（你也可以在此之前创建一个总的课程文件夹，进入之后创建每个 lab 的文件夹）</span></span><br><span class=\"line\">cd lab0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入 lab0 文件夹</span></span><br></pre></td></tr></table></figure></li>\n<li><p>在网页中访问刚刚获取的链接，点击 \"Code\" 下的 \"SSH\"，复制</p>\n<p><img src=\"7.png\" /></p></li>\n<li><p>运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone xxxx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">(将 xxxx 替换为刚刚获取的 SSH)</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">git <span class=\"built_in\">clone</span> 指令用于将远程仓库克隆到本地</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"8.png\" /></p>\n<p>你会发现当前目录下有一个文件夹</p>\n<p><img src=\"10.png\" /></p></li>\n<li><p><strong>NOTE:</strong>\n如果你是第一次使用git，你需要配置你的用户信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;你的姓名&quot;</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;你的邮箱地址&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>user.name</code>：设置提交者的姓名。</li>\n<li><code>user.email</code>：设置提交者的邮箱。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;Li Hua&quot;</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;lihua@example.com&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul></li>\n<li><p>修改本地仓库（vscode 打开） <img src=\"9.png\" /></p>\n<ul>\n<li>你需要成功上传一个文件，格式为.pdf/.md，内容可以是对这门课的期待<del>或者是一只猫猫？</del></li>\n</ul></li>\n<li><p>上传！</p>\n<ul>\n<li><p>你需要先在终端进入克隆下来的文件夹 <img src=\"11.png\" /></p></li>\n<li><p>在终端运行以下指令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -A</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">提交当前文件夹下的所有更改到暂存区</span></span><br><span class=\"line\">git commit -m &quot;xxx(可以是你的提交注释)&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将暂存区的所有更改提交到本地仓库</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将本地仓库推送到远程</span></span><br></pre></td></tr></table></figure></li>\n<li><p>你也可以使用 vscode 自带的提交功能</p></li>\n</ul></li>\n<li><p>在这里简单介绍一下 git 的功能：</p>\n<ul>\n<li>git\n是一种<strong>分布式版本控制系统</strong>，可以记录文件的不同版本，方便阶段性保存、回滚等操作，也能确保团队中的多人可以同时在同一项目上工作而不冲突。</li>\n<li>在 git 中，工作区、缓存区和本地仓库是三个核心概念，它们共同构成了\ngit 的版本控制流程。\n<ul>\n<li><strong>工作区</strong>是实际操作项目文件的地方，可以在这里编辑、删除或添加文件。当你对文件进行修改后，这些更改首先出现在工作区中。此时，文件处于“未跟踪”或“已修改”的状态，git\n并未正式记录这些修改。</li>\n<li><strong>缓存区</strong>是一个临时存储区，记录你希望包含在下一个提交（commit）中的更改。也就是说，文件从工作区进入缓存区后，git\n会认为这些更改已经准备好被提交。</li>\n<li><strong>本地仓库</strong>是你项目的完整历史记录库。每次提交（commit）都会将缓存区的内容永久保存到本地仓库中。提交后，这些修改就会成为项目历史的一部分。</li>\n<li>另外还有<strong>远程仓库</strong>（如\ngithub）。本地仓库的提交可以推送（push）到远程仓库中，与其他开发者共享。</li>\n</ul></li>\n</ul></li>\n</ul>\n<h2 id=\"四参考资料\">四、参考资料</h2>\n<ul>\n<li><p><a\nhref=\"https://www.bilibili.com/video/BV12L41147r7?vd_source=4c29bc15f944e68c9ed01279da29e70e\">github\nclassroom 的使用</a></p></li>\n<li><p>更多的 git 操作可以参考 lab 文档下的 <code>Git 基本使用</code> 或\n<a href=\"https://www.fducslg.com/git-and-github/\">这个链接</a></p></li>\n<li><p>源网站：https://github.com/fduTristin/Lab0</p></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Deadline: 2024-09-25 23:59:59</p>\n</blockquote>\n<h2 id=\"一实验介绍\">一、实验介绍</h2>\n<ul>\n<li>你需要学会使用一些基本的 git 功能。</li>\n<li><del>这个实验非强制性要求</del>，但学会使用 git 是大有裨益的</li>\n</ul>\n<h2 id=\"二to-do-list\">二、To-Do List</h2>\n<ul>\n<li><p>git 与 github 基础相关：</p>\n<ul>\n<li>在 wsl（或你使用的其他虚拟机）中安转 git</li>\n<li>在 wsl 中配置 ssh key</li>\n<li>创建 github 账号</li>\n<li>为 github 账号添加 wsl 的 ssh key</li>\n</ul></li>\n<li><p>github classroom 相关（也是今后 lab 的发布与提交流程）：</p>\n<ul>\n<li>在 github classroom 中接受作业</li>\n<li>将作业内容 clone 至本地（虚拟机）</li>\n<li>修改本地仓库，上传一个文件，并推送至远程仓库</li>\n</ul></li>\n<li><p>（非必需，但推荐）简单学习一下 git 的常用指令</p></li>\n<li><p><strong>完成本次作业需要一次成功的commit，提交内容见下文</strong></p></li>\n</ul>\n<h2 id=\"三实验指引\">三、实验指引</h2>\n<ul>\n<li><p>git 的安装</p>\n<ul>\n<li><p>参考<a\nhref=\"https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git\">这个网站</a></p></li>\n<li><p>本课程只需要在linux环境下安装git，具体流程为：</p>\n<ul>\n<li><p>打开终端，更新软件包列表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure></li>\n<li><p>安装 Git：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install git</span><br></pre></td></tr></table></figure></li>\n<li><p>验证安装是否成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git --version</span><br></pre></td></tr></table></figure></li>\n</ul></li>\n</ul></li>\n<li><p>你需要注册一个 <a href=\"https://github.com/\">github</a>\n账号</p></li>\n<li><p>github 配置 <strong>ssh key</strong></p>\n<p><strong>NOTE:</strong> 由于我们的实验都在虚拟机 linux\n环境下进行，所以无需为本地主机配置 ssh\nkey。如果你以后希望将本地的仓库推送到远程，只要在本地的终端进行下面的配置。</p>\n<ul>\n<li><p>1.打开 wsl</p></li>\n<li><p>2.检查是否已经存在 ssh key。终端运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls ~/.ssh</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">列出 ~/.ssh 目录下的所有内容，相当于查看 ~/.ssh 目录是否存在</span></span><br></pre></td></tr></table></figure>\n<p>如果输出如下， 则跳到第 4 步</p>\n<p><img src=\"3.png\" /></p>\n<p>若显示 <code>No such file or directory</code>，则继续进行第 3\n步</p></li>\n<li><p>3.生成 ssh key。终端运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;xxx@xx.com&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">引号以及里面的内容替换为你的邮箱</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">执行后一直回车使用默认值即可（没必要设置密码）</span></span><br></pre></td></tr></table></figure></li>\n<li><p>4.获取 ssh key 公钥内容（id_rsa.pub）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> 命令用于连接文件并打印到标准输出设备</span></span><br></pre></td></tr></table></figure>\n<p>如下图所示：</p>\n<p><img src=\"4.png\" /></p>\n<p>复制该内容（从 ssh-rsa 开始）</p></li>\n<li><p>5.github 账号上添加公钥</p>\n<ul>\n<li>点击进入 settings - SSH and GPG keys</li>\n</ul>\n<p><img src=\"5.png\" /></p>\n<ul>\n<li>点击 \"New SSH keys\"，将刚刚复制的公钥粘贴，并给它起个名字，例如\nwsl-key</li>\n</ul></li>\n<li><p>6.验证是否成功</p>\n<p><img src=\"6.png\" /></p></li>\n</ul></li>\n<li><p>进入课堂</p>\n<ul>\n<li><p>点击加入 <a href=\"https://classroom.github.com/a/S5MWFPp9\">github\nclassroom</a></p></li>\n<li><p>你将显示如下页面： <img src=\"1.png\" /></p></li>\n<li><p>选择和你对应的学号/姓名</p></li>\n<li><p>完成后： <img src=\"2.png\" /></p></li>\n<li><p>这个链接是你的远程仓库（你只能访问自己的，需要保持 github\n的登录状态）</p></li>\n</ul></li>\n<li><p>创建本地仓库（你也可以直接点进链接，直接更新远程仓库，但是推荐使用本地仓库）</p>\n<ul>\n<li><p>打开 wsl，新建一个 lab 文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入默认文件夹</span></span><br><span class=\"line\">mkdir lab0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">创建名为 lab0 的文件夹（你也可以在此之前创建一个总的课程文件夹，进入之后创建每个 lab 的文件夹）</span></span><br><span class=\"line\">cd lab0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入 lab0 文件夹</span></span><br></pre></td></tr></table></figure></li>\n<li><p>在网页中访问刚刚获取的链接，点击 \"Code\" 下的 \"SSH\"，复制</p>\n<p><img src=\"7.png\" /></p></li>\n<li><p>运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone xxxx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">(将 xxxx 替换为刚刚获取的 SSH)</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">git <span class=\"built_in\">clone</span> 指令用于将远程仓库克隆到本地</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"8.png\" /></p>\n<p>你会发现当前目录下有一个文件夹</p>\n<p><img src=\"10.png\" /></p></li>\n<li><p><strong>NOTE:</strong>\n如果你是第一次使用git，你需要配置你的用户信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;你的姓名&quot;</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;你的邮箱地址&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>user.name</code>：设置提交者的姓名。</li>\n<li><code>user.email</code>：设置提交者的邮箱。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;Li Hua&quot;</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;lihua@example.com&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul></li>\n<li><p>修改本地仓库（vscode 打开） <img src=\"9.png\" /></p>\n<ul>\n<li>你需要成功上传一个文件，格式为.pdf/.md，内容可以是对这门课的期待<del>或者是一只猫猫？</del></li>\n</ul></li>\n<li><p>上传！</p>\n<ul>\n<li><p>你需要先在终端进入克隆下来的文件夹 <img src=\"11.png\" /></p></li>\n<li><p>在终端运行以下指令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -A</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">提交当前文件夹下的所有更改到暂存区</span></span><br><span class=\"line\">git commit -m &quot;xxx(可以是你的提交注释)&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将暂存区的所有更改提交到本地仓库</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将本地仓库推送到远程</span></span><br></pre></td></tr></table></figure></li>\n<li><p>你也可以使用 vscode 自带的提交功能</p></li>\n</ul></li>\n<li><p>在这里简单介绍一下 git 的功能：</p>\n<ul>\n<li>git\n是一种<strong>分布式版本控制系统</strong>，可以记录文件的不同版本，方便阶段性保存、回滚等操作，也能确保团队中的多人可以同时在同一项目上工作而不冲突。</li>\n<li>在 git 中，工作区、缓存区和本地仓库是三个核心概念，它们共同构成了\ngit 的版本控制流程。\n<ul>\n<li><strong>工作区</strong>是实际操作项目文件的地方，可以在这里编辑、删除或添加文件。当你对文件进行修改后，这些更改首先出现在工作区中。此时，文件处于“未跟踪”或“已修改”的状态，git\n并未正式记录这些修改。</li>\n<li><strong>缓存区</strong>是一个临时存储区，记录你希望包含在下一个提交（commit）中的更改。也就是说，文件从工作区进入缓存区后，git\n会认为这些更改已经准备好被提交。</li>\n<li><strong>本地仓库</strong>是你项目的完整历史记录库。每次提交（commit）都会将缓存区的内容永久保存到本地仓库中。提交后，这些修改就会成为项目历史的一部分。</li>\n<li>另外还有<strong>远程仓库</strong>（如\ngithub）。本地仓库的提交可以推送（push）到远程仓库中，与其他开发者共享。</li>\n</ul></li>\n</ul></li>\n</ul>\n<h2 id=\"四参考资料\">四、参考资料</h2>\n<ul>\n<li><p><a\nhref=\"https://www.bilibili.com/video/BV12L41147r7?vd_source=4c29bc15f944e68c9ed01279da29e70e\">github\nclassroom 的使用</a></p></li>\n<li><p>更多的 git 操作可以参考 lab 文档下的 <code>Git 基本使用</code> 或\n<a href=\"https://www.fducslg.com/git-and-github/\">这个链接</a></p></li>\n<li><p>源网站：https://github.com/fduTristin/Lab0</p></li>\n</ul>\n"},{"_content":"# ICS 实验入门手册 2024\n\n## I. Linux 系统\n\n本学期的实验需要使用 Linux 系统。如果你的电脑不是 Linux 系统，则需要使用虚拟机安装 Linux 系统。\n\n手册中介绍 VMWare Workstation Pro 和 WSL 2 两种虚拟机方案。 **建议 Windows 系统的同学选择 WSL 2。**\n\n**VMWare Desktop Hypervisor**\n\nVMWare 在 Windows/MacOS 系统上的虚拟化软件 Workstation Pro 以及 Fusion Pro 于2024年5月13日起供个人免费使用，可在[官方网站](https://www.vmware.com/products/desktop-hypervisor/workstation-and-fusion)下载。这两个虚拟化软件图形界面设计较为清晰，不需要额外教学，大家可以自行尝试。\n\nVMWare Desktop Hypervisor 系列使用的系统镜像可以从镜像站下载，如[科大镜像站的Ubuntu镜像链接](https://mirrors.ustc.edu.cn/ubuntu-releases/)。我们推荐使用 Ubuntu 22.04 LTS 发行版，从上面的链接进去的话，可以在 `22.04/ubuntu-22.04.4-desktop-amd64.iso` 找到对应的镜像文件。\n\n**WSL 2**\n\nWSL 2是 Microsoft 推出的虚拟机方案，仅支持 Windows 系统，使用体验极佳。对于 Windows 10 2004以上版本或 Windows 11系统，可以参考 [WSL官方文档](https://learn.microsoft.com/zh-cn/windows/wsl/install)安装 WSL 2。该文档中还包含其它一些有用的信息，推荐感兴趣的同学完整浏览，特别是跨系统文件访问和跨系统网络访问。（当然，完整浏览不是实验必要的）\n\n> 如果直接 wsl --install 失败，请参考文档中提供的手动安装步骤和常见问题。仍有疑问欢迎联系 GPT 和助教。对于 C 盘可用容量堪忧的同学，可以参考[这篇知乎文章](https://zhuanlan.zhihu.com/p/621873601)来把 WSL 迁移到别的盘。\n> 注：用户名不要用大写，不要用中文！（经热心同学踩坑后加上）\n\n> WSL 已默认使用 WSL2，其与 WSl1之间的差异见[官方文档](https://learn.microsoft.com/zh-cn/windows/wsl/compare-versions)。\n\n**Mac 等特殊情况**\n\n部分实验基于 AMD64（又名 x86-64）架构设计。**如有使用 Mac M 系列芯片，或其它非 AMD64 指令集 CPU（如 RISC-V——~~不会真有人用吧~~）的同学，建议联系助教为你安排服务器进行实验，也可尝试 UTM 或 QEMU，但性能可能略低。**\n\n**Linux 命令行**\n\n对于默认没有图形界面的 WSL 2，虽然你可以自行寻找教程安装合适的图形界面应用，但我们还是推荐你以使用命令行交互为主，这是因为命令行在后续实验中是必须掌握的基础技能。命令行的基本用法可以参考 [MIT Missing Semester](https://missing-semester-cn.github.io/) 上的第一、二节入门 Linux 命令行使用。\n\n一般来说，各种命令都可以通过在后面加上 `--help` 的方式输出用法，如运行 `ls --help` 可输出 `ls` 命令的用法。\n如果你需要更加详细的说明，可以通过 `man` 查询命令对应的文档，如 `man tar`，也可以在 [GNU网站](https://www.gnu.org/software/software.html)上找到相关软件的具体说明。\n另外推荐一个命令常用用法速查的命令行工具 `tldr` ，这是 [GITHUB仓库地址](https://github.com/tldr-pages/tldr)，可以自行安装。（看不懂怎么安装的话 `pip3 install tldr` 即可）\n\n下面随便列出一些基本命令和操作：\n\n* cd ls mv rm cp cat echo mkdir rmdir sudo pwd\n* 输出重定向（>） 输入重定向（<） 管道（|） 结束程序（Ctrl+C） 自动补全（Tab）\n* chgrp chmod chown jobs kill fg bg ln top grep find export\n* 后台运行（&） 暂停程序（Ctrl+Z） 引用 job（%） EOF（Ctrl+D） 临时环境变量（=）\n\n## II. 包管理器\n\n> 以 Ubuntu 系统的 apt 包管理器为例，其它发行版可以自行查找有关资料。\n\n包管理器全称是软件包管理器，顾名思义是用来管理软件包的软件。在大家熟悉的 Windows 系统中，通常下载软件就是去软件的官网上下载。而在 Linux 系统中，最常见的安装软件的方式是使用软件包管理器从“软件仓库”中下载。包管理器会负责一个软件的全生命周期，包括下载、安装、依赖关系、卸载、更新等等。\n\nUbuntu 发行版中带有 apt 和 dpkg 包管理器，我们一般使用 apt，基本用法可以参考 [Ubuntu包管理器文档](https://ubuntu.com/server/docs/package-management)中的 apt 一节。完整的官方文档可以运行 man apt 查阅。（使用前请先看下一节进行换源！）\n\n在后续课程中，如果遇到命令行提示说 `xxx not found`，可以尝试使用 apt 安装相应的软件包，如 `sudo apt install xxx`。\n\n>  注意：使用 apt 时一般都需要在前面加上 sudo。\n\n你也可以自行安装 aptitude 包管理器，官方文档中也有对其的介绍。该管理器用法与 apt 类似，且提供了图形化界面。\n\n### 换源（非常重要）\n\napt 默认的软件源服务器在国外，可能被 the Great Fire Wall 直接拦下。建议将其更换为科大镜像（P.S. CSLG 正在紧锣密鼓地搭建复旦自己的镜像站中，大家可能这学期就用得上），Ubuntu 的更换方法如下：\n\n\n```shell\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\nsudo sed -i 's@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g' /etc/apt/sources.list\nsudo apt update\n```\n\n其中第一行是将原来的文件进行备份，这只是一个好习惯而已。\n上面几行的详细说明可以参考[这个链接](https://mirrors.ustc.edu.cn/help/ubuntu.html)，如果你使用其他发行版，也可以去这个链接中寻找相关说明。\n\n> 如需要在命令行下使用代理，可以使用环境变量，或者可以了解一下 proxychains 这个工具。\n\n## III. 常用软件\n\n### Vim\n\nVim 的基本用法为运行 `vim something.txt` 打开文件，然后按 `i` 键编辑文件，此时可以直接打字，完成后按 `ESC` 键，输入 `:wq` 保存并退出，或输入 `:q!` 不保存直接退出。\n\n由于 Vim 有一些学习难度，大家当然可以直接选择开箱即用的 VS Code（说明见下一节），但是如果你习惯了 Vim 的操作，用起来就非常爽快。\n\nVim 的用法非常丰富，如有兴趣可以通过 Vim 自带的教程程序 `vimtutor` 学习（在安装 vim 之后直接在命令行输入这个即可），也可以通过 [Vim学习网站](https://vim-adventures.com/)学习，或者参考[这个保姆级入门视频](https://www.bilibili.com/video/BV13t4y1t7Wg)。\n\n> Copilot 官方提供了一个 [Vim 插件](https://github.com/github/copilot.vim)，可以让你在 Vim 中使用 Copilot。\n\n### VS Code\n\n如果你使用的是 VMWare，可以将 VS Code 安装在虚拟机里，也可以通过本机上的 VSCode SSH 连接到虚拟机中进行开发。\n如果你使用的是 WSL 2，直接将 VSCode 装在本机上即可[使用本机上的VS Code编辑和运行虚拟机中的代码](https://code.visualstudio.com/docs/remote/wsl)。\n\n> WSL2 常用用法：\n> `code some.txt` 即可用 Windows 上的 VSCode 打开文件。\n> `code .` 即可用 Windows 上的 VSCode 打开当前文件夹。\n\nVS Code 会提示你安装常用插件，大家也可以自行在网上寻找好用的插件。关于 VS Code 安装与配置的问题，可参考 [VS Code官方文档](https://code.visualstudio.com/docs)。\n\n### Git\n\nGit 的常用操作可以通过 [Git学习网站](https://learngitbranching.js.org/?locale=zh_CN)学习，也可参考[视频](https://www.bilibili.com/video/BV1r3411F7kn)。完整的官方文档可以运行 man git 查阅。使用 VS Code 的同学有福了，git 插件提供了非常好用的图形化界面。\n\n此外，要将代码库上传到云端，你可能需要注册一个 [GitHub](www.github.com) 或其它类似网站的账号~~，或许你可以注册一个账号给我们的课程网站仓库一个 star~~。一套完整使用 git 的工作流程是：[十分钟学会正确的github工作流，和开源作者们使用同一套流程 - 码农高天](https://www.bilibili.com/video/BV19e4y1q7JJ)，大家之后在本课程和其他课程的组队任务可以试试这套流程。\n\n### SSH\n\n在 ICS 课程中没有直接使用 SSH 连接服务器的内容，但你可能需要[在Git中使用SSH](https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/)。SSH 的完整文档可以通过 man ssh 查阅。\n\n如果你从未使用过 SSH，你可能需要为自己创建一个密钥对，参考指令：`ssh-keygen -t ed25519 -C \"your_email@example.com\"`。密钥对的默认保存位置为 `~/.ssh/`，其中的 `id_rsa` 为私钥，`id_rsa.pub` 为公钥。如果你好奇密钥是如何工作的，可以参考[这篇文章](https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)。\n\n","source":"_posts/ICS实验入门手册.md","raw":"# ICS 实验入门手册 2024\n\n## I. Linux 系统\n\n本学期的实验需要使用 Linux 系统。如果你的电脑不是 Linux 系统，则需要使用虚拟机安装 Linux 系统。\n\n手册中介绍 VMWare Workstation Pro 和 WSL 2 两种虚拟机方案。 **建议 Windows 系统的同学选择 WSL 2。**\n\n**VMWare Desktop Hypervisor**\n\nVMWare 在 Windows/MacOS 系统上的虚拟化软件 Workstation Pro 以及 Fusion Pro 于2024年5月13日起供个人免费使用，可在[官方网站](https://www.vmware.com/products/desktop-hypervisor/workstation-and-fusion)下载。这两个虚拟化软件图形界面设计较为清晰，不需要额外教学，大家可以自行尝试。\n\nVMWare Desktop Hypervisor 系列使用的系统镜像可以从镜像站下载，如[科大镜像站的Ubuntu镜像链接](https://mirrors.ustc.edu.cn/ubuntu-releases/)。我们推荐使用 Ubuntu 22.04 LTS 发行版，从上面的链接进去的话，可以在 `22.04/ubuntu-22.04.4-desktop-amd64.iso` 找到对应的镜像文件。\n\n**WSL 2**\n\nWSL 2是 Microsoft 推出的虚拟机方案，仅支持 Windows 系统，使用体验极佳。对于 Windows 10 2004以上版本或 Windows 11系统，可以参考 [WSL官方文档](https://learn.microsoft.com/zh-cn/windows/wsl/install)安装 WSL 2。该文档中还包含其它一些有用的信息，推荐感兴趣的同学完整浏览，特别是跨系统文件访问和跨系统网络访问。（当然，完整浏览不是实验必要的）\n\n> 如果直接 wsl --install 失败，请参考文档中提供的手动安装步骤和常见问题。仍有疑问欢迎联系 GPT 和助教。对于 C 盘可用容量堪忧的同学，可以参考[这篇知乎文章](https://zhuanlan.zhihu.com/p/621873601)来把 WSL 迁移到别的盘。\n> 注：用户名不要用大写，不要用中文！（经热心同学踩坑后加上）\n\n> WSL 已默认使用 WSL2，其与 WSl1之间的差异见[官方文档](https://learn.microsoft.com/zh-cn/windows/wsl/compare-versions)。\n\n**Mac 等特殊情况**\n\n部分实验基于 AMD64（又名 x86-64）架构设计。**如有使用 Mac M 系列芯片，或其它非 AMD64 指令集 CPU（如 RISC-V——~~不会真有人用吧~~）的同学，建议联系助教为你安排服务器进行实验，也可尝试 UTM 或 QEMU，但性能可能略低。**\n\n**Linux 命令行**\n\n对于默认没有图形界面的 WSL 2，虽然你可以自行寻找教程安装合适的图形界面应用，但我们还是推荐你以使用命令行交互为主，这是因为命令行在后续实验中是必须掌握的基础技能。命令行的基本用法可以参考 [MIT Missing Semester](https://missing-semester-cn.github.io/) 上的第一、二节入门 Linux 命令行使用。\n\n一般来说，各种命令都可以通过在后面加上 `--help` 的方式输出用法，如运行 `ls --help` 可输出 `ls` 命令的用法。\n如果你需要更加详细的说明，可以通过 `man` 查询命令对应的文档，如 `man tar`，也可以在 [GNU网站](https://www.gnu.org/software/software.html)上找到相关软件的具体说明。\n另外推荐一个命令常用用法速查的命令行工具 `tldr` ，这是 [GITHUB仓库地址](https://github.com/tldr-pages/tldr)，可以自行安装。（看不懂怎么安装的话 `pip3 install tldr` 即可）\n\n下面随便列出一些基本命令和操作：\n\n* cd ls mv rm cp cat echo mkdir rmdir sudo pwd\n* 输出重定向（>） 输入重定向（<） 管道（|） 结束程序（Ctrl+C） 自动补全（Tab）\n* chgrp chmod chown jobs kill fg bg ln top grep find export\n* 后台运行（&） 暂停程序（Ctrl+Z） 引用 job（%） EOF（Ctrl+D） 临时环境变量（=）\n\n## II. 包管理器\n\n> 以 Ubuntu 系统的 apt 包管理器为例，其它发行版可以自行查找有关资料。\n\n包管理器全称是软件包管理器，顾名思义是用来管理软件包的软件。在大家熟悉的 Windows 系统中，通常下载软件就是去软件的官网上下载。而在 Linux 系统中，最常见的安装软件的方式是使用软件包管理器从“软件仓库”中下载。包管理器会负责一个软件的全生命周期，包括下载、安装、依赖关系、卸载、更新等等。\n\nUbuntu 发行版中带有 apt 和 dpkg 包管理器，我们一般使用 apt，基本用法可以参考 [Ubuntu包管理器文档](https://ubuntu.com/server/docs/package-management)中的 apt 一节。完整的官方文档可以运行 man apt 查阅。（使用前请先看下一节进行换源！）\n\n在后续课程中，如果遇到命令行提示说 `xxx not found`，可以尝试使用 apt 安装相应的软件包，如 `sudo apt install xxx`。\n\n>  注意：使用 apt 时一般都需要在前面加上 sudo。\n\n你也可以自行安装 aptitude 包管理器，官方文档中也有对其的介绍。该管理器用法与 apt 类似，且提供了图形化界面。\n\n### 换源（非常重要）\n\napt 默认的软件源服务器在国外，可能被 the Great Fire Wall 直接拦下。建议将其更换为科大镜像（P.S. CSLG 正在紧锣密鼓地搭建复旦自己的镜像站中，大家可能这学期就用得上），Ubuntu 的更换方法如下：\n\n\n```shell\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\nsudo sed -i 's@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g' /etc/apt/sources.list\nsudo apt update\n```\n\n其中第一行是将原来的文件进行备份，这只是一个好习惯而已。\n上面几行的详细说明可以参考[这个链接](https://mirrors.ustc.edu.cn/help/ubuntu.html)，如果你使用其他发行版，也可以去这个链接中寻找相关说明。\n\n> 如需要在命令行下使用代理，可以使用环境变量，或者可以了解一下 proxychains 这个工具。\n\n## III. 常用软件\n\n### Vim\n\nVim 的基本用法为运行 `vim something.txt` 打开文件，然后按 `i` 键编辑文件，此时可以直接打字，完成后按 `ESC` 键，输入 `:wq` 保存并退出，或输入 `:q!` 不保存直接退出。\n\n由于 Vim 有一些学习难度，大家当然可以直接选择开箱即用的 VS Code（说明见下一节），但是如果你习惯了 Vim 的操作，用起来就非常爽快。\n\nVim 的用法非常丰富，如有兴趣可以通过 Vim 自带的教程程序 `vimtutor` 学习（在安装 vim 之后直接在命令行输入这个即可），也可以通过 [Vim学习网站](https://vim-adventures.com/)学习，或者参考[这个保姆级入门视频](https://www.bilibili.com/video/BV13t4y1t7Wg)。\n\n> Copilot 官方提供了一个 [Vim 插件](https://github.com/github/copilot.vim)，可以让你在 Vim 中使用 Copilot。\n\n### VS Code\n\n如果你使用的是 VMWare，可以将 VS Code 安装在虚拟机里，也可以通过本机上的 VSCode SSH 连接到虚拟机中进行开发。\n如果你使用的是 WSL 2，直接将 VSCode 装在本机上即可[使用本机上的VS Code编辑和运行虚拟机中的代码](https://code.visualstudio.com/docs/remote/wsl)。\n\n> WSL2 常用用法：\n> `code some.txt` 即可用 Windows 上的 VSCode 打开文件。\n> `code .` 即可用 Windows 上的 VSCode 打开当前文件夹。\n\nVS Code 会提示你安装常用插件，大家也可以自行在网上寻找好用的插件。关于 VS Code 安装与配置的问题，可参考 [VS Code官方文档](https://code.visualstudio.com/docs)。\n\n### Git\n\nGit 的常用操作可以通过 [Git学习网站](https://learngitbranching.js.org/?locale=zh_CN)学习，也可参考[视频](https://www.bilibili.com/video/BV1r3411F7kn)。完整的官方文档可以运行 man git 查阅。使用 VS Code 的同学有福了，git 插件提供了非常好用的图形化界面。\n\n此外，要将代码库上传到云端，你可能需要注册一个 [GitHub](www.github.com) 或其它类似网站的账号~~，或许你可以注册一个账号给我们的课程网站仓库一个 star~~。一套完整使用 git 的工作流程是：[十分钟学会正确的github工作流，和开源作者们使用同一套流程 - 码农高天](https://www.bilibili.com/video/BV19e4y1q7JJ)，大家之后在本课程和其他课程的组队任务可以试试这套流程。\n\n### SSH\n\n在 ICS 课程中没有直接使用 SSH 连接服务器的内容，但你可能需要[在Git中使用SSH](https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/)。SSH 的完整文档可以通过 man ssh 查阅。\n\n如果你从未使用过 SSH，你可能需要为自己创建一个密钥对，参考指令：`ssh-keygen -t ed25519 -C \"your_email@example.com\"`。密钥对的默认保存位置为 `~/.ssh/`，其中的 `id_rsa` 为私钥，`id_rsa.pub` 为公钥。如果你好奇密钥是如何工作的，可以参考[这篇文章](https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)。\n\n","slug":"ICS实验入门手册","published":1,"date":"2024-09-25T13:47:12.351Z","updated":"2024-09-25T13:47:12.352Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2yhehkm0005rzx44aue9ho4","content":"<h1 id=\"ics-实验入门手册-2024\">ICS 实验入门手册 2024</h1>\n<h2 id=\"i.-linux-系统\">I. Linux 系统</h2>\n<p>本学期的实验需要使用 Linux 系统。如果你的电脑不是 Linux\n系统，则需要使用虚拟机安装 Linux 系统。</p>\n<p>手册中介绍 VMWare Workstation Pro 和 WSL 2 两种虚拟机方案。\n<strong>建议 Windows 系统的同学选择 WSL 2。</strong></p>\n<p><strong>VMWare Desktop Hypervisor</strong></p>\n<p>VMWare 在 Windows/MacOS 系统上的虚拟化软件 Workstation Pro 以及\nFusion Pro 于2024年5月13日起供个人免费使用，可在<a\nhref=\"https://www.vmware.com/products/desktop-hypervisor/workstation-and-fusion\">官方网站</a>下载。这两个虚拟化软件图形界面设计较为清晰，不需要额外教学，大家可以自行尝试。</p>\n<p>VMWare Desktop Hypervisor 系列使用的系统镜像可以从镜像站下载，如<a\nhref=\"https://mirrors.ustc.edu.cn/ubuntu-releases/\">科大镜像站的Ubuntu镜像链接</a>。我们推荐使用\nUbuntu 22.04 LTS 发行版，从上面的链接进去的话，可以在\n<code>22.04/ubuntu-22.04.4-desktop-amd64.iso</code>\n找到对应的镜像文件。</p>\n<p><strong>WSL 2</strong></p>\n<p>WSL 2是 Microsoft 推出的虚拟机方案，仅支持 Windows\n系统，使用体验极佳。对于 Windows 10 2004以上版本或 Windows\n11系统，可以参考 <a\nhref=\"https://learn.microsoft.com/zh-cn/windows/wsl/install\">WSL官方文档</a>安装\nWSL\n2。该文档中还包含其它一些有用的信息，推荐感兴趣的同学完整浏览，特别是跨系统文件访问和跨系统网络访问。（当然，完整浏览不是实验必要的）</p>\n<blockquote>\n<p>如果直接 wsl --install\n失败，请参考文档中提供的手动安装步骤和常见问题。仍有疑问欢迎联系 GPT\n和助教。对于 C 盘可用容量堪忧的同学，可以参考<a\nhref=\"https://zhuanlan.zhihu.com/p/621873601\">这篇知乎文章</a>来把 WSL\n迁移到别的盘。\n注：用户名不要用大写，不要用中文！（经热心同学踩坑后加上）</p>\n</blockquote>\n<blockquote>\n<p>WSL 已默认使用 WSL2，其与 WSl1之间的差异见<a\nhref=\"https://learn.microsoft.com/zh-cn/windows/wsl/compare-versions\">官方文档</a>。</p>\n</blockquote>\n<p><strong>Mac 等特殊情况</strong></p>\n<p>部分实验基于 AMD64（又名 x86-64）架构设计。<strong>如有使用 Mac M\n系列芯片，或其它非 AMD64 指令集 CPU（如\nRISC-V——<del>不会真有人用吧</del>）的同学，建议联系助教为你安排服务器进行实验，也可尝试\nUTM 或 QEMU，但性能可能略低。</strong></p>\n<p><strong>Linux 命令行</strong></p>\n<p>对于默认没有图形界面的 WSL\n2，虽然你可以自行寻找教程安装合适的图形界面应用，但我们还是推荐你以使用命令行交互为主，这是因为命令行在后续实验中是必须掌握的基础技能。命令行的基本用法可以参考\n<a href=\"https://missing-semester-cn.github.io/\">MIT Missing\nSemester</a> 上的第一、二节入门 Linux 命令行使用。</p>\n<p>一般来说，各种命令都可以通过在后面加上 <code>--help</code>\n的方式输出用法，如运行 <code>ls --help</code> 可输出 <code>ls</code>\n命令的用法。 如果你需要更加详细的说明，可以通过 <code>man</code>\n查询命令对应的文档，如 <code>man tar</code>，也可以在 <a\nhref=\"https://www.gnu.org/software/software.html\">GNU网站</a>上找到相关软件的具体说明。\n另外推荐一个命令常用用法速查的命令行工具 <code>tldr</code> ，这是 <a\nhref=\"https://github.com/tldr-pages/tldr\">GITHUB仓库地址</a>，可以自行安装。（看不懂怎么安装的话\n<code>pip3 install tldr</code> 即可）</p>\n<p>下面随便列出一些基本命令和操作：</p>\n<ul>\n<li>cd ls mv rm cp cat echo mkdir rmdir sudo pwd</li>\n<li>输出重定向（&gt;） 输入重定向（&lt;） 管道（|） 结束程序（Ctrl+C）\n自动补全（Tab）</li>\n<li>chgrp chmod chown jobs kill fg bg ln top grep find export</li>\n<li>后台运行（&amp;） 暂停程序（Ctrl+Z） 引用 job（%） EOF（Ctrl+D）\n临时环境变量（=）</li>\n</ul>\n<h2 id=\"ii.-包管理器\">II. 包管理器</h2>\n<blockquote>\n<p>以 Ubuntu 系统的 apt\n包管理器为例，其它发行版可以自行查找有关资料。</p>\n</blockquote>\n<p>包管理器全称是软件包管理器，顾名思义是用来管理软件包的软件。在大家熟悉的\nWindows 系统中，通常下载软件就是去软件的官网上下载。而在 Linux\n系统中，最常见的安装软件的方式是使用软件包管理器从“软件仓库”中下载。包管理器会负责一个软件的全生命周期，包括下载、安装、依赖关系、卸载、更新等等。</p>\n<p>Ubuntu 发行版中带有 apt 和 dpkg 包管理器，我们一般使用\napt，基本用法可以参考 <a\nhref=\"https://ubuntu.com/server/docs/package-management\">Ubuntu包管理器文档</a>中的\napt 一节。完整的官方文档可以运行 man apt\n查阅。（使用前请先看下一节进行换源！）</p>\n<p>在后续课程中，如果遇到命令行提示说\n<code>xxx not found</code>，可以尝试使用 apt 安装相应的软件包，如\n<code>sudo apt install xxx</code>。</p>\n<blockquote>\n<p>注意：使用 apt 时一般都需要在前面加上 sudo。</p>\n</blockquote>\n<p>你也可以自行安装 aptitude\n包管理器，官方文档中也有对其的介绍。该管理器用法与 apt\n类似，且提供了图形化界面。</p>\n<h3 id=\"换源非常重要\">换源（非常重要）</h3>\n<p>apt 默认的软件源服务器在国外，可能被 the Great Fire Wall\n直接拦下。建议将其更换为科大镜像（P.S. CSLG\n正在紧锣密鼓地搭建复旦自己的镜像站中，大家可能这学期就用得上），Ubuntu\n的更换方法如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class=\"line\">sudo sed -i &#x27;s@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g&#x27; /etc/apt/sources.list</span><br><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n<p>其中第一行是将原来的文件进行备份，这只是一个好习惯而已。\n上面几行的详细说明可以参考<a\nhref=\"https://mirrors.ustc.edu.cn/help/ubuntu.html\">这个链接</a>，如果你使用其他发行版，也可以去这个链接中寻找相关说明。</p>\n<blockquote>\n<p>如需要在命令行下使用代理，可以使用环境变量，或者可以了解一下\nproxychains 这个工具。</p>\n</blockquote>\n<h2 id=\"iii.-常用软件\">III. 常用软件</h2>\n<h3 id=\"vim\">Vim</h3>\n<p>Vim 的基本用法为运行 <code>vim something.txt</code> 打开文件，然后按\n<code>i</code> 键编辑文件，此时可以直接打字，完成后按 <code>ESC</code>\n键，输入 <code>:wq</code> 保存并退出，或输入 <code>:q!</code>\n不保存直接退出。</p>\n<p>由于 Vim 有一些学习难度，大家当然可以直接选择开箱即用的 VS\nCode（说明见下一节），但是如果你习惯了 Vim\n的操作，用起来就非常爽快。</p>\n<p>Vim 的用法非常丰富，如有兴趣可以通过 Vim 自带的教程程序\n<code>vimtutor</code> 学习（在安装 vim\n之后直接在命令行输入这个即可），也可以通过 <a\nhref=\"https://vim-adventures.com/\">Vim学习网站</a>学习，或者参考<a\nhref=\"https://www.bilibili.com/video/BV13t4y1t7Wg\">这个保姆级入门视频</a>。</p>\n<blockquote>\n<p>Copilot 官方提供了一个 <a\nhref=\"https://github.com/github/copilot.vim\">Vim 插件</a>，可以让你在\nVim 中使用 Copilot。</p>\n</blockquote>\n<h3 id=\"vs-code\">VS Code</h3>\n<p>如果你使用的是 VMWare，可以将 VS Code\n安装在虚拟机里，也可以通过本机上的 VSCode SSH 连接到虚拟机中进行开发。\n如果你使用的是 WSL 2，直接将 VSCode 装在本机上即可<a\nhref=\"https://code.visualstudio.com/docs/remote/wsl\">使用本机上的VS\nCode编辑和运行虚拟机中的代码</a>。</p>\n<blockquote>\n<p>WSL2 常用用法： <code>code some.txt</code> 即可用 Windows 上的 VSCode\n打开文件。 <code>code .</code> 即可用 Windows 上的 VSCode\n打开当前文件夹。</p>\n</blockquote>\n<p>VS Code\n会提示你安装常用插件，大家也可以自行在网上寻找好用的插件。关于 VS Code\n安装与配置的问题，可参考 <a href=\"https://code.visualstudio.com/docs\">VS\nCode官方文档</a>。</p>\n<h3 id=\"git\">Git</h3>\n<p>Git 的常用操作可以通过 <a\nhref=\"https://learngitbranching.js.org/?locale=zh_CN\">Git学习网站</a>学习，也可参考<a\nhref=\"https://www.bilibili.com/video/BV1r3411F7kn\">视频</a>。完整的官方文档可以运行\nman git 查阅。使用 VS Code 的同学有福了，git\n插件提供了非常好用的图形化界面。</p>\n<p>此外，要将代码库上传到云端，你可能需要注册一个 <a\nhref=\"www.github.com\">GitHub</a>\n或其它类似网站的账号<del>，或许你可以注册一个账号给我们的课程网站仓库一个\nstar</del>。一套完整使用 git 的工作流程是：<a\nhref=\"https://www.bilibili.com/video/BV19e4y1q7JJ\">十分钟学会正确的github工作流，和开源作者们使用同一套流程\n-\n码农高天</a>，大家之后在本课程和其他课程的组队任务可以试试这套流程。</p>\n<h3 id=\"ssh\">SSH</h3>\n<p>在 ICS 课程中没有直接使用 SSH 连接服务器的内容，但你可能需要<a\nhref=\"https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/\">在Git中使用SSH</a>。SSH\n的完整文档可以通过 man ssh 查阅。</p>\n<p>如果你从未使用过\nSSH，你可能需要为自己创建一个密钥对，参考指令：<code>ssh-keygen -t ed25519 -C \"your_email@example.com\"</code>。密钥对的默认保存位置为\n<code>~/.ssh/</code>，其中的 <code>id_rsa</code>\n为私钥，<code>id_rsa.pub</code>\n为公钥。如果你好奇密钥是如何工作的，可以参考<a\nhref=\"https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\">这篇文章</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ics-实验入门手册-2024\">ICS 实验入门手册 2024</h1>\n<h2 id=\"i.-linux-系统\">I. Linux 系统</h2>\n<p>本学期的实验需要使用 Linux 系统。如果你的电脑不是 Linux\n系统，则需要使用虚拟机安装 Linux 系统。</p>\n<p>手册中介绍 VMWare Workstation Pro 和 WSL 2 两种虚拟机方案。\n<strong>建议 Windows 系统的同学选择 WSL 2。</strong></p>\n<p><strong>VMWare Desktop Hypervisor</strong></p>\n<p>VMWare 在 Windows/MacOS 系统上的虚拟化软件 Workstation Pro 以及\nFusion Pro 于2024年5月13日起供个人免费使用，可在<a\nhref=\"https://www.vmware.com/products/desktop-hypervisor/workstation-and-fusion\">官方网站</a>下载。这两个虚拟化软件图形界面设计较为清晰，不需要额外教学，大家可以自行尝试。</p>\n<p>VMWare Desktop Hypervisor 系列使用的系统镜像可以从镜像站下载，如<a\nhref=\"https://mirrors.ustc.edu.cn/ubuntu-releases/\">科大镜像站的Ubuntu镜像链接</a>。我们推荐使用\nUbuntu 22.04 LTS 发行版，从上面的链接进去的话，可以在\n<code>22.04/ubuntu-22.04.4-desktop-amd64.iso</code>\n找到对应的镜像文件。</p>\n<p><strong>WSL 2</strong></p>\n<p>WSL 2是 Microsoft 推出的虚拟机方案，仅支持 Windows\n系统，使用体验极佳。对于 Windows 10 2004以上版本或 Windows\n11系统，可以参考 <a\nhref=\"https://learn.microsoft.com/zh-cn/windows/wsl/install\">WSL官方文档</a>安装\nWSL\n2。该文档中还包含其它一些有用的信息，推荐感兴趣的同学完整浏览，特别是跨系统文件访问和跨系统网络访问。（当然，完整浏览不是实验必要的）</p>\n<blockquote>\n<p>如果直接 wsl --install\n失败，请参考文档中提供的手动安装步骤和常见问题。仍有疑问欢迎联系 GPT\n和助教。对于 C 盘可用容量堪忧的同学，可以参考<a\nhref=\"https://zhuanlan.zhihu.com/p/621873601\">这篇知乎文章</a>来把 WSL\n迁移到别的盘。\n注：用户名不要用大写，不要用中文！（经热心同学踩坑后加上）</p>\n</blockquote>\n<blockquote>\n<p>WSL 已默认使用 WSL2，其与 WSl1之间的差异见<a\nhref=\"https://learn.microsoft.com/zh-cn/windows/wsl/compare-versions\">官方文档</a>。</p>\n</blockquote>\n<p><strong>Mac 等特殊情况</strong></p>\n<p>部分实验基于 AMD64（又名 x86-64）架构设计。<strong>如有使用 Mac M\n系列芯片，或其它非 AMD64 指令集 CPU（如\nRISC-V——<del>不会真有人用吧</del>）的同学，建议联系助教为你安排服务器进行实验，也可尝试\nUTM 或 QEMU，但性能可能略低。</strong></p>\n<p><strong>Linux 命令行</strong></p>\n<p>对于默认没有图形界面的 WSL\n2，虽然你可以自行寻找教程安装合适的图形界面应用，但我们还是推荐你以使用命令行交互为主，这是因为命令行在后续实验中是必须掌握的基础技能。命令行的基本用法可以参考\n<a href=\"https://missing-semester-cn.github.io/\">MIT Missing\nSemester</a> 上的第一、二节入门 Linux 命令行使用。</p>\n<p>一般来说，各种命令都可以通过在后面加上 <code>--help</code>\n的方式输出用法，如运行 <code>ls --help</code> 可输出 <code>ls</code>\n命令的用法。 如果你需要更加详细的说明，可以通过 <code>man</code>\n查询命令对应的文档，如 <code>man tar</code>，也可以在 <a\nhref=\"https://www.gnu.org/software/software.html\">GNU网站</a>上找到相关软件的具体说明。\n另外推荐一个命令常用用法速查的命令行工具 <code>tldr</code> ，这是 <a\nhref=\"https://github.com/tldr-pages/tldr\">GITHUB仓库地址</a>，可以自行安装。（看不懂怎么安装的话\n<code>pip3 install tldr</code> 即可）</p>\n<p>下面随便列出一些基本命令和操作：</p>\n<ul>\n<li>cd ls mv rm cp cat echo mkdir rmdir sudo pwd</li>\n<li>输出重定向（&gt;） 输入重定向（&lt;） 管道（|） 结束程序（Ctrl+C）\n自动补全（Tab）</li>\n<li>chgrp chmod chown jobs kill fg bg ln top grep find export</li>\n<li>后台运行（&amp;） 暂停程序（Ctrl+Z） 引用 job（%） EOF（Ctrl+D）\n临时环境变量（=）</li>\n</ul>\n<h2 id=\"ii.-包管理器\">II. 包管理器</h2>\n<blockquote>\n<p>以 Ubuntu 系统的 apt\n包管理器为例，其它发行版可以自行查找有关资料。</p>\n</blockquote>\n<p>包管理器全称是软件包管理器，顾名思义是用来管理软件包的软件。在大家熟悉的\nWindows 系统中，通常下载软件就是去软件的官网上下载。而在 Linux\n系统中，最常见的安装软件的方式是使用软件包管理器从“软件仓库”中下载。包管理器会负责一个软件的全生命周期，包括下载、安装、依赖关系、卸载、更新等等。</p>\n<p>Ubuntu 发行版中带有 apt 和 dpkg 包管理器，我们一般使用\napt，基本用法可以参考 <a\nhref=\"https://ubuntu.com/server/docs/package-management\">Ubuntu包管理器文档</a>中的\napt 一节。完整的官方文档可以运行 man apt\n查阅。（使用前请先看下一节进行换源！）</p>\n<p>在后续课程中，如果遇到命令行提示说\n<code>xxx not found</code>，可以尝试使用 apt 安装相应的软件包，如\n<code>sudo apt install xxx</code>。</p>\n<blockquote>\n<p>注意：使用 apt 时一般都需要在前面加上 sudo。</p>\n</blockquote>\n<p>你也可以自行安装 aptitude\n包管理器，官方文档中也有对其的介绍。该管理器用法与 apt\n类似，且提供了图形化界面。</p>\n<h3 id=\"换源非常重要\">换源（非常重要）</h3>\n<p>apt 默认的软件源服务器在国外，可能被 the Great Fire Wall\n直接拦下。建议将其更换为科大镜像（P.S. CSLG\n正在紧锣密鼓地搭建复旦自己的镜像站中，大家可能这学期就用得上），Ubuntu\n的更换方法如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class=\"line\">sudo sed -i &#x27;s@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g&#x27; /etc/apt/sources.list</span><br><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n<p>其中第一行是将原来的文件进行备份，这只是一个好习惯而已。\n上面几行的详细说明可以参考<a\nhref=\"https://mirrors.ustc.edu.cn/help/ubuntu.html\">这个链接</a>，如果你使用其他发行版，也可以去这个链接中寻找相关说明。</p>\n<blockquote>\n<p>如需要在命令行下使用代理，可以使用环境变量，或者可以了解一下\nproxychains 这个工具。</p>\n</blockquote>\n<h2 id=\"iii.-常用软件\">III. 常用软件</h2>\n<h3 id=\"vim\">Vim</h3>\n<p>Vim 的基本用法为运行 <code>vim something.txt</code> 打开文件，然后按\n<code>i</code> 键编辑文件，此时可以直接打字，完成后按 <code>ESC</code>\n键，输入 <code>:wq</code> 保存并退出，或输入 <code>:q!</code>\n不保存直接退出。</p>\n<p>由于 Vim 有一些学习难度，大家当然可以直接选择开箱即用的 VS\nCode（说明见下一节），但是如果你习惯了 Vim\n的操作，用起来就非常爽快。</p>\n<p>Vim 的用法非常丰富，如有兴趣可以通过 Vim 自带的教程程序\n<code>vimtutor</code> 学习（在安装 vim\n之后直接在命令行输入这个即可），也可以通过 <a\nhref=\"https://vim-adventures.com/\">Vim学习网站</a>学习，或者参考<a\nhref=\"https://www.bilibili.com/video/BV13t4y1t7Wg\">这个保姆级入门视频</a>。</p>\n<blockquote>\n<p>Copilot 官方提供了一个 <a\nhref=\"https://github.com/github/copilot.vim\">Vim 插件</a>，可以让你在\nVim 中使用 Copilot。</p>\n</blockquote>\n<h3 id=\"vs-code\">VS Code</h3>\n<p>如果你使用的是 VMWare，可以将 VS Code\n安装在虚拟机里，也可以通过本机上的 VSCode SSH 连接到虚拟机中进行开发。\n如果你使用的是 WSL 2，直接将 VSCode 装在本机上即可<a\nhref=\"https://code.visualstudio.com/docs/remote/wsl\">使用本机上的VS\nCode编辑和运行虚拟机中的代码</a>。</p>\n<blockquote>\n<p>WSL2 常用用法： <code>code some.txt</code> 即可用 Windows 上的 VSCode\n打开文件。 <code>code .</code> 即可用 Windows 上的 VSCode\n打开当前文件夹。</p>\n</blockquote>\n<p>VS Code\n会提示你安装常用插件，大家也可以自行在网上寻找好用的插件。关于 VS Code\n安装与配置的问题，可参考 <a href=\"https://code.visualstudio.com/docs\">VS\nCode官方文档</a>。</p>\n<h3 id=\"git\">Git</h3>\n<p>Git 的常用操作可以通过 <a\nhref=\"https://learngitbranching.js.org/?locale=zh_CN\">Git学习网站</a>学习，也可参考<a\nhref=\"https://www.bilibili.com/video/BV1r3411F7kn\">视频</a>。完整的官方文档可以运行\nman git 查阅。使用 VS Code 的同学有福了，git\n插件提供了非常好用的图形化界面。</p>\n<p>此外，要将代码库上传到云端，你可能需要注册一个 <a\nhref=\"www.github.com\">GitHub</a>\n或其它类似网站的账号<del>，或许你可以注册一个账号给我们的课程网站仓库一个\nstar</del>。一套完整使用 git 的工作流程是：<a\nhref=\"https://www.bilibili.com/video/BV19e4y1q7JJ\">十分钟学会正确的github工作流，和开源作者们使用同一套流程\n-\n码农高天</a>，大家之后在本课程和其他课程的组队任务可以试试这套流程。</p>\n<h3 id=\"ssh\">SSH</h3>\n<p>在 ICS 课程中没有直接使用 SSH 连接服务器的内容，但你可能需要<a\nhref=\"https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/\">在Git中使用SSH</a>。SSH\n的完整文档可以通过 man ssh 查阅。</p>\n<p>如果你从未使用过\nSSH，你可能需要为自己创建一个密钥对，参考指令：<code>ssh-keygen -t ed25519 -C \"your_email@example.com\"</code>。密钥对的默认保存位置为\n<code>~/.ssh/</code>，其中的 <code>id_rsa</code>\n为私钥，<code>id_rsa.pub</code>\n为公钥。如果你好奇密钥是如何工作的，可以参考<a\nhref=\"https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\">这篇文章</a>。</p>\n"},{"title":"StackLab","author":"王雨晨 杨洋","email":"yuchenwang21@m.fudan.edu.cn yyang21@m.fudan.edu.cn","_content":"\n> Deadline：2024-11-20 23:59:59\n\n## 〇、实验简介\n\n栈帧相关实验。\n\n本学期，我们将金老师ICS第三个Lab回炉重造，添加更多讲解，以加深各位同学对栈帧的理解，并探索一些相关应用，丰富同学们的知识面。\n\n本次Lab由三个部分组成：\n\n- 尝试在含有漏洞的程序中实现**任意代码执行**\n- 学习 Canary 机制，了解栈溢出的防御\n- 尝试使用栈帧完成更多有意思的功能\n\n## 一、危险的计算器\n\n### RCE 攻击\n\n电影中的黑客神通广大，能神不知鬼不觉地“黑”掉各种计算机系统，他们是如何做到的？\n\n首先，我们需要认识一下“黑”掉一个系统到底是指什么，对于黑客来说，有许多种不同的攻击效果（或者说漏洞）：\n\n- RCE (Remote Code Execution)：远程代码执行，即攻击者可以在远程服务器上执行任意代码；\n- DoS (Denial of Service)：拒绝服务，即攻击者可以让服务器无法正常工作；\n- MITM (Man-In-The-Middle)：中间人攻击，即攻击者可以在通信过程中窃取信息；\n- ……\n\n其中，攻击者最为喜闻乐见的就是RCE，因为这意味着他们可以在服务器上执行任意程序代码，做任何自己想做的事。比如，他可以把网站服务器托管的网站的首页改成自己的名字；又比如，他可以在上面运行自己的挖矿程序，借用他人计算机的算力帮自己牟利。\n\n一个最简单的RCE漏洞形如：\n\n```c\nread(0, input, 20);\nsystem(input);\n```\n\n这段代码读取用户输入，并调用了 `system` 函数。`system` 函数的功能是执行一条shell指令，比如 `system(\"ls\")` 就会相当于在命令行上输入 `ls` 以显示当前目录下的文件。\n\n这个程序在本地运行时，显然没什么问题，但如果这个 input 字符串来源于网络，这意味着攻击者可以通过输入恶意指令来执行任意代码。比如，当类似于这段代码的程序运行在一个服务器上时，攻击者只要想办法控制input为 `rm -rf /` 就可以删除服务器上的所有文件。\n\n所以，RCE 通常就是指“在目标机器上执行任意shell指令”。\n\n### 栈溢出漏洞\n\n栈溢出漏洞是一种常见且经典的漏洞，破坏力非常强大——它经常可以使攻击者达成 RCE。\n\n栈溢出漏洞在C语言当中非常常见，主要是因为使用 C 语言时非常容易漏掉对数组边界和 buffer 大小的检查。比如，下面这段代码：\n\n```c\nchar buffer[20];\ngets(buffer);\n```\n\n这段代码使用了 `gets` 函数，它会读取用户输入并存储到 `buffer` 中。然而，`gets` 函数并不会检查用户输入的长度，如果用户输入的长度超过了 `buffer` 的大小，就会导致多余的数据“溢出”到栈上的其他位置，导致其他数据被干扰。这就是栈溢出的定义。\n\n### 从栈溢出漏洞到劫持程序控制流\n\n之所以栈溢出漏洞如此危险，是因为它可以被利用来劫持程序的控制流。我们来回忆一下，栈上有哪些数据？\n\n![](https://organicprogrammer.com/images/stack_contents.png)\n\n注意到，其中有一个重要的数据：返回地址。当函数调用结束时，程序会跳转到这个返回地址继续执行。\n\n如果攻击者栈溢出的数据控制了这个返回地址，他就可以决定程序接下来返回到哪里，从而控制程序的执行流程。\n\n### 在劫持了程序控制流之后\n\n“决定程序接下来执行哪个函数”，这听起来是不是很像我们之前说的RCE？没错，这就是栈溢出漏洞的危险之处：它可以被利用来实现任意代码执行。试想，如果程序中存在一个调用 `system(\"/bin/sh\")` 函数的地方，我们只需要把对应的地址填到栈上返回地址的位置，就可以控制程序去调用 `system(\"/bin/sh\")`，从而获取一个 shell 达成 RCE。\n\n然而，并不是所有的程序都会调用 `system(\"/bin/sh\")` 或是类似的函数，这种情况怎么办呢？我们现在仅仅能够控制程序接下来执行哪个地址的代码，离执行任意的shell指令还有一段距离。\n\n这个时候就需要进行“构造”了，攻击者在利用漏洞时，需要利用好一切可以利用的资源，包括但不限于：当前寄存器中的数据、内存中的机器码和数据等等。\n\n比如，我们知道 `rdi` 寄存器是用来传递第一个参数的寄存器。如果我们劫持程序控制流到 `foo(int a)` 函数，其实就相当于调用了 `foo(<当前rdi值>)`。\n\n又比如，我们不一定要控制程序去返回到某个函数（的起始位置），而可以控制程序返回到某个函数的中间。如果有这样一个函数：\n\n```c\nvoid foo() {\n    if (false) {\n        system(\"/bin/sh\");\n    }\n    return;\n}\n```\n\n看上去这个函数没有任何用，因为它什么都不会干。但其中包含的 `system(\"/bin/sh\")` 片段可以为我们所用：我们可以直接控制程序执行 if 内的代码。\n\n### 实验\n\n在本次试验中，我们给出了一个简单但包含有漏洞的计算器程序，它会读取用户输入的表达式，包上 `echo $(())` 后调用 `system` 函数来计算表达式的结果。\n\n你的任务是：利用栈溢出漏洞，控制程序执行 `./malware` 。这个“恶意程序”会检测自己的父进程调用，如果发现自己由 `bash-calc` 调用，就会输出 `You have successfully detonated the bomb! Congratulations!`，表示你已经成功完成了任务。\n\n#### 实验步骤\n\n1. 阅读 `bash-calc.c` 源代码，理解程序的逻辑，找到漏洞所在函数，计算出溢出所需要的字符数；\n2. 使用 `gdb` 调试程序，将断点设置在漏洞所在函数的 `ret` 语句处，观察此时各个寄存器的值；\n3. 结合你的观察，构造一个恰当的 payload，使得程序执行 `./malware`；\n\n#### 提示\n\n- 不同输入函数的“截断”不同，截断指的是输入函数在读取到哪些字符时会停止读取。比如，`gets` 函数会读取到换行符为止，所以它也会读入 `\\0` 这种非常特殊的字符。具体可以参照 [CTF中常见的C语言输入函数截断属性总结](https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/16/input/)\n\n- 一个示例的构造payload的方法：\n\n假设buffer距离返回地址的偏移为0x10，且我们想让程序返回到地址 `0x4005d6`，则我们可以编写一个如下的 Python 程序：\n\n```python\nimport sys\npayload = b'A' * 0x10 + b'\\xd6\\x05\\x40\\x00\\x00\\x00\\x00\\x00'\nsys.stdout.buffer.write(payload)\n```\n\n然后在终端中执行：\n\n```bash\npython3 payload.py | ./bash-calc\n```\n\n或者直接将 payload 写入文件，然后使用重定向机制：\n\n```bash\npython3 payload.py > payload\n./bash-calc < payload\n```\n\n后者可以帮助你在使用gdb时更好地调试，比如在gdb中执行 `run < payload` 就可以使用终端的重定向语法。\n\n- 我们的目标类似于执行 `system(\"./malware\")`，如果你已经构造成功了 payload 使程序执行 `system(\"./malware\")`，但程序在 `system` 函数的内部崩溃了，这在我们的预期内。\n\n造成这种情况的原因是：`system` 内部某些汇编语句对栈的对齐要求很高，如果没有对齐至 0x10，就会导致程序崩溃。如果你使用gdb进行调试，你就可以看到这几条非常“挑剔”的汇编指令。\n\n在正常执行一个函数时，`rsp` 寄存器是向 0x10 对齐的；调用某一个函数时使用的是 `call` 指令，会往栈上压入一个8字节的返回地址（这里就破坏了对齐），然后跳转到函数的起始位置。因此，每个函数都会假设自己刚刚被调用时，`rsp` 寄存器是不向 0x10 对齐的。\n\n然而，我们通过劫持返回地址调用某个函数时，我们并没有使用 `call` 指令，而是直接跳转到了函数的开头。这就导致函数开始时，栈反而向 0x10 对齐了，这破坏了 `system` 函数的假设，导致程序崩溃。\n\n解决办法很简单：**不要直接调用 `system` 函数，而是调用一个中间函数，并且跳过函数开头的一条 `push rbp` 指令。**这类似于手动破坏栈的对齐，使得 `system` 函数可以正常执行。关于这个解决方法的原理分析，我们留作思考题。\n\n- 额外补充一个小技巧：在 system（或是命令行shell）中，你可以使用 `#` 符号注释掉不需要的内容。比如，`system(\"echo hello # echo world\")` 只会输出 `hello`，而不会输出 `world`。\n\n### 实验之后的思考题\n\n除了在报告描述你的攻击流程之外，你还需要在报告中回答以下问题：\n\n**Problem 1.1** 实验任务中导致溢出的函数早就成为了一个臭名昭著的函数，现如今几乎没有人会再使用它。但即使在 2024 年的今天，我们依然会看到许许多多的栈溢出、堆溢出漏洞。请你思考一下，还有什么其他的场景、函数会导致溢出？你自己是否在编程中遇到过栈溢出的情况？\n\n**Problem 1.2** 提示中提到了一个解决方案：**不要直接调用 `system` 函数，而是调用一个中间函数，并且跳过函数开头的一条 `push rbp` 指令。**这类似于手动破坏栈的对齐，使得 `system` 函数可以正常执行。请你思考一下，为什么这样做可以解决问题？\n\n## 二、栈溢出的防御\n\n有一种针对于栈溢出的防御机制被广泛部署于各种软件中，也早已被作为编译器的默认选项。\n\n在这个任务中，我们需要你重新编译 `bash-calc.c`，通过阅读汇编代码的方式，理解这种防御机制的原理。\n\n你可以使用这条指令来重新编译一个 `bash-calc-my`：\n\n```bash\ngcc -no-pie -o bash-calc-my bash-calc.c\n```\n\n在编译以后，你可以通过两种方式来探索这种防御机制：\n\n1. 借助gdb动态调试，使用刚刚的 payload 攻击程序，观察程序的行为；\n2. 借助objdump静态分析，观察程序新增加的汇编代码，通过搜索等手段理解其意义。\n\n你需要在实验报告中描述你对这种防御机制原理的理解，并尝试回答一个问题：\n\n**Problem 2.1** 这种防御机制是否能够彻底“防御”栈溢出漏洞？\n\n## 三、栈帧的更多应用（协程）\n\n在前两项任务中，我们已经加深了对程序运行时的栈帧的认识，接下来，我们使用栈帧和一定的汇编语言，来给C语言实现一些更加现代的功能吧。\n\n本实验文件位于Task3文件夹，可以使用`make clean && make`来编译代码，使用`./program`来运行代码。\n\n### 前言\n\n> 本实验并不需要清晰地知道进程和线程的区别。你可以理解为一个进程可以开启多个线程，让CPU的不同核心同时计算不同的功能。\n\n如果在程序运行的过程中，我们直接将PC（%rip）的值修改到某个指定地址，那程序大概率是不能正常运行的。比如我们尝试编译这样一个简单的二分查找C语言程序：\n\n```C\n#include <stdio.h>\nint arr[] = {1, 2, 3, 5, 8, 13, 21, 34};\n\nint binSearch(int dest){\n    register int l=0, r=7;\n    register int result = -1;\n    while(l<=r){\n        int mid = (l+r)>>1;\n        if(arr[mid]<dest)l=mid+1;\n        else if(arr[mid]>dest)r=mid-1;\n        else {\n            result = mid;\n            break;\n        }\n    }\n    if(result == -1) result = l;\n    return result;\n}\n\nvoid main(){\n    for(int i=0; i<=35;++i){\n        printf(\"%d \", binSearch(i));\n    }\n    printf(\"\\n\");\n}\n```\n\n它的main函数反汇编后如下：\n\n```\n0000000000001202 <main>:\n    1202:\tf3 0f 1e fa          \tendbr64 \n    1206:\t55                   \tpush   %rbp\n    1207:\t48 89 e5             \tmov    %rsp,%rbp\n    120a:\t48 83 ec 10          \tsub    $0x10,%rsp\n    120e:\tc7 45 fc 00 00 00 00 \tmovl   $0x0,-0x4(%rbp)\n    1215:\teb 21                \tjmp    1238 <main+0x36>\n    1217:\t8b 45 fc             \tmov    -0x4(%rbp),%eax\n    121a:\t89 c7                \tmov    %eax,%edi\n    121c:\te8 48 ff ff ff       \tcall   1169 <binSearch>\n    1221:\t89 c6                \tmov    %eax,%esi\n    1223:\t48 8d 3d da 0d 00 00 \tlea    0xdda(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>\n    122a:\tb8 00 00 00 00       \tmov    $0x0,%eax\n    122f:\te8 3c fe ff ff       \tcall   1070 <printf@plt>\n    1234:\t83 45 fc 01          \taddl   $0x1,-0x4(%rbp)\n    1238:\t83 7d fc 23          \tcmpl   $0x23,-0x4(%rbp)\n    123c:\t7e d9                \tjle    1217 <main+0x15>\n    123e:\tbf 0a 00 00 00       \tmov    $0xa,%edi\n    1243:\te8 18 fe ff ff       \tcall   1060 <putchar@plt>\n    1248:\t90                   \tnop\n    1249:\tc9                   \tleave  \n    124a:\tc3                   \tret    \n\n```\n\n**Problem 4.1** 在运行main函数时，内存-0x4(%rbp)处是什么？1217位置的mov语句是为了做什么？\n\n**Problem 4.2** 二分查找函数中我们使用了`register int`保留字，这告诉编译器要把变量存到寄存器而不是内存中，这样做有什么好处<sup>1</sup>？正因如此，在执行完二分查找函数中的**算法部分**，希望返回主函数时，能否直接修改%rip的值到1221而不做其他事情？还缺少什么步骤？\n\n> [1]实际上在现代编译器中，你不需要自己手写register关键字。开启优化后，编译器会自动安排变量的位置，找到最优化的一种策略，这基本是现代编译器必备的操作。\n\n### 上下文保存与恢复\n\n打开Linux终端，输入`top -H`指令（按下q退出），看看当前电脑上正在运行的线程有多少个？再输入`cat /proc/cpuinfo | grep processor`，看看你的电脑的CPU有多少个线程？\n\n在大部分情况下，系统中正在运行的线程数量都比CPU的线程数要多，但是你可以试试播放同时多个视频、音频、下载文件、编辑文档、QQ微信接收消息、显示动态壁纸……CPU可以“同时”做到这些事情。想要实现这个效果，自然不能让一个程序线程独占一个CPU，也就是——限制线程能连续在CPU上运行的时间，时间用完后**切换**到一个其它的线程继续运行。只要这个连续运行时间足够短，在我们看起来，电脑就是在同时进行所有工作。\n\n上面这段文字暗含了一些信息：电脑需要保存一个线程“**执行到什么状态了**”，这样它下次继续运行该线程时可以直接从暂停的位置继续。我们将这个**执行的状态**称之为**上下文**，这两种操作分别称为**保存上下文**和**恢复上下文**，记为save和restore。本实验我们将这些操作限制在同一个进程内，同学们不需要考虑硬件和操作系统层面的内容。\n\n**Problem 4.3** 结合Problem4.2，为了让程序能在跳转到指定位置后正常运行，我们除了修改%rip，还需要复原__的状态。所以，save操作需要将这些信息记录到内存中。\n\n我们在这里规定save操作不记录函数的栈帧。想象一下用户在函数中申请了一个16MB的数组，如果save记录栈帧，一次调用就需要将整个数组都复制一遍，低效且浪费空间。\n\n实际上，对于当前save和restore的定义，我们还有两个需要考虑的方面。对于如下的伪代码：\n\n```\nfuncA:\n    x = 0\n    save()\n    x = 1\n    call funcB\n\nfuncB:\n    restore()\n```\n**Problem 4.4** 假如变量x被存放在栈帧上，在restore操作后，x的值为__；假如变量x被存放在寄存器上，在restore操作后，x的值为__。\n\n由于变量放在寄存器还是内存是由编译器决定的，根据编译器策略的不同，可能会导致同一份代码产生不同的运行结果。为了简化问题，我们可以做出如下限定：执行save语句的函数结束后，这一份save记录被销毁；我们规定在save语句后修改过的局部变量，在restore后都是未知的，让开发者不要在restore之后直接使用这些变量的值。\n\n此外还有一个问题。我们可以模拟这个过程：程序首先在funcA中save一次，调用funcB，restore后程序复原到save时的状态，又回到x=1这条指令。接下来程序又调用funcB，又执行一次restore，这显然不是我们所期望的。\n\n为了避免这种“循环”带来的错误，我们可以给save添加一个“返回值”。save记录时返回0，程序正常执行；而执行restore后，程序的执行位置同样会回到save的后一条语句，其表现也像是“在save后返回到该函数”。因此，只需要让此时save的返回值表现为非0，就能区分开save和restore，甚至还能用一些枚举值来表示“程序为什么调用了restore”。\n\n```\nfuncA:\n    x = 0\n    if save() == 0:\n        x = 1\n        call funcB\n    else:\n        return\n\nfuncB:\n    restore()\n```\n\n接下来，我们将通过汇编实现save和restore的功能（显然不考虑内联汇编的C语言难以实现这个功能），不过在此之前我们先着手用汇编语言写一个简单的函数吧。\n\n**Problem 4.3** 请用不超过5条汇编指令<sup>2</sup>实现函数naive_func，直接写在实验报告中。该函数的功能为：将函数的返回地址保存到第一个参数所指定的内存地址，然后返回0。可参考伪代码：\n```\nnaive_func(void **p):\n    *p = (return addr);\n    return 0;\n```\n\n> [2]不计伪指令。如果可以，请在函数开头加上`endbr64`，正确做法下指令数量是足够的。\n\n**Problem 4.4** 也许你在课上学过函数开头两条指令的固定格式`push rbp; mov rbp, rsp`。但是前面所写的naive_func显然不遵循这样的格式，为什么这是可以的呢？\n\n接下来，我们开始着手实现save和restore函数，为了实现更多后续功能，这两个函数的定义与上文所述有略微不同，请参见API手册。\n\n**Task 4.1** 请在`context_asm.S`中实现函数`__ctx_save`和`__ctx_restore`，分别对应上文所述的save和restore操作。根据函数的定义，你需要仔细考虑哪些数据是需要存储到`__ctx`中的。你可以自行调整`__ctx`类型申请的内存大小，但是我们保证原始代码给出的120字节是足够的。如果一切顺利，在完成本节内容后，你将能通过 test1 和 test2。\n\n> 按照 x86-64 调用约定，rdi 和 rsi 分别为函数调用的第一二个参数，rax 为函数调用的返回值。在默认情况下，gcc 使用 AT&T 汇编语法。如果你想要使用 Intel 汇编语法，可以在ctx.S的开头加上一句.intel_syntax noprefix。\n> 禁止使用 setjmp 或 __builtin_setjmp 等现成函数，但你也许可以参考它们的实现。\n\n### 基于上下文回退的异常处理\n\n现代编程语言基本都支持异常处理机制，即程序包含以try和catch（或except等关键字）开头的代码块，程序员可以将一些代码放到try代码块中，如果遇到除0错误或是其他一些错误，程序不是直接停止运行，而是跳转到catch后面继续运行。\n\n基于上一部分已经实现的两个操作，我们可以实现一个简单的异常处理机制，不妨参考下面的伪代码：\n\n```\nfunc():\n    x = input\n    if save() == 0:\n        check(x)\n        print(input / 2)\n    else:\n        print(\"Input is invalid\")\n\ncheck(x):\n    if not isdigit(x):\n        recover(error_code)\n```\n这实际上等同于使用try-catch机制，它和下面的Python代码是基本等价的：\n\n```python\ndef func():\n    x = input()\n    try:\n        check(x)\n        print(int(x) / 2)\n    except:\n        print(\"Input is invalid\")\n\ndef check(x):\n    if not x.isdigit():\n        raise Exception(\"Input is invalid\")\n```\n\n借助C语言的宏，我们可以将原始含save和recover的代码包装成类似Python或者C++风格的代码。而且，try-catch是可以嵌套的。在发生try-catch嵌套时，程序中会同时存在许多个try记录的上下文。在执行throw操作时，我们需要恢复到最新的一个上下文，如下面的C++代码：\n\n```C++\ntry{\n    try{\n        throw Exception;\n    }\n    catch{\n        cout << 1;\n    }\n}\ncatch{\n    cout << 2;\n}\n```\n该代码会输出1。\n\n容易看出，这实际上就是一个栈的结构，我们将其称为异常处理栈。对于每个try操作，它记录当前的上下文，并将其加入异常处理栈。对于每个throw操作，它弹出异常处理栈中的栈顶元素，将当前状态恢复成该上下文，并转而执行catch操作。当然，清理也是必须的，对于每个正常完成的try操作，我们需要弹出异常处理栈中的栈顶元素，使之恢复到try操作之前的状态，如下面的代码则会输出2：\n```C++\ntry{\n    try{\n    }\n    catch{\n        cout << 1;\n    }\n    throw Exception;\n}\ncatch{\n    cout << 2;\n}\n```\n\n在本lab中，我们采用单向链表的方式来实现这个栈。在该Task中，你暂时不需要考虑`__generator`结构体的作用，只需要知道`__now_gen->__err_stk_head`是这个单向链表的表头，`__err_stk_node`结构体用于表示链表的节点。你需要实现`__err_stk_push`和`__err_stk_pop`两个函数来实现链表的操作，然后使用我们当前已实现的功能，填充`try`、`catch`和`throw`的宏定义<sup>3</sup>。\n\n> [3]C语言提供了cleanup属性，被添加该属性的变量会在生命周期结束时执行对应的函数，可以理解为类似析构函数的功能，可参考https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html\n\n**Task 4.2** 请在`context.c`中实现函数`__err_stk_push`和`__err_stk_pop`，然后在`context.h`中实现`try`、`catch`和`throw`的宏定义。如果一切顺利，在完成本节内容后，你将能通过test3、test4和test5。\n\n### 基于上下文切换的生成器（协程）\n\n如果你还不熟悉Python的生成器，可以试着跑一下以下程序，观察输出：\n\n```python\ndef test(x):\n    val = x\n    for i in range(5):\n        val = yield val\n        print(val)\n        val += 1\n\ngen = test(1)\narray = [gen.send(None)]\nprint(array)\nwhile True:\n    array.append(gen.send(array[-1]*10))\n    print(array)\n```\n\n这段代码里面有关键字`yield`和函数`send`。当gen被赋值为一个函数后，程序并没有执行该函数。而第一次调用`send`方法时，程序跳转到该函数的开头开始执行，执行到第一个`yield`关键字时，函数将`yield`后面的值作为`send`方法的返回值，恢复到主函数继续执行。下次`send`又被调用时，程序并不是在函数中从头开始，而是接着上次`yield`返回主函数的位置继续向后执行，且`send`的值在该函数看来就是`yield`的返回值。当`test`函数执行完毕后，程序会抛出一个异常。\n\n这似乎跟我们前面实现的保存上下文很像：`yield`保存了函数当前的上下文，返回主函数；`send`保存了主函数的上下文，恢复函数的上下文继续执行。看起来这个功能似乎很好实现？不过先让我们看看下面的伪代码：\n\n```\nctx a, b;\n\nfuncA:\n    for i in 0..10:\n    print(\"A\", i);\n    if(save(&a) == 0):\n        restore(&b);\n\nfuncB:\n    for i in 0..10:\n    print(\"B\", i);\n    if(save(&b) == 0):\n        restore(&a)\n```\n\n容易看出，如果这段代码已经跑起来了，它可以交替执行 A、B 两个循环，只要在此基础上包装出 yield 和 send 函数，即可达到与 Python 中生成器一致的效果。但我们首先要解决一个问题：它是怎么跑起来的？\n\n请注意我们在之前提出的约定：函数返回之后，不能再使用其调用`save`保存的上下文。因此，要想使funcA中引用的ctx b有效，必须保证funcB不返回（保证不清除栈帧），这似乎只可能发生在funcB调用了funcA的情况下。但反过来，要想使funcB中引用的ctx a有效，也必须保证funcA不返回（保证不清除栈帧），似乎只可能发生在funcA调用了funcB的情况下。\n\n上面的分析仿佛引出了一个悖论。事实上，这一悖论只会在funcA和funcB使用同一个调用栈的情况下成立。假如我们为funcA和funcB分配两个不同的栈空间，那么执行funcA时，funcB的栈帧保留在它自己的栈空间上，与funcA所在的栈空间并无关联，也就不需要调用关系来保证funcB不返回了。\n\n为了实现多个栈空间，我们可以手动申请一块内存，配置一段上下文，然后通过我们实现的restore函数让程序跳转到这一段内存开始执行函数，这样这个函数就有了一段独立的栈空间。\n\n总结一下这个过程：创建生成器时，程序申请一段内存，并在该内存中配置一段初始上下文，等待调用。当生成器第一次被调用时，恢复到这段初始上下文，开始执行生成器对应的函数，直到第一次遇到yield，保存当前生成器的上下文，回到调用该生成器的函数中。如果生成器的函数执行完毕，抛出一个`ERR_GENEND`异常。在已给出的`__generator`结构体中，我们使用`data`变量来传输`yield`和`send`的返回值。为方便起见，我们将主函数也视作一个generator（只不过你不需要手动给这个generator制作一个栈空间和初始上下文），因此全局变量`__now_gen`被初始化为了`&__main_gen`，且每个generator都有自己的异常处理栈。\n\n**Task 4.3** 请在`context.c`中实现函数`send`、`yield`和`generator`（你可以理解为构造函数）。允许自行添加一些函数，因为你可能需要一些跳板函数来实现生成器的启动。你可能需要修改`throw`宏，以在外部处理生成器中未处理的`throw`。如果一切顺利，在完成本节内容后，你将能通过test6和test7。\n\n### 协程的一些实际应用\n\n协程在现代应用程序中有广泛的应用。比如，手机程序向服务器请求数据时同时显示动画，就可以理解为本机的逻辑处理函数发送网络请求后，上下文恢复到主函数来显示动画，一旦服务器返回了数据，上下文又切换到逻辑处理函数来执行后续操作。这是非常节约资源的一个方法：开辟新线程来进行网络通信也可以达到相同的效果，但开辟新线程本身就会消耗一些系统资源，所以不是最优的选择。\n\n本Lab最后一个部分希望你能自定义一个基于协程的进度条动画。考虑我们平时玩的游戏，游戏画面本身也是多张图片连续快速播放，人眼看起来就变成了连贯的动画，这一过程可以用以下伪代码表示：\n\n```\ndef game():\n    record_time = get_time()\n\n    while True:\n        now_time = get_time()\n        delta_time = now_time - record_time\n        record_time = now_time\n\n        get_user_input()\n        handle_events(delta_time)\n        draw_scene()\n        sleep_until_next_frame()\n```\n\n其中，`delta_time`代表游戏两帧之间间隔了多久，游戏场景里面的物件会根据这个时间间隔移动相应的距离。\n\n当需要给某游戏物件做一个持续若干秒的动画时，我们不能在某函数中写一个循环，每次移动一点物体，然后`sleep`若干毫秒，循环直到动画结束，这会导致在动画结束前都无法执行到其它代码，会阻碍其他游戏事件的进行。一种解决方法时，开启一个新的协程，每次主函数向协程`send(delta_time)`，协程就会根据时间变化量少量修改对应物体的坐标，然后`yield`回到主函数来执行其它代码，等待下一帧到来，主函数继续`send`，以此类推，直到动画结束。\n\n> 这是在如Unity等游戏引擎中一种典型的通过代码来制作物体动画的方法。\n\n**Task 4.4** 基于上面的讨论，请你完善`main.c`中的`progress_bar`函数，实现一个自定义的进度条动画。发挥你的想象力即可。\n\n![](task3_result.gif)\n\n---\n\n参考资料：\n- Kieray Lab from ICS 2022\n\n","source":"_posts/StackLab.md","raw":"---\ntitle: StackLab\nauthor: 王雨晨 杨洋\nemail: yuchenwang21@m.fudan.edu.cn yyang21@m.fudan.edu.cn\n---\n\n> Deadline：2024-11-20 23:59:59\n\n## 〇、实验简介\n\n栈帧相关实验。\n\n本学期，我们将金老师ICS第三个Lab回炉重造，添加更多讲解，以加深各位同学对栈帧的理解，并探索一些相关应用，丰富同学们的知识面。\n\n本次Lab由三个部分组成：\n\n- 尝试在含有漏洞的程序中实现**任意代码执行**\n- 学习 Canary 机制，了解栈溢出的防御\n- 尝试使用栈帧完成更多有意思的功能\n\n## 一、危险的计算器\n\n### RCE 攻击\n\n电影中的黑客神通广大，能神不知鬼不觉地“黑”掉各种计算机系统，他们是如何做到的？\n\n首先，我们需要认识一下“黑”掉一个系统到底是指什么，对于黑客来说，有许多种不同的攻击效果（或者说漏洞）：\n\n- RCE (Remote Code Execution)：远程代码执行，即攻击者可以在远程服务器上执行任意代码；\n- DoS (Denial of Service)：拒绝服务，即攻击者可以让服务器无法正常工作；\n- MITM (Man-In-The-Middle)：中间人攻击，即攻击者可以在通信过程中窃取信息；\n- ……\n\n其中，攻击者最为喜闻乐见的就是RCE，因为这意味着他们可以在服务器上执行任意程序代码，做任何自己想做的事。比如，他可以把网站服务器托管的网站的首页改成自己的名字；又比如，他可以在上面运行自己的挖矿程序，借用他人计算机的算力帮自己牟利。\n\n一个最简单的RCE漏洞形如：\n\n```c\nread(0, input, 20);\nsystem(input);\n```\n\n这段代码读取用户输入，并调用了 `system` 函数。`system` 函数的功能是执行一条shell指令，比如 `system(\"ls\")` 就会相当于在命令行上输入 `ls` 以显示当前目录下的文件。\n\n这个程序在本地运行时，显然没什么问题，但如果这个 input 字符串来源于网络，这意味着攻击者可以通过输入恶意指令来执行任意代码。比如，当类似于这段代码的程序运行在一个服务器上时，攻击者只要想办法控制input为 `rm -rf /` 就可以删除服务器上的所有文件。\n\n所以，RCE 通常就是指“在目标机器上执行任意shell指令”。\n\n### 栈溢出漏洞\n\n栈溢出漏洞是一种常见且经典的漏洞，破坏力非常强大——它经常可以使攻击者达成 RCE。\n\n栈溢出漏洞在C语言当中非常常见，主要是因为使用 C 语言时非常容易漏掉对数组边界和 buffer 大小的检查。比如，下面这段代码：\n\n```c\nchar buffer[20];\ngets(buffer);\n```\n\n这段代码使用了 `gets` 函数，它会读取用户输入并存储到 `buffer` 中。然而，`gets` 函数并不会检查用户输入的长度，如果用户输入的长度超过了 `buffer` 的大小，就会导致多余的数据“溢出”到栈上的其他位置，导致其他数据被干扰。这就是栈溢出的定义。\n\n### 从栈溢出漏洞到劫持程序控制流\n\n之所以栈溢出漏洞如此危险，是因为它可以被利用来劫持程序的控制流。我们来回忆一下，栈上有哪些数据？\n\n![](https://organicprogrammer.com/images/stack_contents.png)\n\n注意到，其中有一个重要的数据：返回地址。当函数调用结束时，程序会跳转到这个返回地址继续执行。\n\n如果攻击者栈溢出的数据控制了这个返回地址，他就可以决定程序接下来返回到哪里，从而控制程序的执行流程。\n\n### 在劫持了程序控制流之后\n\n“决定程序接下来执行哪个函数”，这听起来是不是很像我们之前说的RCE？没错，这就是栈溢出漏洞的危险之处：它可以被利用来实现任意代码执行。试想，如果程序中存在一个调用 `system(\"/bin/sh\")` 函数的地方，我们只需要把对应的地址填到栈上返回地址的位置，就可以控制程序去调用 `system(\"/bin/sh\")`，从而获取一个 shell 达成 RCE。\n\n然而，并不是所有的程序都会调用 `system(\"/bin/sh\")` 或是类似的函数，这种情况怎么办呢？我们现在仅仅能够控制程序接下来执行哪个地址的代码，离执行任意的shell指令还有一段距离。\n\n这个时候就需要进行“构造”了，攻击者在利用漏洞时，需要利用好一切可以利用的资源，包括但不限于：当前寄存器中的数据、内存中的机器码和数据等等。\n\n比如，我们知道 `rdi` 寄存器是用来传递第一个参数的寄存器。如果我们劫持程序控制流到 `foo(int a)` 函数，其实就相当于调用了 `foo(<当前rdi值>)`。\n\n又比如，我们不一定要控制程序去返回到某个函数（的起始位置），而可以控制程序返回到某个函数的中间。如果有这样一个函数：\n\n```c\nvoid foo() {\n    if (false) {\n        system(\"/bin/sh\");\n    }\n    return;\n}\n```\n\n看上去这个函数没有任何用，因为它什么都不会干。但其中包含的 `system(\"/bin/sh\")` 片段可以为我们所用：我们可以直接控制程序执行 if 内的代码。\n\n### 实验\n\n在本次试验中，我们给出了一个简单但包含有漏洞的计算器程序，它会读取用户输入的表达式，包上 `echo $(())` 后调用 `system` 函数来计算表达式的结果。\n\n你的任务是：利用栈溢出漏洞，控制程序执行 `./malware` 。这个“恶意程序”会检测自己的父进程调用，如果发现自己由 `bash-calc` 调用，就会输出 `You have successfully detonated the bomb! Congratulations!`，表示你已经成功完成了任务。\n\n#### 实验步骤\n\n1. 阅读 `bash-calc.c` 源代码，理解程序的逻辑，找到漏洞所在函数，计算出溢出所需要的字符数；\n2. 使用 `gdb` 调试程序，将断点设置在漏洞所在函数的 `ret` 语句处，观察此时各个寄存器的值；\n3. 结合你的观察，构造一个恰当的 payload，使得程序执行 `./malware`；\n\n#### 提示\n\n- 不同输入函数的“截断”不同，截断指的是输入函数在读取到哪些字符时会停止读取。比如，`gets` 函数会读取到换行符为止，所以它也会读入 `\\0` 这种非常特殊的字符。具体可以参照 [CTF中常见的C语言输入函数截断属性总结](https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/16/input/)\n\n- 一个示例的构造payload的方法：\n\n假设buffer距离返回地址的偏移为0x10，且我们想让程序返回到地址 `0x4005d6`，则我们可以编写一个如下的 Python 程序：\n\n```python\nimport sys\npayload = b'A' * 0x10 + b'\\xd6\\x05\\x40\\x00\\x00\\x00\\x00\\x00'\nsys.stdout.buffer.write(payload)\n```\n\n然后在终端中执行：\n\n```bash\npython3 payload.py | ./bash-calc\n```\n\n或者直接将 payload 写入文件，然后使用重定向机制：\n\n```bash\npython3 payload.py > payload\n./bash-calc < payload\n```\n\n后者可以帮助你在使用gdb时更好地调试，比如在gdb中执行 `run < payload` 就可以使用终端的重定向语法。\n\n- 我们的目标类似于执行 `system(\"./malware\")`，如果你已经构造成功了 payload 使程序执行 `system(\"./malware\")`，但程序在 `system` 函数的内部崩溃了，这在我们的预期内。\n\n造成这种情况的原因是：`system` 内部某些汇编语句对栈的对齐要求很高，如果没有对齐至 0x10，就会导致程序崩溃。如果你使用gdb进行调试，你就可以看到这几条非常“挑剔”的汇编指令。\n\n在正常执行一个函数时，`rsp` 寄存器是向 0x10 对齐的；调用某一个函数时使用的是 `call` 指令，会往栈上压入一个8字节的返回地址（这里就破坏了对齐），然后跳转到函数的起始位置。因此，每个函数都会假设自己刚刚被调用时，`rsp` 寄存器是不向 0x10 对齐的。\n\n然而，我们通过劫持返回地址调用某个函数时，我们并没有使用 `call` 指令，而是直接跳转到了函数的开头。这就导致函数开始时，栈反而向 0x10 对齐了，这破坏了 `system` 函数的假设，导致程序崩溃。\n\n解决办法很简单：**不要直接调用 `system` 函数，而是调用一个中间函数，并且跳过函数开头的一条 `push rbp` 指令。**这类似于手动破坏栈的对齐，使得 `system` 函数可以正常执行。关于这个解决方法的原理分析，我们留作思考题。\n\n- 额外补充一个小技巧：在 system（或是命令行shell）中，你可以使用 `#` 符号注释掉不需要的内容。比如，`system(\"echo hello # echo world\")` 只会输出 `hello`，而不会输出 `world`。\n\n### 实验之后的思考题\n\n除了在报告描述你的攻击流程之外，你还需要在报告中回答以下问题：\n\n**Problem 1.1** 实验任务中导致溢出的函数早就成为了一个臭名昭著的函数，现如今几乎没有人会再使用它。但即使在 2024 年的今天，我们依然会看到许许多多的栈溢出、堆溢出漏洞。请你思考一下，还有什么其他的场景、函数会导致溢出？你自己是否在编程中遇到过栈溢出的情况？\n\n**Problem 1.2** 提示中提到了一个解决方案：**不要直接调用 `system` 函数，而是调用一个中间函数，并且跳过函数开头的一条 `push rbp` 指令。**这类似于手动破坏栈的对齐，使得 `system` 函数可以正常执行。请你思考一下，为什么这样做可以解决问题？\n\n## 二、栈溢出的防御\n\n有一种针对于栈溢出的防御机制被广泛部署于各种软件中，也早已被作为编译器的默认选项。\n\n在这个任务中，我们需要你重新编译 `bash-calc.c`，通过阅读汇编代码的方式，理解这种防御机制的原理。\n\n你可以使用这条指令来重新编译一个 `bash-calc-my`：\n\n```bash\ngcc -no-pie -o bash-calc-my bash-calc.c\n```\n\n在编译以后，你可以通过两种方式来探索这种防御机制：\n\n1. 借助gdb动态调试，使用刚刚的 payload 攻击程序，观察程序的行为；\n2. 借助objdump静态分析，观察程序新增加的汇编代码，通过搜索等手段理解其意义。\n\n你需要在实验报告中描述你对这种防御机制原理的理解，并尝试回答一个问题：\n\n**Problem 2.1** 这种防御机制是否能够彻底“防御”栈溢出漏洞？\n\n## 三、栈帧的更多应用（协程）\n\n在前两项任务中，我们已经加深了对程序运行时的栈帧的认识，接下来，我们使用栈帧和一定的汇编语言，来给C语言实现一些更加现代的功能吧。\n\n本实验文件位于Task3文件夹，可以使用`make clean && make`来编译代码，使用`./program`来运行代码。\n\n### 前言\n\n> 本实验并不需要清晰地知道进程和线程的区别。你可以理解为一个进程可以开启多个线程，让CPU的不同核心同时计算不同的功能。\n\n如果在程序运行的过程中，我们直接将PC（%rip）的值修改到某个指定地址，那程序大概率是不能正常运行的。比如我们尝试编译这样一个简单的二分查找C语言程序：\n\n```C\n#include <stdio.h>\nint arr[] = {1, 2, 3, 5, 8, 13, 21, 34};\n\nint binSearch(int dest){\n    register int l=0, r=7;\n    register int result = -1;\n    while(l<=r){\n        int mid = (l+r)>>1;\n        if(arr[mid]<dest)l=mid+1;\n        else if(arr[mid]>dest)r=mid-1;\n        else {\n            result = mid;\n            break;\n        }\n    }\n    if(result == -1) result = l;\n    return result;\n}\n\nvoid main(){\n    for(int i=0; i<=35;++i){\n        printf(\"%d \", binSearch(i));\n    }\n    printf(\"\\n\");\n}\n```\n\n它的main函数反汇编后如下：\n\n```\n0000000000001202 <main>:\n    1202:\tf3 0f 1e fa          \tendbr64 \n    1206:\t55                   \tpush   %rbp\n    1207:\t48 89 e5             \tmov    %rsp,%rbp\n    120a:\t48 83 ec 10          \tsub    $0x10,%rsp\n    120e:\tc7 45 fc 00 00 00 00 \tmovl   $0x0,-0x4(%rbp)\n    1215:\teb 21                \tjmp    1238 <main+0x36>\n    1217:\t8b 45 fc             \tmov    -0x4(%rbp),%eax\n    121a:\t89 c7                \tmov    %eax,%edi\n    121c:\te8 48 ff ff ff       \tcall   1169 <binSearch>\n    1221:\t89 c6                \tmov    %eax,%esi\n    1223:\t48 8d 3d da 0d 00 00 \tlea    0xdda(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>\n    122a:\tb8 00 00 00 00       \tmov    $0x0,%eax\n    122f:\te8 3c fe ff ff       \tcall   1070 <printf@plt>\n    1234:\t83 45 fc 01          \taddl   $0x1,-0x4(%rbp)\n    1238:\t83 7d fc 23          \tcmpl   $0x23,-0x4(%rbp)\n    123c:\t7e d9                \tjle    1217 <main+0x15>\n    123e:\tbf 0a 00 00 00       \tmov    $0xa,%edi\n    1243:\te8 18 fe ff ff       \tcall   1060 <putchar@plt>\n    1248:\t90                   \tnop\n    1249:\tc9                   \tleave  \n    124a:\tc3                   \tret    \n\n```\n\n**Problem 4.1** 在运行main函数时，内存-0x4(%rbp)处是什么？1217位置的mov语句是为了做什么？\n\n**Problem 4.2** 二分查找函数中我们使用了`register int`保留字，这告诉编译器要把变量存到寄存器而不是内存中，这样做有什么好处<sup>1</sup>？正因如此，在执行完二分查找函数中的**算法部分**，希望返回主函数时，能否直接修改%rip的值到1221而不做其他事情？还缺少什么步骤？\n\n> [1]实际上在现代编译器中，你不需要自己手写register关键字。开启优化后，编译器会自动安排变量的位置，找到最优化的一种策略，这基本是现代编译器必备的操作。\n\n### 上下文保存与恢复\n\n打开Linux终端，输入`top -H`指令（按下q退出），看看当前电脑上正在运行的线程有多少个？再输入`cat /proc/cpuinfo | grep processor`，看看你的电脑的CPU有多少个线程？\n\n在大部分情况下，系统中正在运行的线程数量都比CPU的线程数要多，但是你可以试试播放同时多个视频、音频、下载文件、编辑文档、QQ微信接收消息、显示动态壁纸……CPU可以“同时”做到这些事情。想要实现这个效果，自然不能让一个程序线程独占一个CPU，也就是——限制线程能连续在CPU上运行的时间，时间用完后**切换**到一个其它的线程继续运行。只要这个连续运行时间足够短，在我们看起来，电脑就是在同时进行所有工作。\n\n上面这段文字暗含了一些信息：电脑需要保存一个线程“**执行到什么状态了**”，这样它下次继续运行该线程时可以直接从暂停的位置继续。我们将这个**执行的状态**称之为**上下文**，这两种操作分别称为**保存上下文**和**恢复上下文**，记为save和restore。本实验我们将这些操作限制在同一个进程内，同学们不需要考虑硬件和操作系统层面的内容。\n\n**Problem 4.3** 结合Problem4.2，为了让程序能在跳转到指定位置后正常运行，我们除了修改%rip，还需要复原__的状态。所以，save操作需要将这些信息记录到内存中。\n\n我们在这里规定save操作不记录函数的栈帧。想象一下用户在函数中申请了一个16MB的数组，如果save记录栈帧，一次调用就需要将整个数组都复制一遍，低效且浪费空间。\n\n实际上，对于当前save和restore的定义，我们还有两个需要考虑的方面。对于如下的伪代码：\n\n```\nfuncA:\n    x = 0\n    save()\n    x = 1\n    call funcB\n\nfuncB:\n    restore()\n```\n**Problem 4.4** 假如变量x被存放在栈帧上，在restore操作后，x的值为__；假如变量x被存放在寄存器上，在restore操作后，x的值为__。\n\n由于变量放在寄存器还是内存是由编译器决定的，根据编译器策略的不同，可能会导致同一份代码产生不同的运行结果。为了简化问题，我们可以做出如下限定：执行save语句的函数结束后，这一份save记录被销毁；我们规定在save语句后修改过的局部变量，在restore后都是未知的，让开发者不要在restore之后直接使用这些变量的值。\n\n此外还有一个问题。我们可以模拟这个过程：程序首先在funcA中save一次，调用funcB，restore后程序复原到save时的状态，又回到x=1这条指令。接下来程序又调用funcB，又执行一次restore，这显然不是我们所期望的。\n\n为了避免这种“循环”带来的错误，我们可以给save添加一个“返回值”。save记录时返回0，程序正常执行；而执行restore后，程序的执行位置同样会回到save的后一条语句，其表现也像是“在save后返回到该函数”。因此，只需要让此时save的返回值表现为非0，就能区分开save和restore，甚至还能用一些枚举值来表示“程序为什么调用了restore”。\n\n```\nfuncA:\n    x = 0\n    if save() == 0:\n        x = 1\n        call funcB\n    else:\n        return\n\nfuncB:\n    restore()\n```\n\n接下来，我们将通过汇编实现save和restore的功能（显然不考虑内联汇编的C语言难以实现这个功能），不过在此之前我们先着手用汇编语言写一个简单的函数吧。\n\n**Problem 4.3** 请用不超过5条汇编指令<sup>2</sup>实现函数naive_func，直接写在实验报告中。该函数的功能为：将函数的返回地址保存到第一个参数所指定的内存地址，然后返回0。可参考伪代码：\n```\nnaive_func(void **p):\n    *p = (return addr);\n    return 0;\n```\n\n> [2]不计伪指令。如果可以，请在函数开头加上`endbr64`，正确做法下指令数量是足够的。\n\n**Problem 4.4** 也许你在课上学过函数开头两条指令的固定格式`push rbp; mov rbp, rsp`。但是前面所写的naive_func显然不遵循这样的格式，为什么这是可以的呢？\n\n接下来，我们开始着手实现save和restore函数，为了实现更多后续功能，这两个函数的定义与上文所述有略微不同，请参见API手册。\n\n**Task 4.1** 请在`context_asm.S`中实现函数`__ctx_save`和`__ctx_restore`，分别对应上文所述的save和restore操作。根据函数的定义，你需要仔细考虑哪些数据是需要存储到`__ctx`中的。你可以自行调整`__ctx`类型申请的内存大小，但是我们保证原始代码给出的120字节是足够的。如果一切顺利，在完成本节内容后，你将能通过 test1 和 test2。\n\n> 按照 x86-64 调用约定，rdi 和 rsi 分别为函数调用的第一二个参数，rax 为函数调用的返回值。在默认情况下，gcc 使用 AT&T 汇编语法。如果你想要使用 Intel 汇编语法，可以在ctx.S的开头加上一句.intel_syntax noprefix。\n> 禁止使用 setjmp 或 __builtin_setjmp 等现成函数，但你也许可以参考它们的实现。\n\n### 基于上下文回退的异常处理\n\n现代编程语言基本都支持异常处理机制，即程序包含以try和catch（或except等关键字）开头的代码块，程序员可以将一些代码放到try代码块中，如果遇到除0错误或是其他一些错误，程序不是直接停止运行，而是跳转到catch后面继续运行。\n\n基于上一部分已经实现的两个操作，我们可以实现一个简单的异常处理机制，不妨参考下面的伪代码：\n\n```\nfunc():\n    x = input\n    if save() == 0:\n        check(x)\n        print(input / 2)\n    else:\n        print(\"Input is invalid\")\n\ncheck(x):\n    if not isdigit(x):\n        recover(error_code)\n```\n这实际上等同于使用try-catch机制，它和下面的Python代码是基本等价的：\n\n```python\ndef func():\n    x = input()\n    try:\n        check(x)\n        print(int(x) / 2)\n    except:\n        print(\"Input is invalid\")\n\ndef check(x):\n    if not x.isdigit():\n        raise Exception(\"Input is invalid\")\n```\n\n借助C语言的宏，我们可以将原始含save和recover的代码包装成类似Python或者C++风格的代码。而且，try-catch是可以嵌套的。在发生try-catch嵌套时，程序中会同时存在许多个try记录的上下文。在执行throw操作时，我们需要恢复到最新的一个上下文，如下面的C++代码：\n\n```C++\ntry{\n    try{\n        throw Exception;\n    }\n    catch{\n        cout << 1;\n    }\n}\ncatch{\n    cout << 2;\n}\n```\n该代码会输出1。\n\n容易看出，这实际上就是一个栈的结构，我们将其称为异常处理栈。对于每个try操作，它记录当前的上下文，并将其加入异常处理栈。对于每个throw操作，它弹出异常处理栈中的栈顶元素，将当前状态恢复成该上下文，并转而执行catch操作。当然，清理也是必须的，对于每个正常完成的try操作，我们需要弹出异常处理栈中的栈顶元素，使之恢复到try操作之前的状态，如下面的代码则会输出2：\n```C++\ntry{\n    try{\n    }\n    catch{\n        cout << 1;\n    }\n    throw Exception;\n}\ncatch{\n    cout << 2;\n}\n```\n\n在本lab中，我们采用单向链表的方式来实现这个栈。在该Task中，你暂时不需要考虑`__generator`结构体的作用，只需要知道`__now_gen->__err_stk_head`是这个单向链表的表头，`__err_stk_node`结构体用于表示链表的节点。你需要实现`__err_stk_push`和`__err_stk_pop`两个函数来实现链表的操作，然后使用我们当前已实现的功能，填充`try`、`catch`和`throw`的宏定义<sup>3</sup>。\n\n> [3]C语言提供了cleanup属性，被添加该属性的变量会在生命周期结束时执行对应的函数，可以理解为类似析构函数的功能，可参考https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html\n\n**Task 4.2** 请在`context.c`中实现函数`__err_stk_push`和`__err_stk_pop`，然后在`context.h`中实现`try`、`catch`和`throw`的宏定义。如果一切顺利，在完成本节内容后，你将能通过test3、test4和test5。\n\n### 基于上下文切换的生成器（协程）\n\n如果你还不熟悉Python的生成器，可以试着跑一下以下程序，观察输出：\n\n```python\ndef test(x):\n    val = x\n    for i in range(5):\n        val = yield val\n        print(val)\n        val += 1\n\ngen = test(1)\narray = [gen.send(None)]\nprint(array)\nwhile True:\n    array.append(gen.send(array[-1]*10))\n    print(array)\n```\n\n这段代码里面有关键字`yield`和函数`send`。当gen被赋值为一个函数后，程序并没有执行该函数。而第一次调用`send`方法时，程序跳转到该函数的开头开始执行，执行到第一个`yield`关键字时，函数将`yield`后面的值作为`send`方法的返回值，恢复到主函数继续执行。下次`send`又被调用时，程序并不是在函数中从头开始，而是接着上次`yield`返回主函数的位置继续向后执行，且`send`的值在该函数看来就是`yield`的返回值。当`test`函数执行完毕后，程序会抛出一个异常。\n\n这似乎跟我们前面实现的保存上下文很像：`yield`保存了函数当前的上下文，返回主函数；`send`保存了主函数的上下文，恢复函数的上下文继续执行。看起来这个功能似乎很好实现？不过先让我们看看下面的伪代码：\n\n```\nctx a, b;\n\nfuncA:\n    for i in 0..10:\n    print(\"A\", i);\n    if(save(&a) == 0):\n        restore(&b);\n\nfuncB:\n    for i in 0..10:\n    print(\"B\", i);\n    if(save(&b) == 0):\n        restore(&a)\n```\n\n容易看出，如果这段代码已经跑起来了，它可以交替执行 A、B 两个循环，只要在此基础上包装出 yield 和 send 函数，即可达到与 Python 中生成器一致的效果。但我们首先要解决一个问题：它是怎么跑起来的？\n\n请注意我们在之前提出的约定：函数返回之后，不能再使用其调用`save`保存的上下文。因此，要想使funcA中引用的ctx b有效，必须保证funcB不返回（保证不清除栈帧），这似乎只可能发生在funcB调用了funcA的情况下。但反过来，要想使funcB中引用的ctx a有效，也必须保证funcA不返回（保证不清除栈帧），似乎只可能发生在funcA调用了funcB的情况下。\n\n上面的分析仿佛引出了一个悖论。事实上，这一悖论只会在funcA和funcB使用同一个调用栈的情况下成立。假如我们为funcA和funcB分配两个不同的栈空间，那么执行funcA时，funcB的栈帧保留在它自己的栈空间上，与funcA所在的栈空间并无关联，也就不需要调用关系来保证funcB不返回了。\n\n为了实现多个栈空间，我们可以手动申请一块内存，配置一段上下文，然后通过我们实现的restore函数让程序跳转到这一段内存开始执行函数，这样这个函数就有了一段独立的栈空间。\n\n总结一下这个过程：创建生成器时，程序申请一段内存，并在该内存中配置一段初始上下文，等待调用。当生成器第一次被调用时，恢复到这段初始上下文，开始执行生成器对应的函数，直到第一次遇到yield，保存当前生成器的上下文，回到调用该生成器的函数中。如果生成器的函数执行完毕，抛出一个`ERR_GENEND`异常。在已给出的`__generator`结构体中，我们使用`data`变量来传输`yield`和`send`的返回值。为方便起见，我们将主函数也视作一个generator（只不过你不需要手动给这个generator制作一个栈空间和初始上下文），因此全局变量`__now_gen`被初始化为了`&__main_gen`，且每个generator都有自己的异常处理栈。\n\n**Task 4.3** 请在`context.c`中实现函数`send`、`yield`和`generator`（你可以理解为构造函数）。允许自行添加一些函数，因为你可能需要一些跳板函数来实现生成器的启动。你可能需要修改`throw`宏，以在外部处理生成器中未处理的`throw`。如果一切顺利，在完成本节内容后，你将能通过test6和test7。\n\n### 协程的一些实际应用\n\n协程在现代应用程序中有广泛的应用。比如，手机程序向服务器请求数据时同时显示动画，就可以理解为本机的逻辑处理函数发送网络请求后，上下文恢复到主函数来显示动画，一旦服务器返回了数据，上下文又切换到逻辑处理函数来执行后续操作。这是非常节约资源的一个方法：开辟新线程来进行网络通信也可以达到相同的效果，但开辟新线程本身就会消耗一些系统资源，所以不是最优的选择。\n\n本Lab最后一个部分希望你能自定义一个基于协程的进度条动画。考虑我们平时玩的游戏，游戏画面本身也是多张图片连续快速播放，人眼看起来就变成了连贯的动画，这一过程可以用以下伪代码表示：\n\n```\ndef game():\n    record_time = get_time()\n\n    while True:\n        now_time = get_time()\n        delta_time = now_time - record_time\n        record_time = now_time\n\n        get_user_input()\n        handle_events(delta_time)\n        draw_scene()\n        sleep_until_next_frame()\n```\n\n其中，`delta_time`代表游戏两帧之间间隔了多久，游戏场景里面的物件会根据这个时间间隔移动相应的距离。\n\n当需要给某游戏物件做一个持续若干秒的动画时，我们不能在某函数中写一个循环，每次移动一点物体，然后`sleep`若干毫秒，循环直到动画结束，这会导致在动画结束前都无法执行到其它代码，会阻碍其他游戏事件的进行。一种解决方法时，开启一个新的协程，每次主函数向协程`send(delta_time)`，协程就会根据时间变化量少量修改对应物体的坐标，然后`yield`回到主函数来执行其它代码，等待下一帧到来，主函数继续`send`，以此类推，直到动画结束。\n\n> 这是在如Unity等游戏引擎中一种典型的通过代码来制作物体动画的方法。\n\n**Task 4.4** 基于上面的讨论，请你完善`main.c`中的`progress_bar`函数，实现一个自定义的进度条动画。发挥你的想象力即可。\n\n![](task3_result.gif)\n\n---\n\n参考资料：\n- Kieray Lab from ICS 2022\n\n","slug":"StackLab","published":1,"date":"2024-10-31T05:08:26.212Z","updated":"2024-11-01T08:37:00.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2yhehkn0006rzx48k1ycw63","content":"<blockquote>\n<p>Deadline：2024-11-20 23:59:59</p>\n</blockquote>\n<h2 id=\"实验简介\">〇、实验简介</h2>\n<p>栈帧相关实验。</p>\n<p>本学期，我们将金老师ICS第三个Lab回炉重造，添加更多讲解，以加深各位同学对栈帧的理解，并探索一些相关应用，丰富同学们的知识面。</p>\n<p>本次Lab由三个部分组成：</p>\n<ul>\n<li>尝试在含有漏洞的程序中实现<strong>任意代码执行</strong></li>\n<li>学习 Canary 机制，了解栈溢出的防御</li>\n<li>尝试使用栈帧完成更多有意思的功能</li>\n</ul>\n<h2 id=\"一危险的计算器\">一、危险的计算器</h2>\n<h3 id=\"rce-攻击\">RCE 攻击</h3>\n<p>电影中的黑客神通广大，能神不知鬼不觉地“黑”掉各种计算机系统，他们是如何做到的？</p>\n<p>首先，我们需要认识一下“黑”掉一个系统到底是指什么，对于黑客来说，有许多种不同的攻击效果（或者说漏洞）：</p>\n<ul>\n<li>RCE (Remote Code\nExecution)：远程代码执行，即攻击者可以在远程服务器上执行任意代码；</li>\n<li>DoS (Denial of\nService)：拒绝服务，即攻击者可以让服务器无法正常工作；</li>\n<li>MITM\n(Man-In-The-Middle)：中间人攻击，即攻击者可以在通信过程中窃取信息；</li>\n<li>……</li>\n</ul>\n<p>其中，攻击者最为喜闻乐见的就是RCE，因为这意味着他们可以在服务器上执行任意程序代码，做任何自己想做的事。比如，他可以把网站服务器托管的网站的首页改成自己的名字；又比如，他可以在上面运行自己的挖矿程序，借用他人计算机的算力帮自己牟利。</p>\n<p>一个最简单的RCE漏洞形如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read(<span class=\"number\">0</span>, input, <span class=\"number\">20</span>);</span><br><span class=\"line\">system(input);</span><br></pre></td></tr></table></figure>\n<p>这段代码读取用户输入，并调用了 <code>system</code>\n函数。<code>system</code> 函数的功能是执行一条shell指令，比如\n<code>system(\"ls\")</code> 就会相当于在命令行上输入 <code>ls</code>\n以显示当前目录下的文件。</p>\n<p>这个程序在本地运行时，显然没什么问题，但如果这个 input\n字符串来源于网络，这意味着攻击者可以通过输入恶意指令来执行任意代码。比如，当类似于这段代码的程序运行在一个服务器上时，攻击者只要想办法控制input为\n<code>rm -rf /</code> 就可以删除服务器上的所有文件。</p>\n<p>所以，RCE 通常就是指“在目标机器上执行任意shell指令”。</p>\n<h3 id=\"栈溢出漏洞\">栈溢出漏洞</h3>\n<p>栈溢出漏洞是一种常见且经典的漏洞，破坏力非常强大——它经常可以使攻击者达成\nRCE。</p>\n<p>栈溢出漏洞在C语言当中非常常见，主要是因为使用 C\n语言时非常容易漏掉对数组边界和 buffer\n大小的检查。比如，下面这段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buffer[<span class=\"number\">20</span>];</span><br><span class=\"line\">gets(buffer);</span><br></pre></td></tr></table></figure>\n<p>这段代码使用了 <code>gets</code> 函数，它会读取用户输入并存储到\n<code>buffer</code> 中。然而，<code>gets</code>\n函数并不会检查用户输入的长度，如果用户输入的长度超过了\n<code>buffer</code>\n的大小，就会导致多余的数据“溢出”到栈上的其他位置，导致其他数据被干扰。这就是栈溢出的定义。</p>\n<h3 id=\"从栈溢出漏洞到劫持程序控制流\">从栈溢出漏洞到劫持程序控制流</h3>\n<p>之所以栈溢出漏洞如此危险，是因为它可以被利用来劫持程序的控制流。我们来回忆一下，栈上有哪些数据？</p>\n<p><img\nsrc=\"https://organicprogrammer.com/images/stack_contents.png\" /></p>\n<p>注意到，其中有一个重要的数据：返回地址。当函数调用结束时，程序会跳转到这个返回地址继续执行。</p>\n<p>如果攻击者栈溢出的数据控制了这个返回地址，他就可以决定程序接下来返回到哪里，从而控制程序的执行流程。</p>\n<h3 id=\"在劫持了程序控制流之后\">在劫持了程序控制流之后</h3>\n<p>“决定程序接下来执行哪个函数”，这听起来是不是很像我们之前说的RCE？没错，这就是栈溢出漏洞的危险之处：它可以被利用来实现任意代码执行。试想，如果程序中存在一个调用\n<code>system(\"/bin/sh\")</code>\n函数的地方，我们只需要把对应的地址填到栈上返回地址的位置，就可以控制程序去调用\n<code>system(\"/bin/sh\")</code>，从而获取一个 shell 达成 RCE。</p>\n<p>然而，并不是所有的程序都会调用 <code>system(\"/bin/sh\")</code>\n或是类似的函数，这种情况怎么办呢？我们现在仅仅能够控制程序接下来执行哪个地址的代码，离执行任意的shell指令还有一段距离。</p>\n<p>这个时候就需要进行“构造”了，攻击者在利用漏洞时，需要利用好一切可以利用的资源，包括但不限于：当前寄存器中的数据、内存中的机器码和数据等等。</p>\n<p>比如，我们知道 <code>rdi</code>\n寄存器是用来传递第一个参数的寄存器。如果我们劫持程序控制流到\n<code>foo(int a)</code> 函数，其实就相当于调用了\n<code>foo(&lt;当前rdi值&gt;)</code>。</p>\n<p>又比如，我们不一定要控制程序去返回到某个函数（的起始位置），而可以控制程序返回到某个函数的中间。如果有这样一个函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">foo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        system(<span class=\"string\">&quot;/bin/sh&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看上去这个函数没有任何用，因为它什么都不会干。但其中包含的\n<code>system(\"/bin/sh\")</code>\n片段可以为我们所用：我们可以直接控制程序执行 if 内的代码。</p>\n<h3 id=\"实验\">实验</h3>\n<p>在本次试验中，我们给出了一个简单但包含有漏洞的计算器程序，它会读取用户输入的表达式，包上\n<code>echo $(())</code> 后调用 <code>system</code>\n函数来计算表达式的结果。</p>\n<p>你的任务是：利用栈溢出漏洞，控制程序执行 <code>./malware</code>\n。这个“恶意程序”会检测自己的父进程调用，如果发现自己由\n<code>bash-calc</code> 调用，就会输出\n<code>You have successfully detonated the bomb! Congratulations!</code>，表示你已经成功完成了任务。</p>\n<h4 id=\"实验步骤\">实验步骤</h4>\n<ol type=\"1\">\n<li>阅读 <code>bash-calc.c</code>\n源代码，理解程序的逻辑，找到漏洞所在函数，计算出溢出所需要的字符数；</li>\n<li>使用 <code>gdb</code> 调试程序，将断点设置在漏洞所在函数的\n<code>ret</code> 语句处，观察此时各个寄存器的值；</li>\n<li>结合你的观察，构造一个恰当的 payload，使得程序执行\n<code>./malware</code>；</li>\n</ol>\n<h4 id=\"提示\">提示</h4>\n<ul>\n<li><p>不同输入函数的“截断”不同，截断指的是输入函数在读取到哪些字符时会停止读取。比如，<code>gets</code>\n函数会读取到换行符为止，所以它也会读入 <code>\\0</code>\n这种非常特殊的字符。具体可以参照 <a\nhref=\"https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/16/input/\">CTF中常见的C语言输入函数截断属性总结</a></p></li>\n<li><p>一个示例的构造payload的方法：</p></li>\n</ul>\n<p>假设buffer距离返回地址的偏移为0x10，且我们想让程序返回到地址\n<code>0x4005d6</code>，则我们可以编写一个如下的 Python 程序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;A&#x27;</span> * <span class=\"number\">0x10</span> + <span class=\"string\">b&#x27;\\xd6\\x05\\x40\\x00\\x00\\x00\\x00\\x00&#x27;</span></span><br><span class=\"line\">sys.stdout.buffer.write(payload)</span><br></pre></td></tr></table></figure>\n<p>然后在终端中执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 payload.py | ./bash-calc</span><br></pre></td></tr></table></figure>\n<p>或者直接将 payload 写入文件，然后使用重定向机制：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 payload.py &gt; payload</span><br><span class=\"line\">./bash-calc &lt; payload</span><br></pre></td></tr></table></figure>\n<p>后者可以帮助你在使用gdb时更好地调试，比如在gdb中执行\n<code>run &lt; payload</code> 就可以使用终端的重定向语法。</p>\n<ul>\n<li>我们的目标类似于执行\n<code>system(\"./malware\")</code>，如果你已经构造成功了 payload\n使程序执行 <code>system(\"./malware\")</code>，但程序在\n<code>system</code> 函数的内部崩溃了，这在我们的预期内。</li>\n</ul>\n<p>造成这种情况的原因是：<code>system</code>\n内部某些汇编语句对栈的对齐要求很高，如果没有对齐至\n0x10，就会导致程序崩溃。如果你使用gdb进行调试，你就可以看到这几条非常“挑剔”的汇编指令。</p>\n<p>在正常执行一个函数时，<code>rsp</code> 寄存器是向 0x10\n对齐的；调用某一个函数时使用的是 <code>call</code>\n指令，会往栈上压入一个8字节的返回地址（这里就破坏了对齐），然后跳转到函数的起始位置。因此，每个函数都会假设自己刚刚被调用时，<code>rsp</code>\n寄存器是不向 0x10 对齐的。</p>\n<p>然而，我们通过劫持返回地址调用某个函数时，我们并没有使用\n<code>call</code>\n指令，而是直接跳转到了函数的开头。这就导致函数开始时，栈反而向 0x10\n对齐了，这破坏了 <code>system</code> 函数的假设，导致程序崩溃。</p>\n<p>解决办法很简单：<strong>不要直接调用 <code>system</code>\n函数，而是调用一个中间函数，并且跳过函数开头的一条 <code>push rbp</code>\n指令。</strong>这类似于手动破坏栈的对齐，使得 <code>system</code>\n函数可以正常执行。关于这个解决方法的原理分析，我们留作思考题。</p>\n<ul>\n<li>额外补充一个小技巧：在 system（或是命令行shell）中，你可以使用\n<code>#</code>\n符号注释掉不需要的内容。比如，<code>system(\"echo hello # echo world\")</code>\n只会输出 <code>hello</code>，而不会输出 <code>world</code>。</li>\n</ul>\n<h3 id=\"实验之后的思考题\">实验之后的思考题</h3>\n<p>除了在报告描述你的攻击流程之外，你还需要在报告中回答以下问题：</p>\n<p><strong>Problem 1.1</strong>\n实验任务中导致溢出的函数早就成为了一个臭名昭著的函数，现如今几乎没有人会再使用它。但即使在\n2024\n年的今天，我们依然会看到许许多多的栈溢出、堆溢出漏洞。请你思考一下，还有什么其他的场景、函数会导致溢出？你自己是否在编程中遇到过栈溢出的情况？</p>\n<p><strong>Problem 1.2</strong>\n提示中提到了一个解决方案：<strong>不要直接调用 <code>system</code>\n函数，而是调用一个中间函数，并且跳过函数开头的一条 <code>push rbp</code>\n指令。</strong>这类似于手动破坏栈的对齐，使得 <code>system</code>\n函数可以正常执行。请你思考一下，为什么这样做可以解决问题？</p>\n<h2 id=\"二栈溢出的防御\">二、栈溢出的防御</h2>\n<p>有一种针对于栈溢出的防御机制被广泛部署于各种软件中，也早已被作为编译器的默认选项。</p>\n<p>在这个任务中，我们需要你重新编译\n<code>bash-calc.c</code>，通过阅读汇编代码的方式，理解这种防御机制的原理。</p>\n<p>你可以使用这条指令来重新编译一个 <code>bash-calc-my</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -no-pie -o bash-calc-my bash-calc.c</span><br></pre></td></tr></table></figure>\n<p>在编译以后，你可以通过两种方式来探索这种防御机制：</p>\n<ol type=\"1\">\n<li>借助gdb动态调试，使用刚刚的 payload 攻击程序，观察程序的行为；</li>\n<li>借助objdump静态分析，观察程序新增加的汇编代码，通过搜索等手段理解其意义。</li>\n</ol>\n<p>你需要在实验报告中描述你对这种防御机制原理的理解，并尝试回答一个问题：</p>\n<p><strong>Problem 2.1</strong>\n这种防御机制是否能够彻底“防御”栈溢出漏洞？</p>\n<h2 id=\"三栈帧的更多应用协程\">三、栈帧的更多应用（协程）</h2>\n<p>在前两项任务中，我们已经加深了对程序运行时的栈帧的认识，接下来，我们使用栈帧和一定的汇编语言，来给C语言实现一些更加现代的功能吧。</p>\n<p>本实验文件位于Task3文件夹，可以使用<code>make clean &amp;&amp; make</code>来编译代码，使用<code>./program</code>来运行代码。</p>\n<h3 id=\"前言\">前言</h3>\n<blockquote>\n<p>本实验并不需要清晰地知道进程和线程的区别。你可以理解为一个进程可以开启多个线程，让CPU的不同核心同时计算不同的功能。</p>\n</blockquote>\n<p>如果在程序运行的过程中，我们直接将PC（%rip）的值修改到某个指定地址，那程序大概率是不能正常运行的。比如我们尝试编译这样一个简单的二分查找C语言程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">21</span>, <span class=\"number\">34</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">binSearch</span><span class=\"params\">(<span class=\"type\">int</span> dest)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"type\">int</span> l=<span class=\"number\">0</span>, r=<span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"type\">int</span> result = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;=r)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[mid]&lt;dest)l=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(arr[mid]&gt;dest)r=mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = mid;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result == <span class=\"number\">-1</span>) result = l;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;=<span class=\"number\">35</span>;++i)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, binSearch(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的main函数反汇编后如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000000000001202 &lt;main&gt;:</span><br><span class=\"line\">    1202:\tf3 0f 1e fa          \tendbr64 </span><br><span class=\"line\">    1206:\t55                   \tpush   %rbp</span><br><span class=\"line\">    1207:\t48 89 e5             \tmov    %rsp,%rbp</span><br><span class=\"line\">    120a:\t48 83 ec 10          \tsub    $0x10,%rsp</span><br><span class=\"line\">    120e:\tc7 45 fc 00 00 00 00 \tmovl   $0x0,-0x4(%rbp)</span><br><span class=\"line\">    1215:\teb 21                \tjmp    1238 &lt;main+0x36&gt;</span><br><span class=\"line\">    1217:\t8b 45 fc             \tmov    -0x4(%rbp),%eax</span><br><span class=\"line\">    121a:\t89 c7                \tmov    %eax,%edi</span><br><span class=\"line\">    121c:\te8 48 ff ff ff       \tcall   1169 &lt;binSearch&gt;</span><br><span class=\"line\">    1221:\t89 c6                \tmov    %eax,%esi</span><br><span class=\"line\">    1223:\t48 8d 3d da 0d 00 00 \tlea    0xdda(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class=\"line\">    122a:\tb8 00 00 00 00       \tmov    $0x0,%eax</span><br><span class=\"line\">    122f:\te8 3c fe ff ff       \tcall   1070 &lt;printf@plt&gt;</span><br><span class=\"line\">    1234:\t83 45 fc 01          \taddl   $0x1,-0x4(%rbp)</span><br><span class=\"line\">    1238:\t83 7d fc 23          \tcmpl   $0x23,-0x4(%rbp)</span><br><span class=\"line\">    123c:\t7e d9                \tjle    1217 &lt;main+0x15&gt;</span><br><span class=\"line\">    123e:\tbf 0a 00 00 00       \tmov    $0xa,%edi</span><br><span class=\"line\">    1243:\te8 18 fe ff ff       \tcall   1060 &lt;putchar@plt&gt;</span><br><span class=\"line\">    1248:\t90                   \tnop</span><br><span class=\"line\">    1249:\tc9                   \tleave  </span><br><span class=\"line\">    124a:\tc3                   \tret    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>Problem 4.1</strong>\n在运行main函数时，内存-0x4(%rbp)处是什么？1217位置的mov语句是为了做什么？</p>\n<p><strong>Problem 4.2</strong>\n二分查找函数中我们使用了<code>register int</code>保留字，这告诉编译器要把变量存到寄存器而不是内存中，这样做有什么好处<sup>1</sup>？正因如此，在执行完二分查找函数中的<strong>算法部分</strong>，希望返回主函数时，能否直接修改%rip的值到1221而不做其他事情？还缺少什么步骤？</p>\n<blockquote>\n<p>[1]实际上在现代编译器中，你不需要自己手写register关键字。开启优化后，编译器会自动安排变量的位置，找到最优化的一种策略，这基本是现代编译器必备的操作。</p>\n</blockquote>\n<h3 id=\"上下文保存与恢复\">上下文保存与恢复</h3>\n<p>打开Linux终端，输入<code>top -H</code>指令（按下q退出），看看当前电脑上正在运行的线程有多少个？再输入<code>cat /proc/cpuinfo | grep processor</code>，看看你的电脑的CPU有多少个线程？</p>\n<p>在大部分情况下，系统中正在运行的线程数量都比CPU的线程数要多，但是你可以试试播放同时多个视频、音频、下载文件、编辑文档、QQ微信接收消息、显示动态壁纸……CPU可以“同时”做到这些事情。想要实现这个效果，自然不能让一个程序线程独占一个CPU，也就是——限制线程能连续在CPU上运行的时间，时间用完后<strong>切换</strong>到一个其它的线程继续运行。只要这个连续运行时间足够短，在我们看起来，电脑就是在同时进行所有工作。</p>\n<p>上面这段文字暗含了一些信息：电脑需要保存一个线程“<strong>执行到什么状态了</strong>”，这样它下次继续运行该线程时可以直接从暂停的位置继续。我们将这个<strong>执行的状态</strong>称之为<strong>上下文</strong>，这两种操作分别称为<strong>保存上下文</strong>和<strong>恢复上下文</strong>，记为save和restore。本实验我们将这些操作限制在同一个进程内，同学们不需要考虑硬件和操作系统层面的内容。</p>\n<p><strong>Problem 4.3</strong>\n结合Problem4.2，为了让程序能在跳转到指定位置后正常运行，我们除了修改%rip，还需要复原__的状态。所以，save操作需要将这些信息记录到内存中。</p>\n<p>我们在这里规定save操作不记录函数的栈帧。想象一下用户在函数中申请了一个16MB的数组，如果save记录栈帧，一次调用就需要将整个数组都复制一遍，低效且浪费空间。</p>\n<p>实际上，对于当前save和restore的定义，我们还有两个需要考虑的方面。对于如下的伪代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funcA:</span><br><span class=\"line\">    x = 0</span><br><span class=\"line\">    save()</span><br><span class=\"line\">    x = 1</span><br><span class=\"line\">    call funcB</span><br><span class=\"line\"></span><br><span class=\"line\">funcB:</span><br><span class=\"line\">    restore()</span><br></pre></td></tr></table></figure>\n<p><strong>Problem 4.4</strong>\n假如变量x被存放在栈帧上，在restore操作后，x的值为__；假如变量x被存放在寄存器上，在restore操作后，x的值为__。</p>\n<p>由于变量放在寄存器还是内存是由编译器决定的，根据编译器策略的不同，可能会导致同一份代码产生不同的运行结果。为了简化问题，我们可以做出如下限定：执行save语句的函数结束后，这一份save记录被销毁；我们规定在save语句后修改过的局部变量，在restore后都是未知的，让开发者不要在restore之后直接使用这些变量的值。</p>\n<p>此外还有一个问题。我们可以模拟这个过程：程序首先在funcA中save一次，调用funcB，restore后程序复原到save时的状态，又回到x=1这条指令。接下来程序又调用funcB，又执行一次restore，这显然不是我们所期望的。</p>\n<p>为了避免这种“循环”带来的错误，我们可以给save添加一个“返回值”。save记录时返回0，程序正常执行；而执行restore后，程序的执行位置同样会回到save的后一条语句，其表现也像是“在save后返回到该函数”。因此，只需要让此时save的返回值表现为非0，就能区分开save和restore，甚至还能用一些枚举值来表示“程序为什么调用了restore”。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funcA:</span><br><span class=\"line\">    x = 0</span><br><span class=\"line\">    if save() == 0:</span><br><span class=\"line\">        x = 1</span><br><span class=\"line\">        call funcB</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        return</span><br><span class=\"line\"></span><br><span class=\"line\">funcB:</span><br><span class=\"line\">    restore()</span><br></pre></td></tr></table></figure>\n<p>接下来，我们将通过汇编实现save和restore的功能（显然不考虑内联汇编的C语言难以实现这个功能），不过在此之前我们先着手用汇编语言写一个简单的函数吧。</p>\n<p><strong>Problem 4.3</strong>\n请用不超过5条汇编指令<sup>2</sup>实现函数naive_func，直接写在实验报告中。该函数的功能为：将函数的返回地址保存到第一个参数所指定的内存地址，然后返回0。可参考伪代码：\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">naive_func(void **p):</span><br><span class=\"line\">    *p = (return addr);</span><br><span class=\"line\">    return 0;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>[2]不计伪指令。如果可以，请在函数开头加上<code>endbr64</code>，正确做法下指令数量是足够的。</p>\n</blockquote>\n<p><strong>Problem 4.4</strong>\n也许你在课上学过函数开头两条指令的固定格式<code>push rbp; mov rbp, rsp</code>。但是前面所写的naive_func显然不遵循这样的格式，为什么这是可以的呢？</p>\n<p>接下来，我们开始着手实现save和restore函数，为了实现更多后续功能，这两个函数的定义与上文所述有略微不同，请参见API手册。</p>\n<p><strong>Task 4.1</strong>\n请在<code>context_asm.S</code>中实现函数<code>__ctx_save</code>和<code>__ctx_restore</code>，分别对应上文所述的save和restore操作。根据函数的定义，你需要仔细考虑哪些数据是需要存储到<code>__ctx</code>中的。你可以自行调整<code>__ctx</code>类型申请的内存大小，但是我们保证原始代码给出的120字节是足够的。如果一切顺利，在完成本节内容后，你将能通过\ntest1 和 test2。</p>\n<blockquote>\n<p>按照 x86-64 调用约定，rdi 和 rsi 分别为函数调用的第一二个参数，rax\n为函数调用的返回值。在默认情况下，gcc 使用 AT&amp;T\n汇编语法。如果你想要使用 Intel\n汇编语法，可以在ctx.S的开头加上一句.intel_syntax noprefix。 禁止使用\nsetjmp 或 __builtin_setjmp 等现成函数，但你也许可以参考它们的实现。</p>\n</blockquote>\n<h3 id=\"基于上下文回退的异常处理\">基于上下文回退的异常处理</h3>\n<p>现代编程语言基本都支持异常处理机制，即程序包含以try和catch（或except等关键字）开头的代码块，程序员可以将一些代码放到try代码块中，如果遇到除0错误或是其他一些错误，程序不是直接停止运行，而是跳转到catch后面继续运行。</p>\n<p>基于上一部分已经实现的两个操作，我们可以实现一个简单的异常处理机制，不妨参考下面的伪代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func():</span><br><span class=\"line\">    x = input</span><br><span class=\"line\">    if save() == 0:</span><br><span class=\"line\">        check(x)</span><br><span class=\"line\">        print(input / 2)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;Input is invalid&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">check(x):</span><br><span class=\"line\">    if not isdigit(x):</span><br><span class=\"line\">        recover(error_code)</span><br></pre></td></tr></table></figure>\n<p>这实际上等同于使用try-catch机制，它和下面的Python代码是基本等价的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">func</span>():</span><br><span class=\"line\">    x = <span class=\"built_in\">input</span>()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        check(x)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(x) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Input is invalid&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> x.isdigit():</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> Exception(<span class=\"string\">&quot;Input is invalid&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>借助C语言的宏，我们可以将原始含save和recover的代码包装成类似Python或者C++风格的代码。而且，try-catch是可以嵌套的。在发生try-catch嵌套时，程序中会同时存在许多个try记录的上下文。在执行throw操作时，我们需要恢复到最新的一个上下文，如下面的C++代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> Exception;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该代码会输出1。</p>\n<p>容易看出，这实际上就是一个栈的结构，我们将其称为异常处理栈。对于每个try操作，它记录当前的上下文，并将其加入异常处理栈。对于每个throw操作，它弹出异常处理栈中的栈顶元素，将当前状态恢复成该上下文，并转而执行catch操作。当然，清理也是必须的，对于每个正常完成的try操作，我们需要弹出异常处理栈中的栈顶元素，使之恢复到try操作之前的状态，如下面的代码则会输出2：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> Exception;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在本lab中，我们采用单向链表的方式来实现这个栈。在该Task中，你暂时不需要考虑<code>__generator</code>结构体的作用，只需要知道<code>__now_gen-&gt;__err_stk_head</code>是这个单向链表的表头，<code>__err_stk_node</code>结构体用于表示链表的节点。你需要实现<code>__err_stk_push</code>和<code>__err_stk_pop</code>两个函数来实现链表的操作，然后使用我们当前已实现的功能，填充<code>try</code>、<code>catch</code>和<code>throw</code>的宏定义<sup>3</sup>。</p>\n<blockquote>\n<p>[3]C语言提供了cleanup属性，被添加该属性的变量会在生命周期结束时执行对应的函数，可以理解为类似析构函数的功能，可参考https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html</p>\n</blockquote>\n<p><strong>Task 4.2</strong>\n请在<code>context.c</code>中实现函数<code>__err_stk_push</code>和<code>__err_stk_pop</code>，然后在<code>context.h</code>中实现<code>try</code>、<code>catch</code>和<code>throw</code>的宏定义。如果一切顺利，在完成本节内容后，你将能通过test3、test4和test5。</p>\n<h3 id=\"基于上下文切换的生成器协程\">基于上下文切换的生成器（协程）</h3>\n<p>如果你还不熟悉Python的生成器，可以试着跑一下以下程序，观察输出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    val = x</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>):</span><br><span class=\"line\">        val = <span class=\"keyword\">yield</span> val</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(val)</span><br><span class=\"line\">        val += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">gen = test(<span class=\"number\">1</span>)</span><br><span class=\"line\">array = [gen.send(<span class=\"literal\">None</span>)]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(array)</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    array.append(gen.send(array[-<span class=\"number\">1</span>]*<span class=\"number\">10</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(array)</span><br></pre></td></tr></table></figure>\n<p>这段代码里面有关键字<code>yield</code>和函数<code>send</code>。当gen被赋值为一个函数后，程序并没有执行该函数。而第一次调用<code>send</code>方法时，程序跳转到该函数的开头开始执行，执行到第一个<code>yield</code>关键字时，函数将<code>yield</code>后面的值作为<code>send</code>方法的返回值，恢复到主函数继续执行。下次<code>send</code>又被调用时，程序并不是在函数中从头开始，而是接着上次<code>yield</code>返回主函数的位置继续向后执行，且<code>send</code>的值在该函数看来就是<code>yield</code>的返回值。当<code>test</code>函数执行完毕后，程序会抛出一个异常。</p>\n<p>这似乎跟我们前面实现的保存上下文很像：<code>yield</code>保存了函数当前的上下文，返回主函数；<code>send</code>保存了主函数的上下文，恢复函数的上下文继续执行。看起来这个功能似乎很好实现？不过先让我们看看下面的伪代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">funcA:</span><br><span class=\"line\">    for i in 0..10:</span><br><span class=\"line\">    print(&quot;A&quot;, i);</span><br><span class=\"line\">    if(save(&amp;a) == 0):</span><br><span class=\"line\">        restore(&amp;b);</span><br><span class=\"line\"></span><br><span class=\"line\">funcB:</span><br><span class=\"line\">    for i in 0..10:</span><br><span class=\"line\">    print(&quot;B&quot;, i);</span><br><span class=\"line\">    if(save(&amp;b) == 0):</span><br><span class=\"line\">        restore(&amp;a)</span><br></pre></td></tr></table></figure>\n<p>容易看出，如果这段代码已经跑起来了，它可以交替执行 A、B\n两个循环，只要在此基础上包装出 yield 和 send 函数，即可达到与 Python\n中生成器一致的效果。但我们首先要解决一个问题：它是怎么跑起来的？</p>\n<p>请注意我们在之前提出的约定：函数返回之后，不能再使用其调用<code>save</code>保存的上下文。因此，要想使funcA中引用的ctx\nb有效，必须保证funcB不返回（保证不清除栈帧），这似乎只可能发生在funcB调用了funcA的情况下。但反过来，要想使funcB中引用的ctx\na有效，也必须保证funcA不返回（保证不清除栈帧），似乎只可能发生在funcA调用了funcB的情况下。</p>\n<p>上面的分析仿佛引出了一个悖论。事实上，这一悖论只会在funcA和funcB使用同一个调用栈的情况下成立。假如我们为funcA和funcB分配两个不同的栈空间，那么执行funcA时，funcB的栈帧保留在它自己的栈空间上，与funcA所在的栈空间并无关联，也就不需要调用关系来保证funcB不返回了。</p>\n<p>为了实现多个栈空间，我们可以手动申请一块内存，配置一段上下文，然后通过我们实现的restore函数让程序跳转到这一段内存开始执行函数，这样这个函数就有了一段独立的栈空间。</p>\n<p>总结一下这个过程：创建生成器时，程序申请一段内存，并在该内存中配置一段初始上下文，等待调用。当生成器第一次被调用时，恢复到这段初始上下文，开始执行生成器对应的函数，直到第一次遇到yield，保存当前生成器的上下文，回到调用该生成器的函数中。如果生成器的函数执行完毕，抛出一个<code>ERR_GENEND</code>异常。在已给出的<code>__generator</code>结构体中，我们使用<code>data</code>变量来传输<code>yield</code>和<code>send</code>的返回值。为方便起见，我们将主函数也视作一个generator（只不过你不需要手动给这个generator制作一个栈空间和初始上下文），因此全局变量<code>__now_gen</code>被初始化为了<code>&amp;__main_gen</code>，且每个generator都有自己的异常处理栈。</p>\n<p><strong>Task 4.3</strong>\n请在<code>context.c</code>中实现函数<code>send</code>、<code>yield</code>和<code>generator</code>（你可以理解为构造函数）。允许自行添加一些函数，因为你可能需要一些跳板函数来实现生成器的启动。你可能需要修改<code>throw</code>宏，以在外部处理生成器中未处理的<code>throw</code>。如果一切顺利，在完成本节内容后，你将能通过test6和test7。</p>\n<h3 id=\"协程的一些实际应用\">协程的一些实际应用</h3>\n<p>协程在现代应用程序中有广泛的应用。比如，手机程序向服务器请求数据时同时显示动画，就可以理解为本机的逻辑处理函数发送网络请求后，上下文恢复到主函数来显示动画，一旦服务器返回了数据，上下文又切换到逻辑处理函数来执行后续操作。这是非常节约资源的一个方法：开辟新线程来进行网络通信也可以达到相同的效果，但开辟新线程本身就会消耗一些系统资源，所以不是最优的选择。</p>\n<p>本Lab最后一个部分希望你能自定义一个基于协程的进度条动画。考虑我们平时玩的游戏，游戏画面本身也是多张图片连续快速播放，人眼看起来就变成了连贯的动画，这一过程可以用以下伪代码表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def game():</span><br><span class=\"line\">    record_time = get_time()</span><br><span class=\"line\"></span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        now_time = get_time()</span><br><span class=\"line\">        delta_time = now_time - record_time</span><br><span class=\"line\">        record_time = now_time</span><br><span class=\"line\"></span><br><span class=\"line\">        get_user_input()</span><br><span class=\"line\">        handle_events(delta_time)</span><br><span class=\"line\">        draw_scene()</span><br><span class=\"line\">        sleep_until_next_frame()</span><br></pre></td></tr></table></figure>\n<p>其中，<code>delta_time</code>代表游戏两帧之间间隔了多久，游戏场景里面的物件会根据这个时间间隔移动相应的距离。</p>\n<p>当需要给某游戏物件做一个持续若干秒的动画时，我们不能在某函数中写一个循环，每次移动一点物体，然后<code>sleep</code>若干毫秒，循环直到动画结束，这会导致在动画结束前都无法执行到其它代码，会阻碍其他游戏事件的进行。一种解决方法时，开启一个新的协程，每次主函数向协程<code>send(delta_time)</code>，协程就会根据时间变化量少量修改对应物体的坐标，然后<code>yield</code>回到主函数来执行其它代码，等待下一帧到来，主函数继续<code>send</code>，以此类推，直到动画结束。</p>\n<blockquote>\n<p>这是在如Unity等游戏引擎中一种典型的通过代码来制作物体动画的方法。</p>\n</blockquote>\n<p><strong>Task 4.4</strong>\n基于上面的讨论，请你完善<code>main.c</code>中的<code>progress_bar</code>函数，实现一个自定义的进度条动画。发挥你的想象力即可。</p>\n<p><img src=\"task3_result.gif\" /></p>\n<hr />\n<p>参考资料： - Kieray Lab from ICS 2022</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Deadline：2024-11-20 23:59:59</p>\n</blockquote>\n<h2 id=\"实验简介\">〇、实验简介</h2>\n<p>栈帧相关实验。</p>\n<p>本学期，我们将金老师ICS第三个Lab回炉重造，添加更多讲解，以加深各位同学对栈帧的理解，并探索一些相关应用，丰富同学们的知识面。</p>\n<p>本次Lab由三个部分组成：</p>\n<ul>\n<li>尝试在含有漏洞的程序中实现<strong>任意代码执行</strong></li>\n<li>学习 Canary 机制，了解栈溢出的防御</li>\n<li>尝试使用栈帧完成更多有意思的功能</li>\n</ul>\n<h2 id=\"一危险的计算器\">一、危险的计算器</h2>\n<h3 id=\"rce-攻击\">RCE 攻击</h3>\n<p>电影中的黑客神通广大，能神不知鬼不觉地“黑”掉各种计算机系统，他们是如何做到的？</p>\n<p>首先，我们需要认识一下“黑”掉一个系统到底是指什么，对于黑客来说，有许多种不同的攻击效果（或者说漏洞）：</p>\n<ul>\n<li>RCE (Remote Code\nExecution)：远程代码执行，即攻击者可以在远程服务器上执行任意代码；</li>\n<li>DoS (Denial of\nService)：拒绝服务，即攻击者可以让服务器无法正常工作；</li>\n<li>MITM\n(Man-In-The-Middle)：中间人攻击，即攻击者可以在通信过程中窃取信息；</li>\n<li>……</li>\n</ul>\n<p>其中，攻击者最为喜闻乐见的就是RCE，因为这意味着他们可以在服务器上执行任意程序代码，做任何自己想做的事。比如，他可以把网站服务器托管的网站的首页改成自己的名字；又比如，他可以在上面运行自己的挖矿程序，借用他人计算机的算力帮自己牟利。</p>\n<p>一个最简单的RCE漏洞形如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read(<span class=\"number\">0</span>, input, <span class=\"number\">20</span>);</span><br><span class=\"line\">system(input);</span><br></pre></td></tr></table></figure>\n<p>这段代码读取用户输入，并调用了 <code>system</code>\n函数。<code>system</code> 函数的功能是执行一条shell指令，比如\n<code>system(\"ls\")</code> 就会相当于在命令行上输入 <code>ls</code>\n以显示当前目录下的文件。</p>\n<p>这个程序在本地运行时，显然没什么问题，但如果这个 input\n字符串来源于网络，这意味着攻击者可以通过输入恶意指令来执行任意代码。比如，当类似于这段代码的程序运行在一个服务器上时，攻击者只要想办法控制input为\n<code>rm -rf /</code> 就可以删除服务器上的所有文件。</p>\n<p>所以，RCE 通常就是指“在目标机器上执行任意shell指令”。</p>\n<h3 id=\"栈溢出漏洞\">栈溢出漏洞</h3>\n<p>栈溢出漏洞是一种常见且经典的漏洞，破坏力非常强大——它经常可以使攻击者达成\nRCE。</p>\n<p>栈溢出漏洞在C语言当中非常常见，主要是因为使用 C\n语言时非常容易漏掉对数组边界和 buffer\n大小的检查。比如，下面这段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buffer[<span class=\"number\">20</span>];</span><br><span class=\"line\">gets(buffer);</span><br></pre></td></tr></table></figure>\n<p>这段代码使用了 <code>gets</code> 函数，它会读取用户输入并存储到\n<code>buffer</code> 中。然而，<code>gets</code>\n函数并不会检查用户输入的长度，如果用户输入的长度超过了\n<code>buffer</code>\n的大小，就会导致多余的数据“溢出”到栈上的其他位置，导致其他数据被干扰。这就是栈溢出的定义。</p>\n<h3 id=\"从栈溢出漏洞到劫持程序控制流\">从栈溢出漏洞到劫持程序控制流</h3>\n<p>之所以栈溢出漏洞如此危险，是因为它可以被利用来劫持程序的控制流。我们来回忆一下，栈上有哪些数据？</p>\n<p><img\nsrc=\"https://organicprogrammer.com/images/stack_contents.png\" /></p>\n<p>注意到，其中有一个重要的数据：返回地址。当函数调用结束时，程序会跳转到这个返回地址继续执行。</p>\n<p>如果攻击者栈溢出的数据控制了这个返回地址，他就可以决定程序接下来返回到哪里，从而控制程序的执行流程。</p>\n<h3 id=\"在劫持了程序控制流之后\">在劫持了程序控制流之后</h3>\n<p>“决定程序接下来执行哪个函数”，这听起来是不是很像我们之前说的RCE？没错，这就是栈溢出漏洞的危险之处：它可以被利用来实现任意代码执行。试想，如果程序中存在一个调用\n<code>system(\"/bin/sh\")</code>\n函数的地方，我们只需要把对应的地址填到栈上返回地址的位置，就可以控制程序去调用\n<code>system(\"/bin/sh\")</code>，从而获取一个 shell 达成 RCE。</p>\n<p>然而，并不是所有的程序都会调用 <code>system(\"/bin/sh\")</code>\n或是类似的函数，这种情况怎么办呢？我们现在仅仅能够控制程序接下来执行哪个地址的代码，离执行任意的shell指令还有一段距离。</p>\n<p>这个时候就需要进行“构造”了，攻击者在利用漏洞时，需要利用好一切可以利用的资源，包括但不限于：当前寄存器中的数据、内存中的机器码和数据等等。</p>\n<p>比如，我们知道 <code>rdi</code>\n寄存器是用来传递第一个参数的寄存器。如果我们劫持程序控制流到\n<code>foo(int a)</code> 函数，其实就相当于调用了\n<code>foo(&lt;当前rdi值&gt;)</code>。</p>\n<p>又比如，我们不一定要控制程序去返回到某个函数（的起始位置），而可以控制程序返回到某个函数的中间。如果有这样一个函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">foo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        system(<span class=\"string\">&quot;/bin/sh&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看上去这个函数没有任何用，因为它什么都不会干。但其中包含的\n<code>system(\"/bin/sh\")</code>\n片段可以为我们所用：我们可以直接控制程序执行 if 内的代码。</p>\n<h3 id=\"实验\">实验</h3>\n<p>在本次试验中，我们给出了一个简单但包含有漏洞的计算器程序，它会读取用户输入的表达式，包上\n<code>echo $(())</code> 后调用 <code>system</code>\n函数来计算表达式的结果。</p>\n<p>你的任务是：利用栈溢出漏洞，控制程序执行 <code>./malware</code>\n。这个“恶意程序”会检测自己的父进程调用，如果发现自己由\n<code>bash-calc</code> 调用，就会输出\n<code>You have successfully detonated the bomb! Congratulations!</code>，表示你已经成功完成了任务。</p>\n<h4 id=\"实验步骤\">实验步骤</h4>\n<ol type=\"1\">\n<li>阅读 <code>bash-calc.c</code>\n源代码，理解程序的逻辑，找到漏洞所在函数，计算出溢出所需要的字符数；</li>\n<li>使用 <code>gdb</code> 调试程序，将断点设置在漏洞所在函数的\n<code>ret</code> 语句处，观察此时各个寄存器的值；</li>\n<li>结合你的观察，构造一个恰当的 payload，使得程序执行\n<code>./malware</code>；</li>\n</ol>\n<h4 id=\"提示\">提示</h4>\n<ul>\n<li><p>不同输入函数的“截断”不同，截断指的是输入函数在读取到哪些字符时会停止读取。比如，<code>gets</code>\n函数会读取到换行符为止，所以它也会读入 <code>\\0</code>\n这种非常特殊的字符。具体可以参照 <a\nhref=\"https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/16/input/\">CTF中常见的C语言输入函数截断属性总结</a></p></li>\n<li><p>一个示例的构造payload的方法：</p></li>\n</ul>\n<p>假设buffer距离返回地址的偏移为0x10，且我们想让程序返回到地址\n<code>0x4005d6</code>，则我们可以编写一个如下的 Python 程序：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;A&#x27;</span> * <span class=\"number\">0x10</span> + <span class=\"string\">b&#x27;\\xd6\\x05\\x40\\x00\\x00\\x00\\x00\\x00&#x27;</span></span><br><span class=\"line\">sys.stdout.buffer.write(payload)</span><br></pre></td></tr></table></figure>\n<p>然后在终端中执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 payload.py | ./bash-calc</span><br></pre></td></tr></table></figure>\n<p>或者直接将 payload 写入文件，然后使用重定向机制：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 payload.py &gt; payload</span><br><span class=\"line\">./bash-calc &lt; payload</span><br></pre></td></tr></table></figure>\n<p>后者可以帮助你在使用gdb时更好地调试，比如在gdb中执行\n<code>run &lt; payload</code> 就可以使用终端的重定向语法。</p>\n<ul>\n<li>我们的目标类似于执行\n<code>system(\"./malware\")</code>，如果你已经构造成功了 payload\n使程序执行 <code>system(\"./malware\")</code>，但程序在\n<code>system</code> 函数的内部崩溃了，这在我们的预期内。</li>\n</ul>\n<p>造成这种情况的原因是：<code>system</code>\n内部某些汇编语句对栈的对齐要求很高，如果没有对齐至\n0x10，就会导致程序崩溃。如果你使用gdb进行调试，你就可以看到这几条非常“挑剔”的汇编指令。</p>\n<p>在正常执行一个函数时，<code>rsp</code> 寄存器是向 0x10\n对齐的；调用某一个函数时使用的是 <code>call</code>\n指令，会往栈上压入一个8字节的返回地址（这里就破坏了对齐），然后跳转到函数的起始位置。因此，每个函数都会假设自己刚刚被调用时，<code>rsp</code>\n寄存器是不向 0x10 对齐的。</p>\n<p>然而，我们通过劫持返回地址调用某个函数时，我们并没有使用\n<code>call</code>\n指令，而是直接跳转到了函数的开头。这就导致函数开始时，栈反而向 0x10\n对齐了，这破坏了 <code>system</code> 函数的假设，导致程序崩溃。</p>\n<p>解决办法很简单：<strong>不要直接调用 <code>system</code>\n函数，而是调用一个中间函数，并且跳过函数开头的一条 <code>push rbp</code>\n指令。</strong>这类似于手动破坏栈的对齐，使得 <code>system</code>\n函数可以正常执行。关于这个解决方法的原理分析，我们留作思考题。</p>\n<ul>\n<li>额外补充一个小技巧：在 system（或是命令行shell）中，你可以使用\n<code>#</code>\n符号注释掉不需要的内容。比如，<code>system(\"echo hello # echo world\")</code>\n只会输出 <code>hello</code>，而不会输出 <code>world</code>。</li>\n</ul>\n<h3 id=\"实验之后的思考题\">实验之后的思考题</h3>\n<p>除了在报告描述你的攻击流程之外，你还需要在报告中回答以下问题：</p>\n<p><strong>Problem 1.1</strong>\n实验任务中导致溢出的函数早就成为了一个臭名昭著的函数，现如今几乎没有人会再使用它。但即使在\n2024\n年的今天，我们依然会看到许许多多的栈溢出、堆溢出漏洞。请你思考一下，还有什么其他的场景、函数会导致溢出？你自己是否在编程中遇到过栈溢出的情况？</p>\n<p><strong>Problem 1.2</strong>\n提示中提到了一个解决方案：<strong>不要直接调用 <code>system</code>\n函数，而是调用一个中间函数，并且跳过函数开头的一条 <code>push rbp</code>\n指令。</strong>这类似于手动破坏栈的对齐，使得 <code>system</code>\n函数可以正常执行。请你思考一下，为什么这样做可以解决问题？</p>\n<h2 id=\"二栈溢出的防御\">二、栈溢出的防御</h2>\n<p>有一种针对于栈溢出的防御机制被广泛部署于各种软件中，也早已被作为编译器的默认选项。</p>\n<p>在这个任务中，我们需要你重新编译\n<code>bash-calc.c</code>，通过阅读汇编代码的方式，理解这种防御机制的原理。</p>\n<p>你可以使用这条指令来重新编译一个 <code>bash-calc-my</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -no-pie -o bash-calc-my bash-calc.c</span><br></pre></td></tr></table></figure>\n<p>在编译以后，你可以通过两种方式来探索这种防御机制：</p>\n<ol type=\"1\">\n<li>借助gdb动态调试，使用刚刚的 payload 攻击程序，观察程序的行为；</li>\n<li>借助objdump静态分析，观察程序新增加的汇编代码，通过搜索等手段理解其意义。</li>\n</ol>\n<p>你需要在实验报告中描述你对这种防御机制原理的理解，并尝试回答一个问题：</p>\n<p><strong>Problem 2.1</strong>\n这种防御机制是否能够彻底“防御”栈溢出漏洞？</p>\n<h2 id=\"三栈帧的更多应用协程\">三、栈帧的更多应用（协程）</h2>\n<p>在前两项任务中，我们已经加深了对程序运行时的栈帧的认识，接下来，我们使用栈帧和一定的汇编语言，来给C语言实现一些更加现代的功能吧。</p>\n<p>本实验文件位于Task3文件夹，可以使用<code>make clean &amp;&amp; make</code>来编译代码，使用<code>./program</code>来运行代码。</p>\n<h3 id=\"前言\">前言</h3>\n<blockquote>\n<p>本实验并不需要清晰地知道进程和线程的区别。你可以理解为一个进程可以开启多个线程，让CPU的不同核心同时计算不同的功能。</p>\n</blockquote>\n<p>如果在程序运行的过程中，我们直接将PC（%rip）的值修改到某个指定地址，那程序大概率是不能正常运行的。比如我们尝试编译这样一个简单的二分查找C语言程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">21</span>, <span class=\"number\">34</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">binSearch</span><span class=\"params\">(<span class=\"type\">int</span> dest)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"type\">int</span> l=<span class=\"number\">0</span>, r=<span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"type\">int</span> result = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;=r)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[mid]&lt;dest)l=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(arr[mid]&gt;dest)r=mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = mid;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result == <span class=\"number\">-1</span>) result = l;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;=<span class=\"number\">35</span>;++i)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, binSearch(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的main函数反汇编后如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000000000001202 &lt;main&gt;:</span><br><span class=\"line\">    1202:\tf3 0f 1e fa          \tendbr64 </span><br><span class=\"line\">    1206:\t55                   \tpush   %rbp</span><br><span class=\"line\">    1207:\t48 89 e5             \tmov    %rsp,%rbp</span><br><span class=\"line\">    120a:\t48 83 ec 10          \tsub    $0x10,%rsp</span><br><span class=\"line\">    120e:\tc7 45 fc 00 00 00 00 \tmovl   $0x0,-0x4(%rbp)</span><br><span class=\"line\">    1215:\teb 21                \tjmp    1238 &lt;main+0x36&gt;</span><br><span class=\"line\">    1217:\t8b 45 fc             \tmov    -0x4(%rbp),%eax</span><br><span class=\"line\">    121a:\t89 c7                \tmov    %eax,%edi</span><br><span class=\"line\">    121c:\te8 48 ff ff ff       \tcall   1169 &lt;binSearch&gt;</span><br><span class=\"line\">    1221:\t89 c6                \tmov    %eax,%esi</span><br><span class=\"line\">    1223:\t48 8d 3d da 0d 00 00 \tlea    0xdda(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class=\"line\">    122a:\tb8 00 00 00 00       \tmov    $0x0,%eax</span><br><span class=\"line\">    122f:\te8 3c fe ff ff       \tcall   1070 &lt;printf@plt&gt;</span><br><span class=\"line\">    1234:\t83 45 fc 01          \taddl   $0x1,-0x4(%rbp)</span><br><span class=\"line\">    1238:\t83 7d fc 23          \tcmpl   $0x23,-0x4(%rbp)</span><br><span class=\"line\">    123c:\t7e d9                \tjle    1217 &lt;main+0x15&gt;</span><br><span class=\"line\">    123e:\tbf 0a 00 00 00       \tmov    $0xa,%edi</span><br><span class=\"line\">    1243:\te8 18 fe ff ff       \tcall   1060 &lt;putchar@plt&gt;</span><br><span class=\"line\">    1248:\t90                   \tnop</span><br><span class=\"line\">    1249:\tc9                   \tleave  </span><br><span class=\"line\">    124a:\tc3                   \tret    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>Problem 4.1</strong>\n在运行main函数时，内存-0x4(%rbp)处是什么？1217位置的mov语句是为了做什么？</p>\n<p><strong>Problem 4.2</strong>\n二分查找函数中我们使用了<code>register int</code>保留字，这告诉编译器要把变量存到寄存器而不是内存中，这样做有什么好处<sup>1</sup>？正因如此，在执行完二分查找函数中的<strong>算法部分</strong>，希望返回主函数时，能否直接修改%rip的值到1221而不做其他事情？还缺少什么步骤？</p>\n<blockquote>\n<p>[1]实际上在现代编译器中，你不需要自己手写register关键字。开启优化后，编译器会自动安排变量的位置，找到最优化的一种策略，这基本是现代编译器必备的操作。</p>\n</blockquote>\n<h3 id=\"上下文保存与恢复\">上下文保存与恢复</h3>\n<p>打开Linux终端，输入<code>top -H</code>指令（按下q退出），看看当前电脑上正在运行的线程有多少个？再输入<code>cat /proc/cpuinfo | grep processor</code>，看看你的电脑的CPU有多少个线程？</p>\n<p>在大部分情况下，系统中正在运行的线程数量都比CPU的线程数要多，但是你可以试试播放同时多个视频、音频、下载文件、编辑文档、QQ微信接收消息、显示动态壁纸……CPU可以“同时”做到这些事情。想要实现这个效果，自然不能让一个程序线程独占一个CPU，也就是——限制线程能连续在CPU上运行的时间，时间用完后<strong>切换</strong>到一个其它的线程继续运行。只要这个连续运行时间足够短，在我们看起来，电脑就是在同时进行所有工作。</p>\n<p>上面这段文字暗含了一些信息：电脑需要保存一个线程“<strong>执行到什么状态了</strong>”，这样它下次继续运行该线程时可以直接从暂停的位置继续。我们将这个<strong>执行的状态</strong>称之为<strong>上下文</strong>，这两种操作分别称为<strong>保存上下文</strong>和<strong>恢复上下文</strong>，记为save和restore。本实验我们将这些操作限制在同一个进程内，同学们不需要考虑硬件和操作系统层面的内容。</p>\n<p><strong>Problem 4.3</strong>\n结合Problem4.2，为了让程序能在跳转到指定位置后正常运行，我们除了修改%rip，还需要复原__的状态。所以，save操作需要将这些信息记录到内存中。</p>\n<p>我们在这里规定save操作不记录函数的栈帧。想象一下用户在函数中申请了一个16MB的数组，如果save记录栈帧，一次调用就需要将整个数组都复制一遍，低效且浪费空间。</p>\n<p>实际上，对于当前save和restore的定义，我们还有两个需要考虑的方面。对于如下的伪代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funcA:</span><br><span class=\"line\">    x = 0</span><br><span class=\"line\">    save()</span><br><span class=\"line\">    x = 1</span><br><span class=\"line\">    call funcB</span><br><span class=\"line\"></span><br><span class=\"line\">funcB:</span><br><span class=\"line\">    restore()</span><br></pre></td></tr></table></figure>\n<p><strong>Problem 4.4</strong>\n假如变量x被存放在栈帧上，在restore操作后，x的值为__；假如变量x被存放在寄存器上，在restore操作后，x的值为__。</p>\n<p>由于变量放在寄存器还是内存是由编译器决定的，根据编译器策略的不同，可能会导致同一份代码产生不同的运行结果。为了简化问题，我们可以做出如下限定：执行save语句的函数结束后，这一份save记录被销毁；我们规定在save语句后修改过的局部变量，在restore后都是未知的，让开发者不要在restore之后直接使用这些变量的值。</p>\n<p>此外还有一个问题。我们可以模拟这个过程：程序首先在funcA中save一次，调用funcB，restore后程序复原到save时的状态，又回到x=1这条指令。接下来程序又调用funcB，又执行一次restore，这显然不是我们所期望的。</p>\n<p>为了避免这种“循环”带来的错误，我们可以给save添加一个“返回值”。save记录时返回0，程序正常执行；而执行restore后，程序的执行位置同样会回到save的后一条语句，其表现也像是“在save后返回到该函数”。因此，只需要让此时save的返回值表现为非0，就能区分开save和restore，甚至还能用一些枚举值来表示“程序为什么调用了restore”。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funcA:</span><br><span class=\"line\">    x = 0</span><br><span class=\"line\">    if save() == 0:</span><br><span class=\"line\">        x = 1</span><br><span class=\"line\">        call funcB</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        return</span><br><span class=\"line\"></span><br><span class=\"line\">funcB:</span><br><span class=\"line\">    restore()</span><br></pre></td></tr></table></figure>\n<p>接下来，我们将通过汇编实现save和restore的功能（显然不考虑内联汇编的C语言难以实现这个功能），不过在此之前我们先着手用汇编语言写一个简单的函数吧。</p>\n<p><strong>Problem 4.3</strong>\n请用不超过5条汇编指令<sup>2</sup>实现函数naive_func，直接写在实验报告中。该函数的功能为：将函数的返回地址保存到第一个参数所指定的内存地址，然后返回0。可参考伪代码：\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">naive_func(void **p):</span><br><span class=\"line\">    *p = (return addr);</span><br><span class=\"line\">    return 0;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>[2]不计伪指令。如果可以，请在函数开头加上<code>endbr64</code>，正确做法下指令数量是足够的。</p>\n</blockquote>\n<p><strong>Problem 4.4</strong>\n也许你在课上学过函数开头两条指令的固定格式<code>push rbp; mov rbp, rsp</code>。但是前面所写的naive_func显然不遵循这样的格式，为什么这是可以的呢？</p>\n<p>接下来，我们开始着手实现save和restore函数，为了实现更多后续功能，这两个函数的定义与上文所述有略微不同，请参见API手册。</p>\n<p><strong>Task 4.1</strong>\n请在<code>context_asm.S</code>中实现函数<code>__ctx_save</code>和<code>__ctx_restore</code>，分别对应上文所述的save和restore操作。根据函数的定义，你需要仔细考虑哪些数据是需要存储到<code>__ctx</code>中的。你可以自行调整<code>__ctx</code>类型申请的内存大小，但是我们保证原始代码给出的120字节是足够的。如果一切顺利，在完成本节内容后，你将能通过\ntest1 和 test2。</p>\n<blockquote>\n<p>按照 x86-64 调用约定，rdi 和 rsi 分别为函数调用的第一二个参数，rax\n为函数调用的返回值。在默认情况下，gcc 使用 AT&amp;T\n汇编语法。如果你想要使用 Intel\n汇编语法，可以在ctx.S的开头加上一句.intel_syntax noprefix。 禁止使用\nsetjmp 或 __builtin_setjmp 等现成函数，但你也许可以参考它们的实现。</p>\n</blockquote>\n<h3 id=\"基于上下文回退的异常处理\">基于上下文回退的异常处理</h3>\n<p>现代编程语言基本都支持异常处理机制，即程序包含以try和catch（或except等关键字）开头的代码块，程序员可以将一些代码放到try代码块中，如果遇到除0错误或是其他一些错误，程序不是直接停止运行，而是跳转到catch后面继续运行。</p>\n<p>基于上一部分已经实现的两个操作，我们可以实现一个简单的异常处理机制，不妨参考下面的伪代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func():</span><br><span class=\"line\">    x = input</span><br><span class=\"line\">    if save() == 0:</span><br><span class=\"line\">        check(x)</span><br><span class=\"line\">        print(input / 2)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;Input is invalid&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">check(x):</span><br><span class=\"line\">    if not isdigit(x):</span><br><span class=\"line\">        recover(error_code)</span><br></pre></td></tr></table></figure>\n<p>这实际上等同于使用try-catch机制，它和下面的Python代码是基本等价的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">func</span>():</span><br><span class=\"line\">    x = <span class=\"built_in\">input</span>()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        check(x)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(x) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Input is invalid&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> x.isdigit():</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> Exception(<span class=\"string\">&quot;Input is invalid&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>借助C语言的宏，我们可以将原始含save和recover的代码包装成类似Python或者C++风格的代码。而且，try-catch是可以嵌套的。在发生try-catch嵌套时，程序中会同时存在许多个try记录的上下文。在执行throw操作时，我们需要恢复到最新的一个上下文，如下面的C++代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> Exception;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该代码会输出1。</p>\n<p>容易看出，这实际上就是一个栈的结构，我们将其称为异常处理栈。对于每个try操作，它记录当前的上下文，并将其加入异常处理栈。对于每个throw操作，它弹出异常处理栈中的栈顶元素，将当前状态恢复成该上下文，并转而执行catch操作。当然，清理也是必须的，对于每个正常完成的try操作，我们需要弹出异常处理栈中的栈顶元素，使之恢复到try操作之前的状态，如下面的代码则会输出2：\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> Exception;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在本lab中，我们采用单向链表的方式来实现这个栈。在该Task中，你暂时不需要考虑<code>__generator</code>结构体的作用，只需要知道<code>__now_gen-&gt;__err_stk_head</code>是这个单向链表的表头，<code>__err_stk_node</code>结构体用于表示链表的节点。你需要实现<code>__err_stk_push</code>和<code>__err_stk_pop</code>两个函数来实现链表的操作，然后使用我们当前已实现的功能，填充<code>try</code>、<code>catch</code>和<code>throw</code>的宏定义<sup>3</sup>。</p>\n<blockquote>\n<p>[3]C语言提供了cleanup属性，被添加该属性的变量会在生命周期结束时执行对应的函数，可以理解为类似析构函数的功能，可参考https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html</p>\n</blockquote>\n<p><strong>Task 4.2</strong>\n请在<code>context.c</code>中实现函数<code>__err_stk_push</code>和<code>__err_stk_pop</code>，然后在<code>context.h</code>中实现<code>try</code>、<code>catch</code>和<code>throw</code>的宏定义。如果一切顺利，在完成本节内容后，你将能通过test3、test4和test5。</p>\n<h3 id=\"基于上下文切换的生成器协程\">基于上下文切换的生成器（协程）</h3>\n<p>如果你还不熟悉Python的生成器，可以试着跑一下以下程序，观察输出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    val = x</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>):</span><br><span class=\"line\">        val = <span class=\"keyword\">yield</span> val</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(val)</span><br><span class=\"line\">        val += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">gen = test(<span class=\"number\">1</span>)</span><br><span class=\"line\">array = [gen.send(<span class=\"literal\">None</span>)]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(array)</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    array.append(gen.send(array[-<span class=\"number\">1</span>]*<span class=\"number\">10</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(array)</span><br></pre></td></tr></table></figure>\n<p>这段代码里面有关键字<code>yield</code>和函数<code>send</code>。当gen被赋值为一个函数后，程序并没有执行该函数。而第一次调用<code>send</code>方法时，程序跳转到该函数的开头开始执行，执行到第一个<code>yield</code>关键字时，函数将<code>yield</code>后面的值作为<code>send</code>方法的返回值，恢复到主函数继续执行。下次<code>send</code>又被调用时，程序并不是在函数中从头开始，而是接着上次<code>yield</code>返回主函数的位置继续向后执行，且<code>send</code>的值在该函数看来就是<code>yield</code>的返回值。当<code>test</code>函数执行完毕后，程序会抛出一个异常。</p>\n<p>这似乎跟我们前面实现的保存上下文很像：<code>yield</code>保存了函数当前的上下文，返回主函数；<code>send</code>保存了主函数的上下文，恢复函数的上下文继续执行。看起来这个功能似乎很好实现？不过先让我们看看下面的伪代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">funcA:</span><br><span class=\"line\">    for i in 0..10:</span><br><span class=\"line\">    print(&quot;A&quot;, i);</span><br><span class=\"line\">    if(save(&amp;a) == 0):</span><br><span class=\"line\">        restore(&amp;b);</span><br><span class=\"line\"></span><br><span class=\"line\">funcB:</span><br><span class=\"line\">    for i in 0..10:</span><br><span class=\"line\">    print(&quot;B&quot;, i);</span><br><span class=\"line\">    if(save(&amp;b) == 0):</span><br><span class=\"line\">        restore(&amp;a)</span><br></pre></td></tr></table></figure>\n<p>容易看出，如果这段代码已经跑起来了，它可以交替执行 A、B\n两个循环，只要在此基础上包装出 yield 和 send 函数，即可达到与 Python\n中生成器一致的效果。但我们首先要解决一个问题：它是怎么跑起来的？</p>\n<p>请注意我们在之前提出的约定：函数返回之后，不能再使用其调用<code>save</code>保存的上下文。因此，要想使funcA中引用的ctx\nb有效，必须保证funcB不返回（保证不清除栈帧），这似乎只可能发生在funcB调用了funcA的情况下。但反过来，要想使funcB中引用的ctx\na有效，也必须保证funcA不返回（保证不清除栈帧），似乎只可能发生在funcA调用了funcB的情况下。</p>\n<p>上面的分析仿佛引出了一个悖论。事实上，这一悖论只会在funcA和funcB使用同一个调用栈的情况下成立。假如我们为funcA和funcB分配两个不同的栈空间，那么执行funcA时，funcB的栈帧保留在它自己的栈空间上，与funcA所在的栈空间并无关联，也就不需要调用关系来保证funcB不返回了。</p>\n<p>为了实现多个栈空间，我们可以手动申请一块内存，配置一段上下文，然后通过我们实现的restore函数让程序跳转到这一段内存开始执行函数，这样这个函数就有了一段独立的栈空间。</p>\n<p>总结一下这个过程：创建生成器时，程序申请一段内存，并在该内存中配置一段初始上下文，等待调用。当生成器第一次被调用时，恢复到这段初始上下文，开始执行生成器对应的函数，直到第一次遇到yield，保存当前生成器的上下文，回到调用该生成器的函数中。如果生成器的函数执行完毕，抛出一个<code>ERR_GENEND</code>异常。在已给出的<code>__generator</code>结构体中，我们使用<code>data</code>变量来传输<code>yield</code>和<code>send</code>的返回值。为方便起见，我们将主函数也视作一个generator（只不过你不需要手动给这个generator制作一个栈空间和初始上下文），因此全局变量<code>__now_gen</code>被初始化为了<code>&amp;__main_gen</code>，且每个generator都有自己的异常处理栈。</p>\n<p><strong>Task 4.3</strong>\n请在<code>context.c</code>中实现函数<code>send</code>、<code>yield</code>和<code>generator</code>（你可以理解为构造函数）。允许自行添加一些函数，因为你可能需要一些跳板函数来实现生成器的启动。你可能需要修改<code>throw</code>宏，以在外部处理生成器中未处理的<code>throw</code>。如果一切顺利，在完成本节内容后，你将能通过test6和test7。</p>\n<h3 id=\"协程的一些实际应用\">协程的一些实际应用</h3>\n<p>协程在现代应用程序中有广泛的应用。比如，手机程序向服务器请求数据时同时显示动画，就可以理解为本机的逻辑处理函数发送网络请求后，上下文恢复到主函数来显示动画，一旦服务器返回了数据，上下文又切换到逻辑处理函数来执行后续操作。这是非常节约资源的一个方法：开辟新线程来进行网络通信也可以达到相同的效果，但开辟新线程本身就会消耗一些系统资源，所以不是最优的选择。</p>\n<p>本Lab最后一个部分希望你能自定义一个基于协程的进度条动画。考虑我们平时玩的游戏，游戏画面本身也是多张图片连续快速播放，人眼看起来就变成了连贯的动画，这一过程可以用以下伪代码表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def game():</span><br><span class=\"line\">    record_time = get_time()</span><br><span class=\"line\"></span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        now_time = get_time()</span><br><span class=\"line\">        delta_time = now_time - record_time</span><br><span class=\"line\">        record_time = now_time</span><br><span class=\"line\"></span><br><span class=\"line\">        get_user_input()</span><br><span class=\"line\">        handle_events(delta_time)</span><br><span class=\"line\">        draw_scene()</span><br><span class=\"line\">        sleep_until_next_frame()</span><br></pre></td></tr></table></figure>\n<p>其中，<code>delta_time</code>代表游戏两帧之间间隔了多久，游戏场景里面的物件会根据这个时间间隔移动相应的距离。</p>\n<p>当需要给某游戏物件做一个持续若干秒的动画时，我们不能在某函数中写一个循环，每次移动一点物体，然后<code>sleep</code>若干毫秒，循环直到动画结束，这会导致在动画结束前都无法执行到其它代码，会阻碍其他游戏事件的进行。一种解决方法时，开启一个新的协程，每次主函数向协程<code>send(delta_time)</code>，协程就会根据时间变化量少量修改对应物体的坐标，然后<code>yield</code>回到主函数来执行其它代码，等待下一帧到来，主函数继续<code>send</code>，以此类推，直到动画结束。</p>\n<blockquote>\n<p>这是在如Unity等游戏引擎中一种典型的通过代码来制作物体动画的方法。</p>\n</blockquote>\n<p><strong>Task 4.4</strong>\n基于上面的讨论，请你完善<code>main.c</code>中的<code>progress_bar</code>函数，实现一个自定义的进度条动画。发挥你的想象力即可。</p>\n<p><img src=\"task3_result.gif\" /></p>\n<hr />\n<p>参考资料： - Kieray Lab from ICS 2022</p>\n"},{"title":"DataLab","_content":"\n> Deadline: 2024.10.10 8:00AM\n\n## 一、实验简介\n\nCSAPP 第一章配套实验。\n\n本实验的目的是加深同学们对整数和浮点数二进制表示的认识。同学们需要解出若干程序谜题，编写代码并通过正确性测试，最后提交代码和报告。希望同学们多加思考，在解题过程中能学到的远不止二进制本身，还能加深对位运算的理解，以及学到一些算法知识。\n\n本实验分为常规部和荣誉部分。荣誉部分的难度较高，是本课程比较有挑战性的部分。\n\n荣誉部分虽然占分，但是占分并不高，大家可以自己决定要不要做荣誉部分。Use your discretion！\n\n\n\n## 二、部署实验环境\n\n### （1）下载\n\n从 `github classroom` 拉取`ICS2024_datalab` 文件夹，其中的内容就是本次实验用到的的文件了，拉取指令如下：\n\n```shell\ngit clone xxx  # 将 xxx 替换为对应链接\ncd ICS2024_datalab\n```\n\n### （2）准备工作\n\n#### - 确保已安装了 gcc\n\n在终端中检查是否安装了 gcc：\n\n```shell\ngcc -v\n```\n\n如果已安装，终端将会反馈版本信息，否则会反馈 `command not found` 。\n\n如未安装，尝试执行以下命令进行安装：\n\n```shell\nsudo apt-get install gcc\n```\n\n\n\n#### - 确保已安装了 make\n\n检查是否安装 make，在终端输入：\n\n```shell\nmake -v\n```\n\n同理，如未安装，尝试以此执行以下命令：\n\n```shell\nsudo apt-get update\nsudo apt-get install make\nsudo apt-get install libc6 libc6-dev libc6-dev-i386\n```\n\n\n\n#### - 确保实验文件能正常 make 并运行测试\n\n在终端中进入 `datalab/`  文件夹目录。\n\n键入 `ls` 查看内容，你应当看到如下文件：\n\n```shell\nDriverhdrs.pm  Makefile  bits.c  btest.c  decl.c  driver.pl  ishow.c\nDriverlib.pm   README    bits.h  btest.h  dlc     fshow.c    tests.c\n```\n\n在终端中依次执行如下命令，以生成可执行文件并执行：\n\n```shell\nmake clean\nmake all\n./btest\n```\n\n如果过程顺利，最后会输出测试结果，最后一行为 `Total points: 0/69` 。\n\n如果过程中出现如下报错：\n\n```shell\n/usr/bin/ld: cannot found -lgcc\n```\n\n那么尝试执行：\n\n```shell\nsudo apt install gcc-multilib\n```\n\n\n\n#### - 确保 dlc（data lab compiler）能正常执行\n\n依然在 `datalab/`  目录下，\n\n执行：\n\n```shell\n./dlc bits.c\n```\n\n如果遇到 `./dlc: Permission denied`，说明没有当前文件的执行权限，执行:\n```shell\nchmod +x dlc\n```\n增加执行权限。\n\n如果执行立即结束并且没有任何反馈，则没有问题。\n\n\n\n## 三、实验提示与说明\n\n### （1）如何入手\n\n推荐阅读顺序：本文档 > `README` > `bits.c` 的注释部分。\n\n`README` 文档中对实验文件做了较为详细的介绍。\n\n`bits.c` 是同学们唯一需要编辑的文件，其中包含了谜题规则介绍， 18 个谜题以及谜题内容、难度、分数等。\n\n上面的两个文件请务必仔细阅读。\n\n\n\n注意到，每一个谜题包含了如下信息：\n\n* 能使用的运算符。\n* 能使用的运算符总数量。\n* 能使用的常数的值域范围。\n* 变量类型。\n* 能否使用控制语句（如 `if` ）等。\n\n\n\n### （2）测试\n\n* 除了 `bits.c` ，你不应该编辑任何其余文件。\n\n* 完成谜题后，需要检验自己的代码是否正确：\n\n  * 首先，执行下述指令，检查每个函数使用的运算符类型、数目是否符合要求：\n\n  * ```shell\n    ./dlc -e bits.c\n    ```\n\n  * 如没有任何报错，按顺序执行下述指令，测试每个函数的正确性：\n\n  * ```shell\n    make clean\n    make all\n    ./btest\n    ```\n\n  * `btest` 执行时会给出每个谜题（函数）是否通过测试（未通过时会给出测试数据），并且会计算你的最终得分。\n\n* 你可以利用上 `./ishow` 和 `./fshow` 来帮助你调试（用法见 `README`）。\n\n\n\n## 四、提交实验\n\n### （1）内容要求\n\n你需要提交至少两份文件，包含你的 `bits.c` 和一份实验报告。\n\n实验报告应该包含以下内容：\n\n* 实验标题，你的姓名，学号。\n\n* 你在终端中执行 `./dlc -e bits.c` 后的截图。\n* 你在终端中执行 `./btest` 后的截图。\n* 描述你实现每个函数的思路。bits.c中不要求给自己的代码写注释（写了也无妨）\n* 如果有，请务必在报告中列出引用的内容以及参考的资料。\n* 对本实验的感受（可选）。\n* 对助教们的建议（可选）。\n\n### （2）格式要求\n\n可提交 `.md` 文件或者 `.pdf` 文件。不要提交 `.doc` 或 `.docx` 文件。  \n（如果提交 `.md` 文件，请确保助教能同时看到你报告中的截图！）\n\n### （3）上传\n\n在终端运行以下指令：\n\n```shell\ngit add -A\n# 提交当前文件夹下的所有更改到暂存区\ngit commit -m \"xxx(可以是你的提交注释)\"\n# 将暂存区的所有更改提交到本地仓库\ngit push\n# 将本地仓库推送到远程\n```\n\n### （4）打分规则\n\n* 实验报告要求简洁清晰，不必追求字数，描述清楚思路即可\n* 对每道谜题请先做思考，不要立即使用搜索引擎。\n* 不允许抄袭其它人的代码，一旦发现，零分处理。\n\n\n\n## 五、参考资料\n\n* http://csapp.cs.cmu.edu/3e/labs.html （lab 来源，本实验相较原文件有改动）\n\n* 本文档编写时参考了22, 23年的实验文档。\n\n* 负责助教:\n  * 伊凡 21307130047@m.fudan.edu.cn\n  * 李增昊 22307130108@m.fudan.edu.cn\n","source":"_posts/DataLab/tmp.md","raw":"---\ntitle: DataLab\n---\n\n> Deadline: 2024.10.10 8:00AM\n\n## 一、实验简介\n\nCSAPP 第一章配套实验。\n\n本实验的目的是加深同学们对整数和浮点数二进制表示的认识。同学们需要解出若干程序谜题，编写代码并通过正确性测试，最后提交代码和报告。希望同学们多加思考，在解题过程中能学到的远不止二进制本身，还能加深对位运算的理解，以及学到一些算法知识。\n\n本实验分为常规部和荣誉部分。荣誉部分的难度较高，是本课程比较有挑战性的部分。\n\n荣誉部分虽然占分，但是占分并不高，大家可以自己决定要不要做荣誉部分。Use your discretion！\n\n\n\n## 二、部署实验环境\n\n### （1）下载\n\n从 `github classroom` 拉取`ICS2024_datalab` 文件夹，其中的内容就是本次实验用到的的文件了，拉取指令如下：\n\n```shell\ngit clone xxx  # 将 xxx 替换为对应链接\ncd ICS2024_datalab\n```\n\n### （2）准备工作\n\n#### - 确保已安装了 gcc\n\n在终端中检查是否安装了 gcc：\n\n```shell\ngcc -v\n```\n\n如果已安装，终端将会反馈版本信息，否则会反馈 `command not found` 。\n\n如未安装，尝试执行以下命令进行安装：\n\n```shell\nsudo apt-get install gcc\n```\n\n\n\n#### - 确保已安装了 make\n\n检查是否安装 make，在终端输入：\n\n```shell\nmake -v\n```\n\n同理，如未安装，尝试以此执行以下命令：\n\n```shell\nsudo apt-get update\nsudo apt-get install make\nsudo apt-get install libc6 libc6-dev libc6-dev-i386\n```\n\n\n\n#### - 确保实验文件能正常 make 并运行测试\n\n在终端中进入 `datalab/`  文件夹目录。\n\n键入 `ls` 查看内容，你应当看到如下文件：\n\n```shell\nDriverhdrs.pm  Makefile  bits.c  btest.c  decl.c  driver.pl  ishow.c\nDriverlib.pm   README    bits.h  btest.h  dlc     fshow.c    tests.c\n```\n\n在终端中依次执行如下命令，以生成可执行文件并执行：\n\n```shell\nmake clean\nmake all\n./btest\n```\n\n如果过程顺利，最后会输出测试结果，最后一行为 `Total points: 0/69` 。\n\n如果过程中出现如下报错：\n\n```shell\n/usr/bin/ld: cannot found -lgcc\n```\n\n那么尝试执行：\n\n```shell\nsudo apt install gcc-multilib\n```\n\n\n\n#### - 确保 dlc（data lab compiler）能正常执行\n\n依然在 `datalab/`  目录下，\n\n执行：\n\n```shell\n./dlc bits.c\n```\n\n如果遇到 `./dlc: Permission denied`，说明没有当前文件的执行权限，执行:\n```shell\nchmod +x dlc\n```\n增加执行权限。\n\n如果执行立即结束并且没有任何反馈，则没有问题。\n\n\n\n## 三、实验提示与说明\n\n### （1）如何入手\n\n推荐阅读顺序：本文档 > `README` > `bits.c` 的注释部分。\n\n`README` 文档中对实验文件做了较为详细的介绍。\n\n`bits.c` 是同学们唯一需要编辑的文件，其中包含了谜题规则介绍， 18 个谜题以及谜题内容、难度、分数等。\n\n上面的两个文件请务必仔细阅读。\n\n\n\n注意到，每一个谜题包含了如下信息：\n\n* 能使用的运算符。\n* 能使用的运算符总数量。\n* 能使用的常数的值域范围。\n* 变量类型。\n* 能否使用控制语句（如 `if` ）等。\n\n\n\n### （2）测试\n\n* 除了 `bits.c` ，你不应该编辑任何其余文件。\n\n* 完成谜题后，需要检验自己的代码是否正确：\n\n  * 首先，执行下述指令，检查每个函数使用的运算符类型、数目是否符合要求：\n\n  * ```shell\n    ./dlc -e bits.c\n    ```\n\n  * 如没有任何报错，按顺序执行下述指令，测试每个函数的正确性：\n\n  * ```shell\n    make clean\n    make all\n    ./btest\n    ```\n\n  * `btest` 执行时会给出每个谜题（函数）是否通过测试（未通过时会给出测试数据），并且会计算你的最终得分。\n\n* 你可以利用上 `./ishow` 和 `./fshow` 来帮助你调试（用法见 `README`）。\n\n\n\n## 四、提交实验\n\n### （1）内容要求\n\n你需要提交至少两份文件，包含你的 `bits.c` 和一份实验报告。\n\n实验报告应该包含以下内容：\n\n* 实验标题，你的姓名，学号。\n\n* 你在终端中执行 `./dlc -e bits.c` 后的截图。\n* 你在终端中执行 `./btest` 后的截图。\n* 描述你实现每个函数的思路。bits.c中不要求给自己的代码写注释（写了也无妨）\n* 如果有，请务必在报告中列出引用的内容以及参考的资料。\n* 对本实验的感受（可选）。\n* 对助教们的建议（可选）。\n\n### （2）格式要求\n\n可提交 `.md` 文件或者 `.pdf` 文件。不要提交 `.doc` 或 `.docx` 文件。  \n（如果提交 `.md` 文件，请确保助教能同时看到你报告中的截图！）\n\n### （3）上传\n\n在终端运行以下指令：\n\n```shell\ngit add -A\n# 提交当前文件夹下的所有更改到暂存区\ngit commit -m \"xxx(可以是你的提交注释)\"\n# 将暂存区的所有更改提交到本地仓库\ngit push\n# 将本地仓库推送到远程\n```\n\n### （4）打分规则\n\n* 实验报告要求简洁清晰，不必追求字数，描述清楚思路即可\n* 对每道谜题请先做思考，不要立即使用搜索引擎。\n* 不允许抄袭其它人的代码，一旦发现，零分处理。\n\n\n\n## 五、参考资料\n\n* http://csapp.cs.cmu.edu/3e/labs.html （lab 来源，本实验相较原文件有改动）\n\n* 本文档编写时参考了22, 23年的实验文档。\n\n* 负责助教:\n  * 伊凡 21307130047@m.fudan.edu.cn\n  * 李增昊 22307130108@m.fudan.edu.cn\n","slug":"DataLab/tmp","published":1,"date":"2024-09-25T13:47:12.345Z","updated":"2024-09-25T13:47:12.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2yhehkn0007rzx44gaef3qw","content":"<blockquote>\n<p>Deadline: 2024.10.10 8:00AM</p>\n</blockquote>\n<h2 id=\"一实验简介\">一、实验简介</h2>\n<p>CSAPP 第一章配套实验。</p>\n<p>本实验的目的是加深同学们对整数和浮点数二进制表示的认识。同学们需要解出若干程序谜题，编写代码并通过正确性测试，最后提交代码和报告。希望同学们多加思考，在解题过程中能学到的远不止二进制本身，还能加深对位运算的理解，以及学到一些算法知识。</p>\n<p>本实验分为常规部和荣誉部分。荣誉部分的难度较高，是本课程比较有挑战性的部分。</p>\n<p>荣誉部分虽然占分，但是占分并不高，大家可以自己决定要不要做荣誉部分。Use\nyour discretion！</p>\n<h2 id=\"二部署实验环境\">二、部署实验环境</h2>\n<h3 id=\"下载\">（1）下载</h3>\n<p>从 <code>github classroom</code> 拉取<code>ICS2024_datalab</code>\n文件夹，其中的内容就是本次实验用到的的文件了，拉取指令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone xxx  # 将 xxx 替换为对应链接</span><br><span class=\"line\">cd ICS2024_datalab</span><br></pre></td></tr></table></figure>\n<h3 id=\"准备工作\">（2）准备工作</h3>\n<h4 id=\"确保已安装了-gcc\">- 确保已安装了 gcc</h4>\n<p>在终端中检查是否安装了 gcc：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -v</span><br></pre></td></tr></table></figure>\n<p>如果已安装，终端将会反馈版本信息，否则会反馈\n<code>command not found</code> 。</p>\n<p>如未安装，尝试执行以下命令进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gcc</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保已安装了-make\">- 确保已安装了 make</h4>\n<p>检查是否安装 make，在终端输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make -v</span><br></pre></td></tr></table></figure>\n<p>同理，如未安装，尝试以此执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install make</span><br><span class=\"line\">sudo apt-get install libc6 libc6-dev libc6-dev-i386</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保实验文件能正常-make-并运行测试\">- 确保实验文件能正常 make\n并运行测试</h4>\n<p>在终端中进入 <code>datalab/</code> 文件夹目录。</p>\n<p>键入 <code>ls</code> 查看内容，你应当看到如下文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Driverhdrs.pm  Makefile  bits.c  btest.c  decl.c  driver.pl  ishow.c</span><br><span class=\"line\">Driverlib.pm   README    bits.h  btest.h  dlc     fshow.c    tests.c</span><br></pre></td></tr></table></figure>\n<p>在终端中依次执行如下命令，以生成可执行文件并执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make clean</span><br><span class=\"line\">make all</span><br><span class=\"line\">./btest</span><br></pre></td></tr></table></figure>\n<p>如果过程顺利，最后会输出测试结果，最后一行为\n<code>Total points: 0/69</code> 。</p>\n<p>如果过程中出现如下报错：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ld: cannot found -lgcc</span><br></pre></td></tr></table></figure>\n<p>那么尝试执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install gcc-multilib</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保-dlcdata-lab-compiler能正常执行\">- 确保 dlc（data lab\ncompiler）能正常执行</h4>\n<p>依然在 <code>datalab/</code> 目录下，</p>\n<p>执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./dlc bits.c</span><br></pre></td></tr></table></figure>\n<p>如果遇到\n<code>./dlc: Permission denied</code>，说明没有当前文件的执行权限，执行:\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x dlc</span><br></pre></td></tr></table></figure> 增加执行权限。</p>\n<p>如果执行立即结束并且没有任何反馈，则没有问题。</p>\n<h2 id=\"三实验提示与说明\">三、实验提示与说明</h2>\n<h3 id=\"如何入手\">（1）如何入手</h3>\n<p>推荐阅读顺序：本文档 &gt; <code>README</code> &gt;\n<code>bits.c</code> 的注释部分。</p>\n<p><code>README</code> 文档中对实验文件做了较为详细的介绍。</p>\n<p><code>bits.c</code>\n是同学们唯一需要编辑的文件，其中包含了谜题规则介绍， 18\n个谜题以及谜题内容、难度、分数等。</p>\n<p>上面的两个文件请务必仔细阅读。</p>\n<p>注意到，每一个谜题包含了如下信息：</p>\n<ul>\n<li>能使用的运算符。</li>\n<li>能使用的运算符总数量。</li>\n<li>能使用的常数的值域范围。</li>\n<li>变量类型。</li>\n<li>能否使用控制语句（如 <code>if</code> ）等。</li>\n</ul>\n<h3 id=\"测试\">（2）测试</h3>\n<ul>\n<li><p>除了 <code>bits.c</code> ，你不应该编辑任何其余文件。</p></li>\n<li><p>完成谜题后，需要检验自己的代码是否正确：</p>\n<ul>\n<li><p>首先，执行下述指令，检查每个函数使用的运算符类型、数目是否符合要求：</p></li>\n<li><p>```shell ./dlc -e bits.c <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 如没有任何报错，按顺序执行下述指令，测试每个函数的正确性：</span><br><span class=\"line\"></span><br><span class=\"line\">* ```shell</span><br><span class=\"line\">  make clean</span><br><span class=\"line\">  make all</span><br><span class=\"line\">  ./btest</span><br></pre></td></tr></table></figure></p></li>\n<li><p><code>btest</code>\n执行时会给出每个谜题（函数）是否通过测试（未通过时会给出测试数据），并且会计算你的最终得分。</p></li>\n</ul></li>\n<li><p>你可以利用上 <code>./ishow</code> 和 <code>./fshow</code>\n来帮助你调试（用法见 <code>README</code>）。</p></li>\n</ul>\n<h2 id=\"四提交实验\">四、提交实验</h2>\n<h3 id=\"内容要求\">（1）内容要求</h3>\n<p>你需要提交至少两份文件，包含你的 <code>bits.c</code>\n和一份实验报告。</p>\n<p>实验报告应该包含以下内容：</p>\n<ul>\n<li><p>实验标题，你的姓名，学号。</p></li>\n<li><p>你在终端中执行 <code>./dlc -e bits.c</code> 后的截图。</p></li>\n<li><p>你在终端中执行 <code>./btest</code> 后的截图。</p></li>\n<li><p>描述你实现每个函数的思路。bits.c中不要求给自己的代码写注释（写了也无妨）</p></li>\n<li><p>如果有，请务必在报告中列出引用的内容以及参考的资料。</p></li>\n<li><p>对本实验的感受（可选）。</p></li>\n<li><p>对助教们的建议（可选）。</p></li>\n</ul>\n<h3 id=\"格式要求\">（2）格式要求</h3>\n<p>可提交 <code>.md</code> 文件或者 <code>.pdf</code> 文件。不要提交\n<code>.doc</code> 或 <code>.docx</code> 文件。<br />\n（如果提交 <code>.md</code>\n文件，请确保助教能同时看到你报告中的截图！）</p>\n<h3 id=\"上传\">（3）上传</h3>\n<p>在终端运行以下指令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -A</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">提交当前文件夹下的所有更改到暂存区</span></span><br><span class=\"line\">git commit -m &quot;xxx(可以是你的提交注释)&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将暂存区的所有更改提交到本地仓库</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将本地仓库推送到远程</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"打分规则\">（4）打分规则</h3>\n<ul>\n<li>实验报告要求简洁清晰，不必追求字数，描述清楚思路即可</li>\n<li>对每道谜题请先做思考，不要立即使用搜索引擎。</li>\n<li>不允许抄袭其它人的代码，一旦发现，零分处理。</li>\n</ul>\n<h2 id=\"五参考资料\">五、参考资料</h2>\n<ul>\n<li><p>http://csapp.cs.cmu.edu/3e/labs.html （lab\n来源，本实验相较原文件有改动）</p></li>\n<li><p>本文档编写时参考了22, 23年的实验文档。</p></li>\n<li><p>负责助教:</p>\n<ul>\n<li>伊凡 21307130047@m.fudan.edu.cn</li>\n<li>李增昊 22307130108@m.fudan.edu.cn</li>\n</ul></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Deadline: 2024.10.10 8:00AM</p>\n</blockquote>\n<h2 id=\"一实验简介\">一、实验简介</h2>\n<p>CSAPP 第一章配套实验。</p>\n<p>本实验的目的是加深同学们对整数和浮点数二进制表示的认识。同学们需要解出若干程序谜题，编写代码并通过正确性测试，最后提交代码和报告。希望同学们多加思考，在解题过程中能学到的远不止二进制本身，还能加深对位运算的理解，以及学到一些算法知识。</p>\n<p>本实验分为常规部和荣誉部分。荣誉部分的难度较高，是本课程比较有挑战性的部分。</p>\n<p>荣誉部分虽然占分，但是占分并不高，大家可以自己决定要不要做荣誉部分。Use\nyour discretion！</p>\n<h2 id=\"二部署实验环境\">二、部署实验环境</h2>\n<h3 id=\"下载\">（1）下载</h3>\n<p>从 <code>github classroom</code> 拉取<code>ICS2024_datalab</code>\n文件夹，其中的内容就是本次实验用到的的文件了，拉取指令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone xxx  # 将 xxx 替换为对应链接</span><br><span class=\"line\">cd ICS2024_datalab</span><br></pre></td></tr></table></figure>\n<h3 id=\"准备工作\">（2）准备工作</h3>\n<h4 id=\"确保已安装了-gcc\">- 确保已安装了 gcc</h4>\n<p>在终端中检查是否安装了 gcc：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -v</span><br></pre></td></tr></table></figure>\n<p>如果已安装，终端将会反馈版本信息，否则会反馈\n<code>command not found</code> 。</p>\n<p>如未安装，尝试执行以下命令进行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gcc</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保已安装了-make\">- 确保已安装了 make</h4>\n<p>检查是否安装 make，在终端输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make -v</span><br></pre></td></tr></table></figure>\n<p>同理，如未安装，尝试以此执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install make</span><br><span class=\"line\">sudo apt-get install libc6 libc6-dev libc6-dev-i386</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保实验文件能正常-make-并运行测试\">- 确保实验文件能正常 make\n并运行测试</h4>\n<p>在终端中进入 <code>datalab/</code> 文件夹目录。</p>\n<p>键入 <code>ls</code> 查看内容，你应当看到如下文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Driverhdrs.pm  Makefile  bits.c  btest.c  decl.c  driver.pl  ishow.c</span><br><span class=\"line\">Driverlib.pm   README    bits.h  btest.h  dlc     fshow.c    tests.c</span><br></pre></td></tr></table></figure>\n<p>在终端中依次执行如下命令，以生成可执行文件并执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make clean</span><br><span class=\"line\">make all</span><br><span class=\"line\">./btest</span><br></pre></td></tr></table></figure>\n<p>如果过程顺利，最后会输出测试结果，最后一行为\n<code>Total points: 0/69</code> 。</p>\n<p>如果过程中出现如下报错：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ld: cannot found -lgcc</span><br></pre></td></tr></table></figure>\n<p>那么尝试执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install gcc-multilib</span><br></pre></td></tr></table></figure>\n<h4 id=\"确保-dlcdata-lab-compiler能正常执行\">- 确保 dlc（data lab\ncompiler）能正常执行</h4>\n<p>依然在 <code>datalab/</code> 目录下，</p>\n<p>执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./dlc bits.c</span><br></pre></td></tr></table></figure>\n<p>如果遇到\n<code>./dlc: Permission denied</code>，说明没有当前文件的执行权限，执行:\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x dlc</span><br></pre></td></tr></table></figure> 增加执行权限。</p>\n<p>如果执行立即结束并且没有任何反馈，则没有问题。</p>\n<h2 id=\"三实验提示与说明\">三、实验提示与说明</h2>\n<h3 id=\"如何入手\">（1）如何入手</h3>\n<p>推荐阅读顺序：本文档 &gt; <code>README</code> &gt;\n<code>bits.c</code> 的注释部分。</p>\n<p><code>README</code> 文档中对实验文件做了较为详细的介绍。</p>\n<p><code>bits.c</code>\n是同学们唯一需要编辑的文件，其中包含了谜题规则介绍， 18\n个谜题以及谜题内容、难度、分数等。</p>\n<p>上面的两个文件请务必仔细阅读。</p>\n<p>注意到，每一个谜题包含了如下信息：</p>\n<ul>\n<li>能使用的运算符。</li>\n<li>能使用的运算符总数量。</li>\n<li>能使用的常数的值域范围。</li>\n<li>变量类型。</li>\n<li>能否使用控制语句（如 <code>if</code> ）等。</li>\n</ul>\n<h3 id=\"测试\">（2）测试</h3>\n<ul>\n<li><p>除了 <code>bits.c</code> ，你不应该编辑任何其余文件。</p></li>\n<li><p>完成谜题后，需要检验自己的代码是否正确：</p>\n<ul>\n<li><p>首先，执行下述指令，检查每个函数使用的运算符类型、数目是否符合要求：</p></li>\n<li><p>```shell ./dlc -e bits.c <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 如没有任何报错，按顺序执行下述指令，测试每个函数的正确性：</span><br><span class=\"line\"></span><br><span class=\"line\">* ```shell</span><br><span class=\"line\">  make clean</span><br><span class=\"line\">  make all</span><br><span class=\"line\">  ./btest</span><br></pre></td></tr></table></figure></p></li>\n<li><p><code>btest</code>\n执行时会给出每个谜题（函数）是否通过测试（未通过时会给出测试数据），并且会计算你的最终得分。</p></li>\n</ul></li>\n<li><p>你可以利用上 <code>./ishow</code> 和 <code>./fshow</code>\n来帮助你调试（用法见 <code>README</code>）。</p></li>\n</ul>\n<h2 id=\"四提交实验\">四、提交实验</h2>\n<h3 id=\"内容要求\">（1）内容要求</h3>\n<p>你需要提交至少两份文件，包含你的 <code>bits.c</code>\n和一份实验报告。</p>\n<p>实验报告应该包含以下内容：</p>\n<ul>\n<li><p>实验标题，你的姓名，学号。</p></li>\n<li><p>你在终端中执行 <code>./dlc -e bits.c</code> 后的截图。</p></li>\n<li><p>你在终端中执行 <code>./btest</code> 后的截图。</p></li>\n<li><p>描述你实现每个函数的思路。bits.c中不要求给自己的代码写注释（写了也无妨）</p></li>\n<li><p>如果有，请务必在报告中列出引用的内容以及参考的资料。</p></li>\n<li><p>对本实验的感受（可选）。</p></li>\n<li><p>对助教们的建议（可选）。</p></li>\n</ul>\n<h3 id=\"格式要求\">（2）格式要求</h3>\n<p>可提交 <code>.md</code> 文件或者 <code>.pdf</code> 文件。不要提交\n<code>.doc</code> 或 <code>.docx</code> 文件。<br />\n（如果提交 <code>.md</code>\n文件，请确保助教能同时看到你报告中的截图！）</p>\n<h3 id=\"上传\">（3）上传</h3>\n<p>在终端运行以下指令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -A</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">提交当前文件夹下的所有更改到暂存区</span></span><br><span class=\"line\">git commit -m &quot;xxx(可以是你的提交注释)&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将暂存区的所有更改提交到本地仓库</span></span><br><span class=\"line\">git push</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将本地仓库推送到远程</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"打分规则\">（4）打分规则</h3>\n<ul>\n<li>实验报告要求简洁清晰，不必追求字数，描述清楚思路即可</li>\n<li>对每道谜题请先做思考，不要立即使用搜索引擎。</li>\n<li>不允许抄袭其它人的代码，一旦发现，零分处理。</li>\n</ul>\n<h2 id=\"五参考资料\">五、参考资料</h2>\n<ul>\n<li><p>http://csapp.cs.cmu.edu/3e/labs.html （lab\n来源，本实验相较原文件有改动）</p></li>\n<li><p>本文档编写时参考了22, 23年的实验文档。</p></li>\n<li><p>负责助教:</p>\n<ul>\n<li>伊凡 21307130047@m.fudan.edu.cn</li>\n<li>李增昊 22307130108@m.fudan.edu.cn</li>\n</ul></li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/BombLab/PlotAdvices.png","post":"cm2yhehkf0001rzx4gfsjftu8","slug":"PlotAdvices.png","modified":1,"renderable":1},{"_id":"source/_posts/BombLab/cfg.png","post":"cm2yhehkf0001rzx4gfsjftu8","slug":"cfg.png","modified":1,"renderable":1},{"_id":"source/_posts/BombLab/meme.jpg","post":"cm2yhehkf0001rzx4gfsjftu8","slug":"meme.jpg","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/Driverhdrs.pm","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"Driverhdrs.pm","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/Driverlib.pm","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"Driverlib.pm","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/Makefile","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"Makefile","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/README","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"README","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/bits.c","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"bits.c","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/bits.h","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"bits.h","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/btest.c","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"btest.c","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/btest.h","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"btest.h","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/decl.c","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"decl.c","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/dlc","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"dlc","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/driver.pl","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"driver.pl","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/fshow.c","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"fshow.c","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/ishow.c","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"ishow.c","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/tests.c","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"tests.c","modified":1,"renderable":1},{"_id":"source/_posts/DataLab/tmp.md","post":"cm2yhehkl0003rzx47jnhfuk2","slug":"tmp.md","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/1.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/10.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/11.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/2.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/3.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/4.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/5.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/6.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"6.png","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/7.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/8.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"8.png","modified":1,"renderable":1},{"_id":"source/_posts/GitLab/9.png","post":"cm2yhehkl0004rzx4fywkcu3z","slug":"9.png","modified":1,"renderable":1},{"_id":"source/_posts/StackLab/task3_result.gif","post":"cm2yhehkn0006rzx48k1ycw63","slug":"task3_result.gif","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[],"Tag":[]}}